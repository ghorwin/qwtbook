:imagesdir: ../images

# Erste Schritte und ein interaktives Diagramm

Um mit der Qwt-Bibliothek warm zu werden, erstellen wir in einem einfachen Beispiel ein interaktives Diagramm mit der `QwtPlot`-Komponente.

## Programmrohbau

### QMake Projektdatei

Wir beginnen mit der qmake-Projektdatei, in der wir den Pfad für die Header-Dateien der Bibliothek und die zu linkende Bibliothek festlegen.

[source,sh]
----
TARGET   = Tutorial1
QT       += core gui widgets
CONFIG   += c++11

# Pfad zu den Qwt Headerdateien hinzufügen
INCLUDEPATH += C:/qwt-6.3.0/include

CONFIG(debug, debug|release) {
	QWTLIB = qwtd
}
else {
	QWTLIB = qwt
}

# Linkerpfad
LIBS += -LC://qwt-6.3.0/lib -l$$QWTLIB

SOURCES += main.cpp
----

Dies ist eine `.pro`-Datei für eine typische Windows-Installation der Qwt-Bibliothek (siehe <<sec:buildingFromSource>>). Unter Linux würden `INCLUDEPATH` und `LIBS` bei Installation der Qwt-Lib nach `/usr/local/share` eher so aussehen.

[IMPORTANT]
====
Beachte, dass die im Debug-Modus kompilierte Qwt-Bibliothek ein angehängtes d hat.
====

### Minimalistisches Hauptprogramm

Für die Verwendung des `QwtPlot` braucht man nur eine sehr minimalistische `main.cpp`.

.Hauptprogramm, in dem nur das nackige Plot selbst erstellt und angezeigt wird
[source,cpp]
----
#include <QApplication>

#include <QwtPlot>

int main(int argc, char *argv[]) {
	QApplication a(argc, argv);
	QwtPlot plot;
	plot.resize(800,500);
	plot.show();
	return a.exec();
}
----

[TIP]
====
Wenn man das Programm compiliert hat und ausführen will, beklagt sich Windows über eine fehlende DLL.
Dazu in den Projekteinstellungen, unter "Ausführen", im Abschnitt "Umgebung" die PATH-Variable bearbeiten und dort den Pfad `C:\qwt-6.3.0\lib` hinzufügen. 
====

Das Programm zeigt ein ziemlich langweiliges (und hässliches) Diagrammfenster (später wird das noch ansehnlicher gestaltet).

.Das nackte Plotwidget
image::Tutorial1_a.png[pdfwidth=6cm]


## Diagrammelemente hinzufügen

### Linie hinzufügen

Als erstes fügen wir eine Linie bzw. Diagrammkurve hinzu:

.Hauptprogramm mit einer Linie
[source,cpp]
----
#include <QApplication>

#include <QwtPlot>
#include <QwtPlotCurve>

int main(int argc, char *argv[]) {
	QApplication a(argc, argv);
	QwtPlot plot;
	plot.resize(500,300);

	// etwas Abstand zwischen Rand und Achsentiteln
	plot.setContentsMargins(8,8,8,8);
	// Hintergrund der Zeichenfläche soll weiß sein
	plot.setCanvasBackground( Qt::white );

	// Daten zum Darstellen
	QVector<double> x = {0,4,5,10,12};
	QVector<double> y = {5.1,4,6.8,6.5,5.2};

	QwtPlotCurve *curve = new QwtPlotCurve();
	curve->setPen(QColor(180,40,20), 0);
	curve->setTitle("Line 1");
	curve->setRenderHint( QwtPlotItem::RenderAntialiased, true ); // Antialiasing verwenden
	curve->setSamples(x, y);
	curve->attach(&plot); // Plot takes ownership

	plot.show();
	return a.exec();
}
----

Im erweiterten Hauptprogramm wird zunächst der Header für die `QwtPlotCurve` eingebunden. Das Kurvenobjekt selbst wird mit `new` auf dem Heap erstellt. Attribute wie Linienfarbe, Titel (wird später in der Legende angezeigt), und Antialising werden gesetzt (im <<sec:linecurves>> werden alle Eigenschaften von Linien im Detail erläutert). 

Die Funktion `setSamples()` setzt die Daten der Linie. Wichtig ist hier, dass die übergebenen Vectoren die gleiche Länge haben. Es handelt sich um eine parametrische Kurve, d.h. weder x noch y Werte müssen monoton sein oder sonstwelchen Regeln folgen. Jedes x,y Wertepaar definiert einen Punkt und diese Punkte werden mit der Linie verbunden.

Die Funktion `attach()` fügt das `QwtPlotCurve`-Objekt zum Diagramm hinzu.

[IMPORTANT]
====
Beim Hinzufügen der Linie mittels `attach()` zum Diagramm wird das Plot neuer Eigentümer und kümmert sich um das Aufräumen des Speichers. Man muss also nicht mehr manuell `delete` für das `QwtPlotCurve`-Objekt aufrufen.
====

Zusätzlich zu dem Code, welcher die Linie hinzufügt, wurden noch 2 kleine Anpassungen am Erscheinungsbild vorgenommen:

- Ränder wurden mittels `setContentsMargins()` hinzugefügt (siehe auch `QWidgdet::setContentsMargins()` )
- der Hintergrund der Zeichenfläche (_canvas_) wurde weiß gefärbt.

Das Ergebnis sieht schon eher nach Diagramm aus.

.Diagramm mit Linie
image::Tutorial1_b.png[pdfwidth=6cm]

### Legende hinzufügen

Als nächstes wird eine Legende eingefügt:

[source,cpp]
----
// Legende anzeigen
QwtLegend * legend = new QwtLegend();
plot.insertLegend( legend , QwtPlot::BottomLegend); // plot takes ownership
----

Auch hier wird oben wieder der Header für die Klasse `QwtLegend` eingebunden.

Die Legende kann links, rechts, oberhalb oder unterhalb der Zeichenfläche liegen, oder in der Zeichenfläche selbst. Das Anpassen der Legende wird in <<sec:legend>> beschrieben.

### Diagrammtitel hinzufügen

[source,cpp]
----
// Titel hinzufügen
QwtText text("Ein Beispieldiagramm");
QFont titleFont;
titleFont.setBold(true);
titleFont.setPointSize(10);
text.setFont(titleFont);
plot.setTitle(text);
----

### Diagrammraster hinzufügen

Gitterlinien werden durch das Zeichenobjekt `QwtPlotGrid` gezeichnet:

[source,cpp]
----
// Hauptgitter anzeigen
QwtPlotGrid *grid = new QwtPlotGrid();
QPen gridPen(Qt::gray);
gridPen.setStyle(Qt::DotLine);
gridPen.setWidth(0);
grid->setPen(gridPen);
grid->attach( plot ); // plot takes ownership
----

[TIP]
====
Man kann auch mehrere Raster hinzufügen, z.B. eins für Hauptgitterlinien und eines für Nebengitterlinien.
====

Inzwischen sieht das Diagramm schon ganz ansehnlich aus.

.Diagramm mit Linie, Legende, Titel und Gitterlinien
image::Tutorial1_c.png[pdfwidth=6cm]


## Interaktion mit dem Diagramm







## Das QwtPlot in eine Designer-Oberfläche/ui-Datei integrieren

Wenn man mittels Qt Designer eine Programmoberfläche baut, möchte man da vielleicht auch ein `QwtPlot` einbetten. Das kann man auf zwei verschiedene Arten machen:

a. ein QWidget als Platzhalter einfügen und zu einem Platzhalterwidget für das `QwtPlot` machen, oder
b. die Qwt-Designer-Plugins verwenden.

### Definition eines Platzhalterwidgets

Zur Erklärung wird im Qt Designer ein einfaches Widget entworfen:

.Widget mit Platzhalter-Widget für das Diagramm
image::Tutorial1_ui1.png[pdfwidth=8cm]

Unter der Spinbox wurde ein `QWidget` eingefügt. Dieses soll nun als Platzhalter für das `QwtPlot` dienen. Dazu im Kontextmenü des Widgets die Option "Als Platzhalter für benutzerdefinierte Klasse festlegen..." auswählen:

image::Tutorial1_ui2.png[pdfwidth=6cm]

Und im Dialog eine neue Platzhalterklasse wie folgt definieren:

image::Tutorial1_ui3.png[pdfwidth=6cm]

Die Eingabe mit "Hinzufügen" bestätigen und dann auf "Anwenden" klicken, um das Platzhalter-Widget in das `QwtPlot` zu wandeln. Wir benennen das noch in _plot_ um, und füge das horizontale Layout und das Plotwidget in ein vertikales Layout ein:

image::Tutorial1_ui4.png[pdfwidth=8cm]

Damit sich das Plotwidget den ganzen vertikalen Platz schnappt, wählt man das Top-Level Widget aus und scrollt in der Eigenschaftsleiste bis nach unten zu den Einstellungen für das vertikale Layout. Dort gibt man bei den Stretch-Faktoren "0,1" ein, wodurch sich das 2. Widget im Layout (das Plot) komplett ausdehnt.

### Verwendung der Designer-Plugins

Wenn man die erstmal installiert hat (siehe <<sec::designerPlugins>>), kann man ein `QwtPlot` direkt aus der Komponentenpalette in den Entwurf zeihen und ist fertig.





