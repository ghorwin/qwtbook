:imagesdir: ../images

[[sec:linecurves]]
# Kurvendiagramme

Die wohl häufiges Diagrammart werden wohl Kurvendiagramme sein. Kurvendiagramme bzw. Liniendiagramme sind parametrische Kurven, bei denen die einzelnen Punkte nacheinander gezeichnet werden, und im Fall von Liniendiagrammen durch Linien verbunden werden. Weder x- noch y-Werte müssen monoton steigen.

Das Zeichenelement `QwtPlotCurve` wird jedoch nicht nur für Liniendiagramme im klassischen Sinn benutzt, sondern auch für Stufen, Stäbchen, Punkt/Symbol-Diagramme und so weiter. Alle diese Varianten haben jedoch gemein, dass sie als Daten einen x- und einen y-Vector mit Daten in Plotkoordinaten erwarten.

Der individuelle Stil der Kurve wird mit der Funktion `QwtPlotCurve::setStyle()` festgelegt. Je nach Stil können/müssen weitere Parameter festgelegt werden. In den folgenden Abschnitten werden die möglichen Diagrammtypen für jeweils die gleichen x/y-Daten im Vergleich gezeigt. 

.Testdaten für die nachfolgenden Diagramme
[width="25%",options="header", colwidths="10%,10%"]
|====================
|  x |  y
|	1	|	5
|	2	|	4
|	5	|	8
|	6	|	8
|	10	|	4
|	12	|	5
|	15	|	8
|	16	|	9
|	17	|	11
|====================

## Datenübergabe
Wie in <<sec:seriesData>> erklärt, wird für die interne Datenhaltung in `QwtPlotCurve` die Klasse `QwtSeriesStore<QPointF>` verwendet.

Daten kann man nun auf mehrere Arten der Plot-Kurve übergeben:

.Verwendung zweier QVector<double> (oder analog QVector<float>)
```c++
QVector<double> x{1,2,5,6,10,12,15,16,17};
QVector<double> y{5,4,8,8, 4, 5, 8, 9,11};
curve->setSamples(x, y);
```

.Verwendung eines QVector<QPointF>
```c++
QVector<QPointF> samples{
	QPointF(1,5),
	QPointF(2,4),
	QPointF(5,8)
};
curve->setSamples(samples);
```

Wenn die Daten in einem C-Array oder `std::vector` vorliegen, bietet sich `QwtPlotCurve::setSamples()` an.

.Übergabe der Daten direkt im Speicher
```c++
std::vector<double> x{1,2,5,6,10,12,15,16,17};
std::vector<double> y{5,4,8,8, 4, 5, 8, 9,11};
const double * xdata = x.data();
const double * ydata = y.data();
unsigned int count = x.size();

curve->setSamples(xdata, ydata, count);
```

[IMPORTANT]
====
Bei der Verwendung von `QwtPlotCurve::setSamples()` werden die Daten _immer_ in den interne `QwtSeriesStore` der Plot-Kurve _kopiert_, auch wenn man hier direkt die Adresse des Speichers mit den Daten übergibt.
====


Bei sehr großen Datenmengen und begrenztem Hauptspeicher kann es sinnvoll sein, die Daten nicht in das Plot hineinzukopieren, sondern die Plotkurven direkt auf den Speicher zugreifen zu lassen. Dafür gibt es die Funktion `QwtPlotCurve::setRawSamples()`. Die Syntax ist wie beim vorherigen Beispiel:

.Direkte Verwendung der im Speicher befindlichen Daten durch as Plot
```c++
const double * xdata = x.data(); // x ist ein std::vector
const double * ydata = y.data(); // y ist ein std::vector
unsigned int count = x.size();
curve->setRawSamples(xdata, ydata, count);
```

[CAUTION]
====
Die Variablen und deren Speicherbereich, welche im Aufruf von `setRawSamples()` verwendet werden, müssen eine längere Lebensdauer haben, als das Plot bzw. die Plotkurve selbst.
====

Direkte Änderung der Daten im Speicher wird beim nächsten Rendern des Plots direkt sichtbar. Allerdings müssen das Plot und dessen  Zeichenelemente, die ein Interesse an den Wertebereichen der Plotkurven haben, manuell über eine Änderung der Daten information werden. Dazu einfach `QwtPlot::replot()`.





## Liniendiagramm

Konfiguration einer `QwtPlotCurve` als Linie:

```c++
QwtPlotCurve *curve = new QwtPlotCurve();
curve->setStyle(QwtPlotCurve::Lines);
```

.Liniendiagramm
image::PlotCurves_StyleLines.png[pdfwidth=5cm]
 
## Stäbchen (Sticks)

Konfiguration einer `QwtPlotCurve` als vertikale Stäbchen:

```c++
QwtPlotCurve *curve = new QwtPlotCurve();
curve->setStyle(QwtPlotCurve::Lines);
curve->setOrientation(Qt::Vertical);
```

.Vertikale Stäbchen
image::PlotCurves_StyleSticksVertical.png[pdfwidth=5cm]

Alternativ kann man die Stäbchen auch horizontal zeichnen. Dazu muss man zusätzlich die Ausrichtung mit `QwtPlotSeriesItem::setOrientation()` setzen:

```c++
QwtPlotCurve *curve = new QwtPlotCurve();
curve->setStyle(QwtPlotCurve::Lines);
curve->setOrientation(Qt::Horizontal);
```

.Horizontale Stäbchen
image::PlotCurves_StyleSticksHorizontal.png[pdfwidth=5cm]


## Stufendiagramme

Wenn die Daten nicht linear verbunden werden sollen, sondern eher Stufen darstellen, kann man den Linientyp `Steps` verwenden.
Das Zusatz-Attribut `QwtPlotCurve::Inverted` gibt dabei an, ob die Stufe am Ende des Intervals oder Anfang des Intervals sein soll. Kurvenattribute werden mit `QwtPlotCurve::setCurveAttribute()` gesetzt:

```c++
QwtPlotCurve *curve = new QwtPlotCurve();
curve->setStyle(QwtPlotCurve::Steps);
curve->setCurveAttribute(QwtPlotCurve::Inverted, false);
```

.Stufendiagramm (normal)
image::PlotCurves_StyleSteps.png[pdfwidth=5cm]


Betrachtet man die Eingangsdaten:

```
x   y
1   5
2   4
5   8
...
``` 

so fällt auf, dass im ersten Intervall, also zwischen x=1..2, der Wert y2=4 gezeichnet wird und an der Stelle x1=1 die Verbindungslinie zwischen y1=5 und y2=4 gezeichnet wird.

Will man direkt den ersten y-Wert im ersten Intervall zeichnen (das wäre eher die natürliche Erwartungshaltung), so muss man das Attribut `Inverted` setzen:

```c++
QwtPlotCurve *curve = new QwtPlotCurve();
curve->setStyle(QwtPlotCurve::Steps);
curve->setCurveAttribute(QwtPlotCurve::Inverted, true);
```

.Stufendiagramm (invertiert)
image::PlotCurves_StyleStepsInverted.png[pdfwidth=5cm]


## Punkte (Dots)

Man kann an den jeweiligen x,y-Koordinaten auch einfach nur Punkte (auch nur einzelne Pixel) zeichnen. Das geht _sehr schnell_ vergleichen mit dem Zeichnen von Symbolen (siehe <<sec:plotSymbols>>) und kann für größere Punktwolken verwendet werden.

[TIP]
====
Bei der Verwendung von `QwtPlotCurve::Dots` sollte man bei heute üblichen Bildschirmauflösungen immer einen `QPen` mit größerer Breite einstellen, da mein _einzelne Pixel_ sonst nur noch schwer sehen kann. Für die Visualisierung großer Punktwolken (> 100000 Pixel) kann die Verwendung von einzelnen Pixeln durchaus noch einen Mehrwert bieten. Für alle besonderen Formen (Kreuze, Rauten, Ringe, Sterne, ...)  ist die Verwendung von Symbolen (siehe <<sec:plotSymbols>>) sinnvoll.
====


```c++
QwtPlotCurve *curve = new QwtPlotCurve();
curve->setStyle(QwtPlotCurve::Dots);
curve->setPen(QColor(180,40,20), 4); // width of 4 makes points better visible
```

.Punktediagramm
image::PlotCurves_StyleDots.png[pdfwidth=5cm]

[TIP]
====
Bei der Visualisierung von Punktwolken kann es hilfreich sein, Transparenz/Alphablending zu benutzen. Dazu einfach bei der Zeichenfarbe noch einen Alphawert kleiner als 255 setzen.
====

```c++
QwtPlotCurve *curve = new QwtPlotCurve();
curve->setStyle(QwtPlotCurve::Dots);
curve->setPen(QColor(0,40,180,32), 2); // 2 pixels wide, alpha value 32
```

.Punktwolke mit halbtransparenten Punkten
image::PlotCurves_StyleDotsScatter.png[pdfwidth=5cm]

[TIP]
====
Wenn man ein Liniendiagramm mit Visualisierung von Stützstellen erhalten will, so kann man natürlich _zwei_ Linien ins Diagramm einfügen: eine mit Stil `QwtPlotCurve::Lines` und die zweite mit Stil `QwtPlotCurve::Dots` darüber, d.h. mit höherem z-Wert, zeichnen. Dann muss man aber auch zwei mal die Daten ins Diagramm geben und man erhält auch zwei Legendeneinträge (die kann man zwar abschalten, siehe <<sec:legend>>, aber trotzdem). Besser ist hier die Verwendung von nur einer Kurve und Symbolen an den Stützstellen (siehe <<sec:plotSymbols>>).
====

## Keine Linie

Möchte man eine Kurve ausschließlich mit Symbolen zeichnen (siehe nachfolgendes Kapitel), so kann man das Zeichnen des Linienzugs auch komplett ausstellen:

```c++
curve->setStyle(QwtPlotCurve::NoCurve);
```


[[sec:plotSymbols]]
## Symbole/Punkte

An den jeweiligen x,y-Koordinaten einer Kurve kann man auch Symbole zeichnen. Dafür bietet die Qwt-Bibliothek die Klasse `QwtSymbol` an.


Ein Symbol fügt man zu eine Kurve wie folgt hinzu:

```c++
// Symbol hinzufügen
QwtSymbol * symbol = new QwtSymbol(QwtSymbol::Ellipse);
symbol->setSize(8);
symbol->setPen(QColor(0,0,160), 2);
symbol->setBrush(QColor(120,170,255));
curve->setSymbol(symbol); // Curve takes ownership of symbol
```

.Liniendiagramm mit ausgefüllten Kreissymbolen
image::Symbols_EllipseFilled.png[pdfwidth=5cm]

Zuerst wird das zu verwendende Symbol auf dem Heap mit new erzeugt. Der Konstruktor übernimmt den Typ des Symbols (siehe auch Galerie unten). Man kann das aber auch später über `QwtSymbol::setStyle()` setzen.

Wichtig ist auch die Größe des Symbols, gesetzt mittels `QwtSymbol::setSize()` in Pixeln. Diese Größe skaliert das Symbol je nach Form.

Außerdem wichtig sind die Eigenschaften Pen und Brush (`QwtSymbol::setPen()` und `QwtSymbol::setBruch()`). Der Pen wird für das Zeichnen des Umrisses verwendet und der Brush, so gesetzt, für das Ausfüllen der Form. Manche Symbole wie das Kreuz sind nicht ausgefüllt, daher hat hier der Brush keine Wirkung.

Schließlich wird das Symbol der Kurve mit `QwtPlotCurve::setSymbol()` gegeben.

[IMPORTANT]
====
Beim Aufruf von `QwtPlotCurve::setSymbol()` übernimmt die Plot-Kurve die Verantwortung für's Speicheraufräumen.
====

Die Symbolklasse ist ziemlich mächtig und kann verschiedenste Symbole zeichnen:

- vorgefertigte Formen wie Kreise, Rechtecke, Kreuze, etc. (Stil `QwtSymbol::Ellipse`...`QwtSymbol::Hexagon`
- nutzerdefinierte Bilder/Pixmaps (Stil `QwtSymbol::Pixmap`)
- spezifische Grafiken gekapselt in Klasse `QwtGraphic` und erzeugt durch eine Anzahl von `QwtPainterCommand` Anweisungen (Stil `QwtSymbol::Graphic`) (siehe auch <<sec:qwtGraphic>>)
- SVG-Dokumente (Stil `QwtSymbol::SvgDocument`)
- nutzerdefinierte Formen, welche durch einen QPainterPath definiert sind (Stil `QwtSymbol::Path`)


### Symbolstile/Eingebauten Symbolformen

Es gibt zahlreiche eingebaute Symbolformen (fett gedruckt im Diagrammtitel ist jeweils der `QwtSymbol::Style` Enumerationsname):

.Eingebaute Symboltypen/Stile und deren Enumerationstypen
image::Symbols_Gallery.png[pdfwidth=16cm]


Symbole müssen nicht immer quadratisch sein. Wenn man die Größe eines Symbols mit

```c++
symbol->setSize(10);
```

setzt, wird automatisch `width=height=10` verwendet. Alternativ kann man aber auch ein Rechteck als Größe definieren:

```c++
symbol->setSize(w,h);
// oder via QSize
QSize s(w,h);
symbol->setSize(s);
```

Deshalb gibt es auch keine separaten Linienstile für Kreis und Ellipse oder Rechteck und Quadrat.

### Nutzerdefinierte Formen via QPainterPath

Man kann beliebige eigene Symbolformen setzen, indem man die Klasse `QPainterPath` verwendet.
Folgendes Beispiel generiert ein Glühlampensymbol:

```c++
// Symbol hinzufügen
QwtSymbol * symbol = new QwtSymbol(QwtSymbol::Path);
QPainterPath p;
p.addEllipse(QRectF(-10,-10,20,20));
p.moveTo(-7,-7);
p.lineTo(7,7);
p.moveTo(7,-7);
p.lineTo(-7,7);
symbol->setPath(p);
symbol->setPen(QColor(0,0,120), 2);
symbol->setBrush(QColor(160,200,255));
curve->setSymbol(symbol); // Curve takes ownership of symbol
```

.Eigenes Symbol definiert mittels QPainterPath
image::Symbols_PainterPath.png[pdfwidth=5cm]

[CAUTION]
====
Wenn man eine nicht-rechteckige Geometrie mit QPainterPath definiert, sollte man beim Ändern der Größe mittels `QwtSymbol::setSize()` die Variante mit den zwei Argumenten aufrufen, also `QwtSymbol::setSize(width,height)`. Die Variante mit nur einem Argument transformiert den Pfad onst auf ein Quadrat. Da man üblicherweise keine nicht-quadratischen Formen als Symbol definiert, dürfte das aber nur selten ein Problem sein.
====


### SVG-Symbole

Man kann eigene SVG-Dateien rendern und anzeigen lassen. Dafür muss man nur eine SVG-Datei einlesen/definieren und als Symbol setzen:

```c++
QwtSymbol * symbol = new QwtSymbol(QwtSymbol::SvgDocument);
QFile f("symbol.svg");
f.open(QFile::ReadOnly);
QTextStream strm(&f);
QByteArray svgDoc = strm.readAll().toLatin1();
symbol->setSvgDocument(svgDoc);
curve->setSymbol(symbol); // Curve takes ownership of symbol
```

[CAUTION]
====
Auch hier ist beim Festlegen der Größe wieder auf das Seitenverhältnis zu achten und zumeist die Variante `QwtSymbol::setSize(width,height)` zu verwenden.
====

Manchmal liegt der Ankerpunkt des SVG-Bildes nicht im Zentrum, wie in obigem Beispiel:

.Zentriertes SVG-Symbol, welches eigentlich aber nach oben verschoben sein sollte
image::Symbols_SvgCentered.png[pdfwidth=5cm]

Man kann den Ankerpunkt bzw. den Zentrierpunkt des Symbols aber mit `QwtSymbol::setPinPoint()` ändern. Die Koordinaten des PinPoint werden dabei von links/oben des SVG-Bildes gemessen:

```c++
...
QRect br = symbol->boundingRect(); // size of symbol
symbol->setPinPoint(QPointF(br.width()/2-1,br.height()-3));
```

.SVG-Symbol mit korrekter Ausrichtung des "Stecknadel"-Punktes
image::Symbols_SvgWithPinPoint.png[pdfwidth=5cm]

[TIP]
====
Man kann die manuell gesetzten Ankerpunkt auch wieder mit `QwtSymbol::setPinPointEnabled(false)` deaktivieren.
====


### Bild-Symbole (Pixmaps)

Alternativ zu eigenen Vektorgrafiksymbolen kann man auch beliebige Bilder als Symbole verwenden. Dies geschieht analog zu den SVG-Symbolen:

```c++
QwtSymbol * symbol = new QwtSymbol(QwtSymbol::Pixmap);
QwtText t("QwtSymbol::Pixmap");
QPixmap pixmap;
pixmap.load("symbol.png");
symbol->setPixmap(pixmap);
QRect br = symbol->boundingRect(); // size of symbol
symbol->setPinPoint(QPointF(br.width()/2,br.height()-1));
curve->setSymbol(symbol); // Curve takes ownership of symbol
```

.Pixmap-Symbol, auch mit manuell festgelegtem "Stecknadel"-Punkt
image::Symbols_Pixmap.png[pdfwidth=5cm]


[[sec:intervalCurves]]
## Intervallkurven
Eine spezielle Kurvenart ist die _Intervallkurve_, bereitgestellt über die Klasse `QwtPlotIntervalCurve`.

Im Prinzip ist das eine Kurve mit zwei y-Werten pro x-Koordinate im Datensatz. Es werden zwei reguläre Kurven gezeichnet und dazwischen wird die Fläche ausgefüllt. Dies kann man auch gut dazu nutzen, um gestackte Liniendiagramme zu zeichnen.

.Beispiel für eine Intervallkurve
```c++
QVector<double> x{1,2,5,6,10,12,15,16,17};
QVector<double> y1{2,2,3,4, 2, 4, 4, 5,11};
QVector<double> y2{6,4.4,9,10, 5.5, 5.7, 9, 11,12};

QVector<QwtIntervalSample> intervalSamples;
for (int i=0; i<x.count(); ++i) 
	intervalSamples.append(QwtIntervalSample(x[i],y1[i],y2[i]));

QwtPlotIntervalCurve *curve = new QwtPlotIntervalCurve();
curve->setStyle(QwtPlotIntervalCurve::Tube);
curve->setPen(QColor(0,40,180), 2);
curve->setBrush( QColor(60,200,255) );
curve->setRenderHint( QwtPlotItem::RenderAntialiased, true ); // Antialiasing verwenden
curve->setSamples(intervalSamples);
curve->attach(&plot); // Plot takes ownership
```

.Intervallkurve
image::IntervalCurve.png[pdfwidth=5cm]

Die Funktion `setSamples()` gibt es in zwei Varianten:

- `QwtPlotIntervalCurve::setSamples( const QVector< QwtIntervalSample >& )` : erwartet einen Vektor mit Interval-Samples, bestehend aus x-Koordinate, unterem und oberen y-Wert
- `QwtPlotIntervalCurve::setSamples( QwtSeriesData< QwtIntervalSample >* )` : erwartet ein `QwtSeriesData` Objekt (siehe <<sec:seriesData>>) welches Eigentum der Intervallkurve wird. Diese Funktion entspricht der Funktion `setData()` der Elternklasse `QwtSeriesStore`.

Man kann das Erscheinungsbild noch etwas Aufwerten, wenn man für die Füllung der Kurve einen Gradienten verwendet. Dafür gibt man der Kurve einfach einen `QBrush`, der mit einem Gradienten erstellt wurde.

```c++
...
QLinearGradient grad(0,90,0,220);
grad.setColorAt(0, QColor(60,200,255));
grad.setColorAt(1, QColor(0,60,120));
curve->setBrush( QBrush(grad));
...
```

.Intervallkurve mit Gradientenfüllung
image::IntervalCurve_Gradient.png[pdfwidth=5cm]

[CAUTION]
====
Die Colorstops der Gradienten in Qt werden in Pixelkoordinaten angegeben. Wenn man also das Plot-Fenster vergrößert/verkleinert, dann führt das zu witzigen Effekten.
Die Lösung ist, das QwtPlot in einer eigenen Klasse abzuleiten und im Resize-Event den Gradienten entsprechend anzupassen. Gleiches gilt auch für das interaktive Verschieben/Zoomen im Plotfenster, also immer wenn ich sich die Pixelkoordinaten der gefüllten Fläche ändern.
Insgesamt einfacher ist es, die Klasse `QwtPlotIntervalCurve` abzuleiten und die Zeichenfunktion selbst zu implementieren, siehe auch Beispiel in <<sec:advancedCurves>>.
====

.Intervallkurve mit festem Gradienten bei Änderung der Plotgeometrie

image:IntervalCurve_Gradient_200.png[Height200,200,400,pdfwidth=5cm]
image:IntervalCurve_Gradient_300.png[Height300,200,400,pdfwidth=5cm]
image:IntervalCurve_Gradient_400.png[Height400,200,400,pdfwidth=5cm]


## Gestapelte (Intervall-)Kurven/Flächendiagramme

Man kann die Intervallkurven auch nutzen, um gestapelte, ausgefüllte Kurven bzw. Flächendiagramme zu erstellen. Dazu erstellt man einfach mehrere `QwtPlotIntervalCurve` Zeichenelemente, die sich jeweils die gleichen Y-Werte teilen.

```c++
QVector<double> x{1,2,5,6,10,12,15,16,17};
QVector<QVector<double> >  y;
// 3 curves, 4 lines
y.append( QVector<double>{0,  0, 0, 0,  0,  0, 0,  0,  0} );
y.append( QVector<double>{2,  2, 3, 4,  2,  4, 4,  5, 11} );
y.append( QVector<double>{6,4.4, 9, 8,5.5,5.7, 9, 11, 12} );
y.append( QVector<double>{7,6.6,12,10,  9, 11,12, 12, 13} );

const QColor cols[] = { QColor(96,60,20),
						QColor(156,39,6),
						QColor(212,91,18),
						QColor(242,188,43)
					  };

for (int j=0;j<y.count()-1; ++j) {
	QwtPlotIntervalCurve *curve = new QwtPlotIntervalCurve();
	// generate intervals for current curve
	QVector<QwtIntervalSample> intervalSamples;
	for (int i=0; i<x.count(); ++i) 
		intervalSamples.append(QwtIntervalSample(x[i],y[j][i],y[j+1][i]));
	curve->setStyle(QwtPlotIntervalCurve::Tube);
	curve->setPen(QColor(96,60,20), 1);
	curve->setBrush(cols[j+1]);
	curve->setRenderHint( QwtPlotItem::RenderAntialiased, true ); // Antialiasing verwenden
	curve->setSamples(intervalSamples);
	curve->attach(&plot); // Plot takes ownership
}
```




.Diagramm mit gestapelten Kurven/Flächendiagramm
image::IntervalCurve_StackedCurve.png[pdfwidth=5cm]

