:imagesdir: ../images

[[sec:linecurves]]
# Kurvendiagramme

Die wohl häufiges Diagrammart werden wohl Kurvendiagramme sein. Kurvendiagramme bzw. Liniendiagramme sind parametrische Kurven, bei denen die einzelnen Punkte nacheinander gezeichnet werden, und im Fall von Liniendiagrammen durch Linien verbunden werden. Weder x- noch y-Werte müssen monoton steigen.

Das Zeichenelement `QwtPlotCurve` wird jedoch nicht nur für Liniendiagramme im klassischen Sinn benutzt, sondern auch für Stufen, Stäbchen, Punkt/Symbol-Diagramme und so weiter. Alle diese Varianten haben jedoch gemein, dass sie als Daten einen x- und einen y-Vector mit Daten in Plotkoordinaten erwarten.

Der individuelle Stil der Kurve wird mit der Funktion `QwtPlotCurve::setStyle()` festgelegt. Je nach Stil können/müssen weitere Parameter festgelegt werden. In den folgenden Abschnitten werden die möglichen Diagrammtypen für jeweils die gleichen x/y-Daten im Vergleich gezeigt. 

.Testdaten für die nachfolgenden Diagramme
[width="25%",options="header", colwidths="10%,10%"]
|====================
|  x |  y
|	1	|	5
|	2	|	4
|	5	|	8
|	6	|	8
|	10	|	4
|	12	|	5
|	15	|	8
|	16	|	9
|	17	|	11
|====================

## Liniendiagramm

Konfiguration einer `QwtPlotCurve` als Linie:

```c++
QwtPlotCurve *curve = new QwtPlotCurve();
curve->setStyle(QwtPlotCurve::Lines);
```

.Liniendiagramm
image::PlotCurves_StyleLines.png[pdfwidth=5cm]
 
## Stäbchen (Sticks)

Konfiguration einer `QwtPlotCurve` als vertikale Stäbchen:

```c++
QwtPlotCurve *curve = new QwtPlotCurve();
curve->setStyle(QwtPlotCurve::Lines);
curve->setOrientation(Qt::Vertical);
```

.Vertikale Stäbchen
image::PlotCurves_StyleSticksVertical.png[pdfwidth=5cm]

Alternativ kann man die Stäbchen auch horizontal zeichnen. Dazu muss man zusätzlich die Ausrichtung mit `QwtPlotSeriesItem::setOrientation()` setzen:

```c++
QwtPlotCurve *curve = new QwtPlotCurve();
curve->setStyle(QwtPlotCurve::Lines);
curve->setOrientation(Qt::Horizontal);
```

.Horizontale Stäbchen
image::PlotCurves_StyleSticksHorizontal.png[pdfwidth=5cm]


## Stufendiagramme

Wenn die Daten nicht linear verbunden werden sollen, sondern eher Stufen darstellen, kann man den Linientyp `Steps` verwenden.
Das Zusatz-Attribut `QwtPlotCurve::Inverted` gibt dabei an, ob die Stufe am Ende des Intervals oder Anfang des Intervals sein soll. Kurvenattribute werden mit `QwtPlotCurve::setCurveAttribute()` gesetzt:

```c++
QwtPlotCurve *curve = new QwtPlotCurve();
curve->setStyle(QwtPlotCurve::Steps);
curve->setCurveAttribute(QwtPlotCurve::Inverted, false);
```

.Stufendiagramm (normal)
image::PlotCurves_StyleSteps.png[pdfwidth=5cm]


Betrachtet man die Eingangsdaten:

```
x   y
1   5
2   4
5   8
...
``` 

so fällt auf, dass im ersten Intervall, also zwischen x=1..2, der Wert y2=4 gezeichnet wird und an der Stelle x1=1 die Verbindungslinie zwischen y1=5 und y2=4 gezeichnet wird.

Will man direkt den ersten y-Wert im ersten Intervall zeichnen (das wäre eher die natürliche Erwartungshaltung), so muss man das Attribut `Inverted` setzen:

```c++
QwtPlotCurve *curve = new QwtPlotCurve();
curve->setStyle(QwtPlotCurve::Steps);
curve->setCurveAttribute(QwtPlotCurve::Inverted, true);
```

.Stufendiagramm (invertiert)
image::PlotCurves_StyleStepsInverted.png[pdfwidth=5cm]


## Punkte (Dots)

Man kann an den jeweiligen x,y-Koordinaten auch einfach nur Punkte (auch nur einzelne Pixel) zeichnen. Das geht _sehr schnell_ vergleichen mit dem Zeichnen von Symbolen (siehe <<sec:plotSymbols>>) und kann für größere Punktwolken verwendet werden.

[TIP]
====
Bei der Verwendung von `QwtPlotCurve::Dots` sollte man bei heute üblichen Bildschirmauflösungen immer einen `QPen` mit größerer Breite einstellen, da mein _einzelne Pixel_ sonst nur noch schwer sehen kann. Für die Visualisierung großer Punktwolken (> 100000 Pixel) kann die Verwendung von einzelnen Pixeln durchaus noch einen Mehrwert bieten. Für alle besonderen Formen (Kreuze, Rauten, Ringe, Sterne, ...)  ist die Verwendung von Symbolen (siehe <<sec:plotSymbols>>) sinnvoll.
====


```c++
QwtPlotCurve *curve = new QwtPlotCurve();
curve->setStyle(QwtPlotCurve::Dots);
curve->setPen(QColor(180,40,20), 4); // width of 4 makes points better visible
```

.Punktediagramm
image::PlotCurves_StyleDots.png[pdfwidth=5cm]

[TIP]
====
Bei der Visualisierung von Punktwolken kann es hilfreich sein, Transparenz/Alphablending zu benutzen. Dazu einfach bei der Zeichenfarbe noch einen Alphawert kleiner als 255 setzen.
====

```c++
QwtPlotCurve *curve = new QwtPlotCurve();
curve->setStyle(QwtPlotCurve::Dots);
curve->setPen(QColor(0,40,180,32), 2); // 2 pixels wide, alpha value 32
```

.Punktwolke mit halbtransparenten Punkten
image::PlotCurves_StyleDotsScatter.png[pdfwidth=5cm]

[TIP]
====
Wenn man ein Liniendiagramm mit Visualisierung von Stützstellen erhalten will, so kann man natürlich _zwei_ Linien ins Diagramm einfügen: eine mit Stil `QwtPlotCurve::Lines` und die zweite mit Stil `QwtPlotCurve::Dots` darüber, d.h. mit höherem z-Wert, zeichnen. Dann muss man aber auch zwei mal die Daten ins Diagramm geben und man erhält auch zwei Legendeneinträge (die kann man zwar abschalten, siehe <<sec:legend>>, aber trotzdem). Besser ist hier die Verwendung von nur einer Kurve und Symbolen an den Stützstellen (siehe <<sec:plotSymbols>>).
====

## Keine Linie

Möchte man eine Kurve ausschließlich mit Symbolen zeichnen (siehe nachfolgendes Kapitel), so kann man das Zeichnen des Linienzugs auch komplett ausstellen:

```c++
curve->setStyle(QwtPlotCurve::NoCurve);
```


[[sec:plotSymbols]]
## Symbole/Punkte

An den jeweiligen x,y-Koordinaten einer Kurve kann man auch Symbole zeichnen. Dafür bietet die Qwt-Bibliothek die Klasse `QwtSymbol` an.


Ein Symbol fügt man zu eine Kurve wie folgt hinzu:

```c++
// Symbol hinzufügen
QwtSymbol * symbol = new QwtSymbol(QwtSymbol::Ellipse);
symbol->setSize(8);
symbol->setPen(QColor(0,0,160), 2);
symbol->setBrush(QColor(120,170,255));
curve->setSymbol(symbol); // Curve takes ownership of symbol
```

.Liniendiagramm mit ausgefüllten Kreissymbolen
image::Symbols_EllipseFilled.png[pdfwidth=5cm]

Zuerst wird das zu verwendende Symbol auf dem Heap mit new erzeugt. Der Konstruktor übernimmt den Typ des Symbols (siehe auch Galerie unten). Man kann das aber auch später über `QwtSymbol::setStyle()` setzen.

Wichtig ist auch die Größe des Symbols, gesetzt mittels `QwtSymbol::setSize()` in Pixeln. Diese Größe skaliert das Symbol je nach Form.

Außerdem wichtig sind die Eigenschaften Pen und Brush (`QwtSymbol::setPen()` und `QwtSymbol::setBruch()`). Der Pen wird für das Zeichnen des Umrisses verwendet und der Brush, so gesetzt, für das Ausfüllen der Form. Manche Symbole wie das Kreuz sind nicht ausgefüllt, daher hat hier der Brush keine Wirkung.

Schließlich wird das Symbol der Kurve mit `QwtPlotCurve::setSymbol()` gegeben.

[IMPORTANT]
====
Beim Aufruf von `QwtPlotCurve::setSymbol()` übernimmt die Plot-Kurve die Verantwortung für's Speicheraufräumen.
====


Die Symbolklasse ist ziemlich mächtig und kann verschiedenste Symbole zeichnen:

- vorgefertigte Formen wie Kreise, Rechtecke, Kreuze, etc. (Stil `QwtSymbol::Ellipse`...`QwtSymbol::Hexagon`
- nutzerdefinierte Bilder/Pixmaps (Stil `QwtSymbol::Pixmap`)
- spezifische Grafiken gekapselt in Klasse `QwtGraphic` und erzeugt durch eine Anzahl von `QwtPainterCommand` Anweisungen (Stil `QwtSymbol::Graphic`) (siehe auch <<sec:qwtGraphic>>)
- SVG-Dokumente (Stil `QwtSymbol::SvgDocument`)
- nutzerdefinierte Formen, welche durch einen QPainterPath definiert sind (Stil `QwtSymbol::Path`)


### Symbolstile/Eingebauten Symbolformen

Es gibt zahlreiche eingebaute Symbolformen (fett gedruckt im Diagrammtitel ist jeweils der `QwtSymbol::Style` Enumerationsname):

.Eingebaute Symboltypen/Stile und deren Enumerationstypen
image::Symbols_Gallery.png[pdfwidth=16cm]




### Nutzerdefinierte Formen via QPainterPath

Man kann beliebige eigene Symbolformen setzen, indem man die Klasse `QPainterPath` verwendet.
Folgendes Beispiel generiert ein Glühlampensymbol:

```c++
// Symbol hinzufügen
QwtSymbol * symbol = new QwtSymbol(QwtSymbol::Path);
QPainterPath p;
p.addEllipse(QRectF(-10,-10,20,20));
p.moveTo(-7,-7);
p.lineTo(7,7);
p.moveTo(7,-7);
p.lineTo(-7,7);
symbol->setPath(p);
symbol->setPen(QColor(0,0,120), 2);
symbol->setBrush(QColor(160,200,255));
curve->setSymbol(symbol); // Curve takes ownership of symbol
```

.Eigenes Symbol definiert mittels QPainterPath
image::Symbols_PainterPath.png[pdfwidth=5cm]

[CAUTION]
====
Wenn man eine nicht-rechteckige Geometrie mit QPainterPath definiert, sollte man beim Ändern der Größe mittels `QwtSymbol::setSize()` die Variante mit den zwei Argumenten aufrufen, also `QwtSymbol::setSize(width,height)`. Die Variante mit nur einem Argument transformiert den Pfad onst auf ein Quadrat. Da man üblicherweise keine nicht-quadratischen Formen als Symbol definiert, dürfte das aber nur selten ein Problem sein.
====


### SVG-Symbole

Man kann eigene SVG-Dateien rendern und anzeigen lassen. Dafür muss man nur eine SVG-Datei einlesen/definieren und als Symbol setzen:

```c++
QwtSymbol * symbol = new QwtSymbol(QwtSymbol::SvgDocument);
QFile f("symbol.svg");
f.open(QFile::ReadOnly);
QTextStream strm(&f);
QByteArray svgDoc = strm.readAll().toLatin1();
symbol->setSvgDocument(svgDoc);
curve->setSymbol(symbol); // Curve takes ownership of symbol
```

[CAUTION]
====
Auch hier ist beim Festlegen der Größe wieder auf das Seitenverhältnis zu achten und zumeist die Variante `QwtSymbol::setSize(width,height)` zu verwenden.
====

Manchmal liegt der Ankerpunkt des SVG-Bildes nicht im Zentrum, wie in obigem Beispiel:

.Zentriertes SVG-Symbol, welches eigentlich aber nach oben verschoben sein sollte
image::Symbols_SvgCentered.png[pdfwidth=5cm]

Man kann den Ankerpunkt bzw. den Zentrierpunkt des Symbols aber mit `QwtSymbol::setPinPoint()` ändern. Die Koordinaten des PinPoint werden dabei von links/oben des SVG-Bildes gemessen:

```c++
...
QRect br = symbol->boundingRect(); // size of symbol
symbol->setPinPoint(QPointF(br.width()/2-1,br.height()-3));
```

.SVG-Symbol mit korrekter Ausrichtung des "Stecknadel"-Punktes
image::Symbols_SvgWithPinPoint.png[pdfwidth=5cm]

[TIP]
====
Man kann die manuell gesetzten Ankerpunkt auch wieder mit `QwtSymbol::setPinPointEnabled(false)` deaktivieren.
====


### Bild-Symbole (Pixmaps)

Alternativ zu eigenen Vektorgrafiksymbolen kann man auch beliebige Bilder als Symbole verwenden. Dies geschieht analog zu den SVG-Symbolen:

```c++
QwtSymbol * symbol = new QwtSymbol(QwtSymbol::Pixmap);
QwtText t("QwtSymbol::Pixmap");
QPixmap pixmap;
pixmap.load("symbol.png");
symbol->setPixmap(pixmap);
QRect br = symbol->boundingRect(); // size of symbol
symbol->setPinPoint(QPointF(br.width()/2,br.height()-1));
curve->setSymbol(symbol); // Curve takes ownership of symbol
```

.Pixmap-Symbol, auch mit manuell festgelegtem "Stecknadel"-Punkt
image::Symbols_Pixmap.png[pdfwidth=5cm]


[[sec:intervalCurves]]
## Intervallkurven


Eine spezielle Kurvenart ist die _Intervallkurve_, bereitgestellt über die Klasse `QwtPlotIntervalCurve`.




