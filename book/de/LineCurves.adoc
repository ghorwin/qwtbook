:imagesdir: ../images

<<<
[[sec:linecurves]]
# Kurvendiagramme

Die wohl häufiges Diagrammart werden wohl Kurvendiagramme sein. Kurvendiagramme bzw. Liniendiagramme oder Reihendiagramme sind parametrische Kurven, bei denen die einzelnen Punkte nacheinander gezeichnet werden, und im Fall von Liniendiagrammen durch Linien verbunden werden. Weder x- noch y-Werte müssen monoton steigen.

Das Zeichenelement `QwtPlotCurve` wird jedoch nicht nur für Liniendiagramme im klassischen Sinn benutzt, sondern auch für Stufen, Stäbchen, Punkt/Symbol-Diagramme und so weiter. Alle diese Varianten haben jedoch gemein, dass sie als Daten einen x- und einen y-Vector mit Daten in Plotkoordinaten erwarten.

Der individuelle Stil der Kurve wird mit der Funktion `QwtPlotCurve::setStyle()` festgelegt. Je nach Stil können/müssen weitere Parameter festgelegt werden. In den folgenden Abschnitten werden die möglichen Diagrammtypen für jeweils die gleichen x/y-Daten im Vergleich gezeigt. 

## Datenübergabe
Wie in <<sec:seriesData>> erklärt, wird für die interne Datenhaltung in `QwtPlotCurve` die Klasse `QwtSeriesStore<QPointF>` verwendet.

Daten kann man nun auf mehrere Arten der Plot-Kurve übergeben:

.Verwendung zweier QVector<double> (oder analog QVector<float>)
```c++
QVector<double> x{1,2,5,6,10,12,15,16,17};
QVector<double> y{5,4,8,8, 4, 5, 8, 9,11};
curve->setSamples(x, y);
```

.Verwendung eines QVector<QPointF>
```c++
QVector<QPointF> samples{
	QPointF(1,5),
	QPointF(2,4),
	QPointF(5,8)
};
curve->setSamples(samples);
```

Wenn die Daten in einem C-Array oder `std::vector` vorliegen, bietet sich `QwtPlotCurve::setSamples()` an.

.Übergabe der Daten direkt im Speicher
```c++
std::vector<double> x{1,2,5,6,10,12,15,16,17};
std::vector<double> y{5,4,8,8, 4, 5, 8, 9,11};
const double * xdata = x.data();
const double * ydata = y.data();
unsigned int count = x.size();

curve->setSamples(xdata, ydata, count);
```

[IMPORTANT]
====
Bei der Verwendung von `QwtPlotCurve::setSamples()` werden die Daten _immer_ in den interne `QwtSeriesStore` der Plot-Kurve _kopiert_, auch wenn man hier direkt die Adresse des Speichers mit den Daten übergibt.
====


Bei sehr großen Datenmengen und begrenztem Hauptspeicher kann es sinnvoll sein, die Daten nicht in das Plot hineinzukopieren, sondern die Plotkurven direkt auf den Speicher zugreifen zu lassen. Dafür gibt es die Funktion `QwtPlotCurve::setRawSamples()`. Die Syntax ist wie beim vorherigen Beispiel:

.Direkte Verwendung der im Speicher befindlichen Daten durch as Plot
```c++
const double * xdata = x.data(); // x ist ein std::vector
const double * ydata = y.data(); // y ist ein std::vector
unsigned int count = x.size();
curve->setRawSamples(xdata, ydata, count);
```

[CAUTION]
====
Die Variablen und deren Speicherbereich, welche im Aufruf von `setRawSamples()` verwendet werden, müssen eine längere Lebensdauer haben, als das Plot bzw. die Plotkurve selbst.
====

Direkte Änderung der Daten im Speicher wird beim nächsten Rendern des Plots direkt sichtbar. Allerdings müssen das Plot und dessen  Zeichenelemente, die ein Interesse an den Wertebereichen der Plotkurven haben, manuell über eine Änderung der Daten information werden. Dazu einfach `QwtPlot::replot()`.



## Kurvenarten

### Liniendiagramm

Konfiguration einer `QwtPlotCurve` als Linie:

```c++
QwtPlotCurve *curve = new QwtPlotCurve();
curve->setStyle(QwtPlotCurve::Lines);
```

.Liniendiagramm
image::PlotCurves_StyleLines.png[pdfwidth=8cm]
 
### Stäbchen (Sticks)

Konfiguration einer `QwtPlotCurve` als vertikale Stäbchen:

```c++
QwtPlotCurve *curve = new QwtPlotCurve();
curve->setStyle(QwtPlotCurve::Lines);
curve->setOrientation(Qt::Vertical);
```

.Vertikale Stäbchen
image::PlotCurves_StyleSticksVertical.png[pdfwidth=8cm]

Alternativ kann man die Stäbchen auch horizontal zeichnen. Dazu muss man zusätzlich die Ausrichtung mit `QwtPlotSeriesItem::setOrientation()` setzen:

```c++
QwtPlotCurve *curve = new QwtPlotCurve();
curve->setStyle(QwtPlotCurve::Lines);
curve->setOrientation(Qt::Horizontal);
```

.Horizontale Stäbchen
image::PlotCurves_StyleSticksHorizontal.png[pdfwidth=8cm]


### Stufendiagramme

Wenn die Daten nicht linear verbunden werden sollen, sondern eher Stufen darstellen, kann man den Linientyp `Steps` verwenden.
Das Zusatz-Attribut `QwtPlotCurve::Inverted` gibt dabei an, ob die Stufe am Ende des Intervals oder Anfang des Intervals sein soll. Kurvenattribute werden mit `QwtPlotCurve::setCurveAttribute()` gesetzt:

```c++
QwtPlotCurve *curve = new QwtPlotCurve();
curve->setStyle(QwtPlotCurve::Steps);
curve->setCurveAttribute(QwtPlotCurve::Inverted, false);
```

.Stufendiagramm (normal)
image::PlotCurves_StyleSteps.png[pdfwidth=8cm]


Betrachtet man die Eingangsdaten:

```
x   y
1   5
2   4
5   8
...
``` 

so fällt auf, dass im ersten Intervall, also zwischen x=1..2, der Wert y2=4 gezeichnet wird und an der Stelle x1=1 die Verbindungslinie zwischen y1=5 und y2=4 gezeichnet wird.

Will man direkt den ersten y-Wert im ersten Intervall zeichnen (das wäre eher die natürliche Erwartungshaltung), so muss man das Attribut `Inverted` setzen:

```c++
QwtPlotCurve *curve = new QwtPlotCurve();
curve->setStyle(QwtPlotCurve::Steps);
curve->setCurveAttribute(QwtPlotCurve::Inverted, true);
```

.Stufendiagramm (invertiert)
image::PlotCurves_StyleStepsInverted.png[pdfwidth=8cm]


### Punkte (Dots)

Man kann an den jeweiligen x,y-Koordinaten auch einfach nur Punkte (auch nur einzelne Pixel) zeichnen. Das geht _sehr schnell_ vergleichen mit dem Zeichnen von Symbolen (siehe <<sec:plotSymbols>>) und kann für größere Punktwolken verwendet werden.

[TIP]
====
Bei der Verwendung von `QwtPlotCurve::Dots` sollte man bei heute üblichen Bildschirmauflösungen immer einen `QPen` mit größerer Breite einstellen, da mein _einzelne Pixel_ sonst nur noch schwer sehen kann. Für die Visualisierung großer Punktwolken (> 100000 Pixel) kann die Verwendung von einzelnen Pixeln durchaus noch einen Mehrwert bieten. Für alle besonderen Formen (Kreuze, Rauten, Ringe, Sterne, ...)  ist die Verwendung von Symbolen (siehe <<sec:plotSymbols>>) sinnvoll.
====


```c++
QwtPlotCurve *curve = new QwtPlotCurve();
curve->setStyle(QwtPlotCurve::Dots);
curve->setPen(QColor(180,40,20), 4); // width of 4 makes points better visible
```

.Punktediagramm
image::PlotCurves_StyleDots.png[pdfwidth=8cm]

[TIP]
====
Bei der Visualisierung von Punktwolken kann es hilfreich sein, Transparenz/Alphablending zu benutzen. Dazu einfach bei der Zeichenfarbe noch einen Alphawert kleiner als 255 setzen.
====

```c++
QwtPlotCurve *curve = new QwtPlotCurve();
curve->setStyle(QwtPlotCurve::Dots);
curve->setPen(QColor(0,40,180,32), 2); // 2 pixels wide, alpha value 32
```

.Punktwolke mit halbtransparenten Punkten
image::PlotCurves_StyleDotsScatter.png[pdfwidth=8cm]

[TIP]
====
Wenn man ein Liniendiagramm mit Visualisierung von Stützstellen erhalten will, so kann man natürlich _zwei_ Linien ins Diagramm einfügen: eine mit Stil `QwtPlotCurve::Lines` und die Zweite mit Stil `QwtPlotCurve::Dots` darüber zeichnen, d.h. mit höherem z-Wert. Dann muss man aber auch zwei Mal die Daten ins Diagramm geben und man erhält auch zwei Legendeneinträge (die kann man zwar auch individuell für einzelne Kurven abschalten, siehe <<sec:legend>>), aber zunächst gibt es für jede Kurve je einen Legendeneintrag). Besser ist hier die Verwendung von nur einer Kurve und Symbolen an den Stützstellen (siehe <<sec:plotSymbols>>).
====

### Keine Linie

Möchte man eine Kurve ausschließlich mit Symbolen zeichnen (siehe <<sec:plotSymbols>>), so kann man das Zeichnen des Linienzugs auch komplett ausstellen:

```c++
curve->setStyle(QwtPlotCurve::NoCurve);
```


[[sec:plotSymbols]]
## Symbole/Punkte

An den jeweiligen x,y-Koordinaten einer Kurve kann man auch Symbole zeichnen. Dafür bietet die Qwt-Bibliothek die Klasse `QwtSymbol` an.


Ein Symbol fügt man zu eine Kurve wie folgt hinzu:

```c++
// Symbol hinzufügen
QwtSymbol * symbol = new QwtSymbol(QwtSymbol::Ellipse);
symbol->setSize(8);
symbol->setPen(QColor(0,0,160), 2);
symbol->setBrush(QColor(120,170,255));
curve->setSymbol(symbol); // Curve takes ownership of symbol
```

.Liniendiagramm mit ausgefüllten Kreissymbolen
image::Symbols_EllipseFilled.png[pdfwidth=8cm]

Zuerst wird das zu verwendende Symbol auf dem Heap mit new erzeugt. Der Konstruktor übernimmt den Typ des Symbols (siehe auch Galerie unten). Man kann das aber auch später über `QwtSymbol::setStyle()` setzen.

Wichtig ist auch die Größe des Symbols, gesetzt mittels `QwtSymbol::setSize()` in Pixeln. Diese Größe skaliert das Symbol je nach Form.

Außerdem wichtig sind die Eigenschaften Pen und Brush (`QwtSymbol::setPen()` und `QwtSymbol::setBruch()`). Der Pen wird für das Zeichnen des Umrisses verwendet und der Brush, so gesetzt, für das Ausfüllen der Form. Manche Symbole wie das Kreuz sind nicht ausgefüllt, daher hat hier der Brush keine Wirkung.

Schließlich wird das Symbol der Kurve mit `QwtPlotCurve::setSymbol()` gegeben.

[IMPORTANT]
====
Beim Aufruf von `QwtPlotCurve::setSymbol()` übernimmt die Plot-Kurve die Verantwortung für's Speicheraufräumen.
====

Die Symbolklasse ist ziemlich mächtig und kann verschiedenste Symbole zeichnen:

- vorgefertigte Formen wie Kreise, Rechtecke, Kreuze, etc. (Stil `QwtSymbol::Ellipse`...`QwtSymbol::Hexagon`
- nutzerdefinierte Bilder/Pixmaps (Stil `QwtSymbol::Pixmap`)
- spezifische Grafiken gekapselt in Klasse `QwtGraphic` und erzeugt durch eine Anzahl von `QwtPainterCommand` Anweisungen (Stil `QwtSymbol::Graphic`) (siehe auch <<sec:qwtGraphic>>)
- SVG-Dokumente (Stil `QwtSymbol::SvgDocument`)
- nutzerdefinierte Formen, welche durch einen QPainterPath definiert sind (Stil `QwtSymbol::Path`)


### Symbolstile/Eingebauten Symbolformen

Es gibt zahlreiche eingebaute Symbolformen (fett gedruckt im Diagrammtitel ist jeweils der `QwtSymbol::Style` Enumerationsname):

.Eingebaute Symboltypen/Stile und deren Enumerationstypen
image::Symbols_Gallery.png[pdfwidth=16cm]


Symbole müssen nicht immer quadratisch sein. Wenn man die Größe eines Symbols mit

```c++
symbol->setSize(10);
```

setzt, wird automatisch `width=height=10` verwendet. Alternativ kann man aber auch ein Rechteck als Größe definieren:

```c++
symbol->setSize(w,h);
// oder via QSize
QSize s(w,h);
symbol->setSize(s);
```

Deshalb gibt es auch keine separaten Linienstile für Kreis und Ellipse oder Rechteck und Quadrat.

### Nutzerdefinierte Formen via QPainterPath

Man kann beliebige eigene Symbolformen setzen, indem man die Klasse `QPainterPath` verwendet.
Folgendes Beispiel generiert ein Glühlampensymbol:

```c++
// Symbol hinzufügen
QwtSymbol * symbol = new QwtSymbol(QwtSymbol::Path);
QPainterPath p;
p.addEllipse(QRectF(-10,-10,20,20));
p.moveTo(-7,-7);
p.lineTo(7,7);
p.moveTo(7,-7);
p.lineTo(-7,7);
symbol->setPath(p);
symbol->setPen(QColor(0,0,120), 2);
symbol->setBrush(QColor(160,200,255));
curve->setSymbol(symbol); // Curve takes ownership of symbol
```

.Eigenes Symbol definiert mittels QPainterPath
image::Symbols_PainterPath.png[pdfwidth=8cm]

[CAUTION]
====
Wenn man eine nicht-rechteckige Geometrie mit QPainterPath definiert, sollte man beim Ändern der Größe mittels `QwtSymbol::setSize()` die Variante mit den zwei Argumenten aufrufen, also `QwtSymbol::setSize(width,height)`. Die Variante mit nur einem Argument transformiert den Pfad onst auf ein Quadrat. Da man üblicherweise keine nicht-quadratischen Formen als Symbol definiert, dürfte das aber nur selten ein Problem sein.
====


### SVG-Symbole

Man kann eigene SVG-Dateien rendern und anzeigen lassen. Dafür muss man nur eine SVG-Datei einlesen/definieren und als Symbol setzen:

```c++
QwtSymbol * symbol = new QwtSymbol(QwtSymbol::SvgDocument);
QFile f("symbol.svg");
f.open(QFile::ReadOnly);
QTextStream strm(&f);
QByteArray svgDoc = strm.readAll().toLatin1();
symbol->setSvgDocument(svgDoc);
curve->setSymbol(symbol); // Curve takes ownership of symbol
```

[CAUTION]
====
Auch hier ist beim Festlegen der Größe wieder auf das Seitenverhältnis zu achten und zumeist die Variante `QwtSymbol::setSize(width,height)` zu verwenden.
====

Manchmal liegt der Ankerpunkt des SVG-Bildes nicht im Zentrum, wie in obigem Beispiel:

.Zentriertes SVG-Symbol, welches eigentlich aber nach oben verschoben sein sollte
image::Symbols_SvgCentered.png[pdfwidth=8cm]

Man kann den Ankerpunkt bzw. den Zentrierpunkt des Symbols aber mit `QwtSymbol::setPinPoint()` ändern. Die Koordinaten des PinPoint werden dabei von links/oben des SVG-Bildes gemessen:

```c++
...
QRect br = symbol->boundingRect(); // size of symbol
symbol->setPinPoint(QPointF(br.width()/2-1,br.height()-3));
```

.SVG-Symbol mit korrekter Ausrichtung des "Stecknadel"-Punktes
image::Symbols_SvgWithPinPoint.png[pdfwidth=8cm]

[TIP]
====
Man kann die manuell gesetzten Ankerpunkt auch wieder mit `QwtSymbol::setPinPointEnabled(false)` deaktivieren.
====


### Bild-Symbole (Pixmaps)

Alternativ zu eigenen Vektorgrafiksymbolen kann man auch beliebige Bilder als Symbole verwenden. Dies geschieht analog zu den SVG-Symbolen:

[source,c++]
----
QwtSymbol * symbol = new QwtSymbol(QwtSymbol::Pixmap);
QwtText t("QwtSymbol::Pixmap");
QPixmap pixmap;
pixmap.load("symbol.png");
symbol->setPixmap(pixmap);
QRect br = symbol->boundingRect(); // size of symbol
symbol->setPinPoint(QPointF(br.width()/2,br.height()-1));
curve->setSymbol(symbol); // Curve takes ownership of symbol
----

.Pixmap-Symbol, auch mit manuell festgelegtem "Stecknadel"-Punkt
image::Symbols_Pixmap.png[pdfwidth=8cm]


## Ausgefüllte Kurven

Eine Kurve kann neben dem Zeichenstift auch noch einen Brush übernehmen. Dann wird die Kurve bis zur x-Achse gefüllt:

[source,c++]
----
curve->setBrush(QColor(0xa0d0ff));
----

.Gefüllte Linienkurve
image::PlotCurves_StyleLinesFilled.png[pdfwidth=8cm]

Man kann die Bezugslinie für die Füllung auch noch verschieben:

[source,c++]
----
curve->setBaseLine(8);
----

.Gefüllte Linienkurve mit verschobener Bezugslinie
image::PlotCurves_StyleLinesFilledWithBaseline.png[pdfwidth=8cm]


## Legendeneinträge 

Jede `QwtPlotCurve` erstellt ihr eigenes Icon zur Anzeige in der Legende. Der in der Legende angezeigte Text wird mit `QwtPlotItem::setTitle()` gesetzt. Um die Legende anzuzeigen, muss man wie in <<sec:legend>> beschrieben zunächst eine Legende erstellen und ins Plot einfügen.

.Standardlegende für Datenreihen
image::PlotCurveLegendStandard.png[pdfwidth=8cm]


Zusätzlich kann noch mit `QwtPlotCurve::setLegendAttribute()` festgelegt werden, ob ein ausgefülltes Rechteck, eine Line oder das Reihensymbol in der Legende gezeichnet wird. 

Diese Eigenschaften werden für jede `QwtPlotCurve` individuell gesetzt:

```c++
curve->setTitle("Linie 1");
curve->setLegendAttribute(QwtPlotCurve::LegendShowLine, true);
```

.Legende mit Linien als Icons
image::PlotCurveLegendLinie.png[pdfwidth=8cm]

Bei Linien mit Markierungen kann man auch die Markierungen zeichnen:

```c++
curve->setTitle("Linie 1");
curve->setLegendAttribute(QwtPlotCurve::LegendShowLine, true);
curve->setLegendAttribute(QwtPlotCurve::LegendShowSymbol, true);

QwtSymbol * symbol = new QwtSymbol(QwtSymbol::Rect);
symbol->setSize(6);
symbol->setPen(QColor(0,0,160), 1);
symbol->setBrush(QColor(160,200,255));
curve->setSymbol(symbol); // Curve takes ownership of symbol
```

.Legende mit Linien und Symbolen als Legendenicons
image::PlotCurveLegendLinieWithSymbol.png[pdfwidth=8cm]

[IMPORTANT]
====
Wenn man unterschiedliche Liniensymbole verwendet, dann wirkt sich das auf die automatisch bestimmte Legendenicongröße aus. Somit sind dann die Legendentitel manchmal wie im Screenshot oben nicht perfekt ausgerichtet.

Man kann aber die Größe der Legendenicons mit `QwtPlotItem::setLegendIconSize()` einheitlich ändern.
====

[source,c++]
----
curve->setTitle("Linie 1");
curve->setLegendAttribute(QwtPlotCurve::LegendShowLine, true);
curve->setLegendAttribute(QwtPlotCurve::LegendShowSymbol, true);

QwtSymbol * symbol = new QwtSymbol(QwtSymbol::Rect);
symbol->setSize(6);
symbol->setPen(QColor(0,0,160), 1);
symbol->setBrush(QColor(160,200,255));
curve->setSymbol(symbol); // Curve takes ownership of symbol

// einheitliche Legendenicon-Breite unabhängig vom gewählten Symbol
curve->setLegendIconSize(QSize(30,16));
----

.Legende mit gleichgroßen Legendenicons
image::PlotCurveLegendLinieWithSymbolSameWidth.png[pdfwidth=8cm]

[CAUTION]
====
Da die Legendenicons beim Setzen von Kurvensymbolen konfiguriert werden, muss die Änderung der Legendenicongrößen stets _nach_ dem Setzen/Anpassen von Kurvensymbolen gemacht werden. Also der Aufruf von `setLegendIconSize()` muss _nach_ `setSymbol()` erfolgen!
====

[TIP]
====
Alle Informationen zu Legenden und auch spezifische Anpassungen, z.B. wie man eigene Icons zeichnet, gibt es in <<sec:legend>>.
====

[[sec:curvePerformance]]
## Zeichenattribute, Zeichengeschwindigkeit und Performanceoptimierung bei großen Datenreihen

Das Zeichnen großer Datenreihen kann mitunter einige Zeit beanspruchen. Vor allem beim Größenändern des Plotfensters wirkt sich das dann durch merkliche Verzögerung beim Bildschirmaufbau aus. Je größer die Datenreihen sind, d.h. umsomehr Punkte enthalten sind, umso länger dauert im Allgemeinen das Zeichnen des Plots. In diesem Abschnitt soll es um verschiedene Eigenschaften und Fähigkeiten der `QwtPlotCurve` gehen, die sich direkt auf die Zeichengeschwindigkeit auswirken.

### Zeichenattribute (PaintAttribute / PaintAttributes)

Die Klasse `QwtPlotCurve` hat verschiedene Zeichenattribute, die verwendete Algorithmen näher konfigurieren. Hier ist zunächst eine kurze Liste, wobei die individuellen Attribute und deren Auswirkung später näher beschrieben werden:

- `ClipPolygons` - damit werden zu zeichnende Datenreihen ausgedünnt, sodass nur im aktuellen Zoomfenster sichtbare Kurventeile gezeichnet werden. Ist standardmäßig aktiv und ist für den SVG-Export notwendig. Sonst ist dieses Herausfiltern außerhalb liegender Punkte vor allem beim Hineinzoomen wirkungsvoll.
- `FilterPoints` - damit werden Punkte/Liniensegmente aus den Datenreihen herausgefiltert, die sowieso nicht gezeichnet werden würden, weil sie übereinander liegen.
- `FilterPointsAggressive` - _Nur_ für Linientyp `QwtPlotCurve::Linien`: Ersetzt viele kurze übereinanderliegende Polygonstücke durch einzelne Liniensegmente
- `MinimizeMemory` - _Nur_ beim Linientyp `QwtPlotCurve::Dots`: Verhindert wenn eingeschaltet, dass bei der Transformation der Datenreihe von Plotkoordinaten zu Renderkoordinaten eine eventuell große Polygon-Kopie erstellt wird. Stattdessen werden alle Punktkoordinaten einzeln transformiert, geclippt und gezeichnet. Da hierbei für jeden Punkt ein gewisser Extraaufwand benötigt wird, ist dies in der Regel etwas langsamer.
- `ImageBuffer` - _Nur_ beim Linientyp `QwtPlotCurve::Dots`: Eine sehr spezielle Optimierung, wobei die Punkte (jeweils nur ein Pixel pro Punkt) erst in ein `QImage` gezeichnet werden. Dies erfolgt parallelisiert und kann daher sehr schnell sein, ist allerdings nur effektiv bei sehr großen Punktmengen.

[IMPORTANT]
====
Das Zeichenattribut `FilterPointsAggressive` wirkt sich nur auf Linientyp `QwtPlotCurve::Lines` aus. Die Attribute `MinimizeMemory` und `ImageBuffer` sind sehr spezielle Optimierungen für den Linientyp `QwtPlotCurve::Dots`.
====

### Punktfilter

Durch Verwendung des Datenfiltes `FilterPoints` kann man bei sehr großen Reihendaten nur die Daten wirklich zeichnen, die sich auf das Diagramm auswirken. Wenn bspw. 100 Datenpunkte auf dem gleichen Pixel landen, braucht man die nicht alle zeichnen. Das Ausfiltern nicht sichtbarer Punkte und Liniensegmente hängt natürlich von der Zoomstufe ab und ist deshalb in die Zeichenroutine der `QwtPlotCurve` integriert.

[NOTE]
====
Neben dem Filtern überflüssiger Punkte durch Setzen des Zeichenattributs `FilterPoints` gibt es auch noch die Möglichkeit, den `QwtWeedingCurveFitter` (siehe <<sec:weedingCurveFitter>>) zu verwenden. Dieser ist aber eigentlich für die Datenreduktion beim Export gedacht und wegen des zusätzlichen Berechnungsaufwands dauert das Zeichnen auf dem Bildschirm in der Regel länger.
====

Das Zeichenattribut `QwtPlotCurve::FilterPoints` ist standardmäßig gesetzt und führt dazu, dass beim Transformieren der Datenreihenkoordinaten in Bildschirmkoordinaten bereits doppelte Punkte herausgefiltert werden (dies macht die Klasse `QwtPointMapper`). Enthält eine Datenreihe bspw. 100000 gleichverteilte Punkte entlang der x-Achse und wird auf einem 1000 Pixel breiten Plot gezeichnet, so teilen sich jeweils 100 Punkte eine x-Pixelkoordinate. Wenn nach der Umrechnung der Koordinaten zwei aufeinanderfolgende Punkte identische Pixelkoordinaten haben, werden die doppelten Punkte entfernt. Diese standardmäßig eingeschaltete Funktion macht bereits einen großen Unterschied bei der Zeichengeschwindigkeit. 

Um das mal zu verdeutlichen, ist hier ein kleines Testprogramm für die Filterfunktionen:

.Testprogramm für den Filteralgorithmus mit 10 Millionen Punkten in der Datenreihe
[source,c++]
----
#include <QApplication>
#include <QElapsedTimer>
#include <QDebug>

#include <cmath>

#include <qwt_plot.h>
#include <qwt_plot_curve.h>
#include <qwt_weeding_curve_fitter.h>

// Spezialisierte QwtPlotCurve mit Zeitmessung um drawCurve()
class BenchmarkedPlotCurve : public QwtPlotCurve {
protected:
	void drawCurve(QPainter *p, int style, 
		const QwtScaleMap & xMap, const QwtScaleMap & yMap, 
		const QRectF & canvasRect, int from, int to) const override 
	{
		QElapsedTimer timer;
		timer.start();
		QwtPlotCurve::drawCurve(p, style, xMap, yMap, canvasRect, from, to);
		qDebug() << "QwtPlotCurve::drawCurve(): " << timer.elapsed() << "ms";
	}
};


int main(int argc, char *argv[]) {
	QApplication a(argc, argv);
	QwtPlot plot;
	plot.setContentsMargins(8,8,8,8);
	plot.setCanvasBackground( Qt::white );

	// Daten zum Darstellen generieren
	QVector<double> x, y;
	for (unsigned int i=0; i<10000000; ++i) {
		x.append(i);
		y.append(std::sin(i*0.00001));
	}

	QwtPlotCurve *curve = new BenchmarkedPlotCurve();
	curve->setPen(QColor(180,40,20), 1);
	curve->setRenderHint( QwtPlotItem::RenderAntialiased, true); // Antialiasing verwenden
	curve->setPaintAttribute(QwtPlotCurve::FilterPoints, false); // Punktefilter ausschalten
	curve->setSamples(x, y);
	curve->attach(&plot); // Plot takes ownership

	plot.resize(1000,800);
	plot.show();

	return a.exec();
}
----

Das Testprogramm generiert 10 Millionen Datenpunkte (mehrere Sinuswellen) und zeichet diese dann in ein 1000x800 Pixel großes Diagramm, zunächst _ohne_ Punktefilter. Dazu wird in Zeile

```c++
curve->setPaintAttribute(QwtPlotCurve::FilterPoints, false);
```

das Zeichenattribut `FilterPoints` ausgeschaltet. Die Zeichenzeit für die Kurve einschließlich der Zeit für die Datenfilterung wird in der abgeleiteten `QwtPlotCurve` und dem kleinen Wrapper um die zentrale `drawCurve()`-Funktion gemessen.

Auf meinem Rechner gibt das Programm im Release-Build ca. **650 ms** aus. Dabei werden wirklich alle 10 Millionen Punkte in den zu zeichnenden Polygonzug übernommen und auf dem Painter gezeichnet (der natürlich Liniensegmente mit Länge 0 verwirft, aber dafür etwas Zeit braucht). 

Schaltet man nun das Attribut `FilterPoints` wieder ein, so enthält das Polygon _nach_ dem Filtern nur noch ca. 24500 Punkte und das Zeichnen dauert ca. **300 ms**.


[TIP]
====
Mit dem Zeichenattribut `FilterPoints` werden Liniensegmente mit Länge 0 herausgefiltert, was bei sehr großen Datenreihen eine merkliche Zeichenbeschleunigung bewirkt.
====


### Aggressives Punktefiltern

Wenn Datenreihen sehr stark rauschen und gleichzeitig sehr große Datenmengen enthalten, dann können sich mehrere Liniensegmente überlagern. Zum Beispiel werden dann mehrere Linien mit der gleichen x-Bildschirmkoordinate übereinander gezeichnet, obwohl ja eine Linie gezeichnet zwischen minimaler und maximaler y-Koordinate ausreichen würde.

Das Zeichenattribut `FilterPointsAggressive` schaltet eine Vorberechnung ein, die genau diese Art der Optimierung durchführt (ebenfalls in Klasse `QwtPointMapper` implementiert) und aus mehreren sich überlagernden, vertikalen Liniensegmenten nur eine einzige Linie macht (deswegen ist diese Optimierung auch nur für den Linientyp `QwtPlotCurve::Lines` sinnvoll).

Um das mal zu testen, wandeln wir das Programm oben ab und generieren eine stark rauschende Kurve:


[source,c++]
----
QVector<double> x, y;
for (unsigned int i=0; i<1000000; ++i) {
	x.append(i);
	y.append(QRandomGenerator64::global()->generateDouble());
}
----

Ohne `FilterPointsAggressive` dauert das Zeichnen ca. **1500 ms**. Obwohl die Datenreihe "nur" aus 1 Mio Punkten besteht, sind die Liniensegmente deutlich länger als bei der Sinuswelle und es dauert länger, diese zu zeichnen. Das Zeichenattribut `FilterPoints` kann auch wegen der stark schwankenden y-Werte kaum Punkte rausschmeißen (die Liniensegmente haben fast nie eine Länge von 0).

Wenn man nun das Attribut mit

```c++
curve->setPaintAttribute(QwtPlotCurve::FilterPointsAggressive, true);
```

einschaltet, verkürzt sich die Zeichenzeit auf ca. **32 ms** !!!! Nach dem Filtern hat das zu zeichnende Polygon nur noch ca. 3670 Punkte.

[TIP]
====
Die Verwendung des Zeichenattributs `FilterPointsAggressive` beschleunigt die Darstellung drastisch, vor allem beim Kurven mit vielen Datenpunkten und stark rauschenden Werten.
====

Wenn man sich die Diagramme mit und ohne `FilterPointsAggressive` im Vergleich anschaut, so sieht man kleinere Unterschiede.

.Ausgabe mit `FilterPoints`, Antialiasing eingeschaltet
image::CurveFilterPoints_Antialias.png[pdfwidth=8cm]

.Ausgabe `FilterPointsAggressive`, Antialiasing eingeschaltet
image::CurveFilterPointsAggressive_Antialias.png[pdfwidth=8cm]

Mit Antialiasing sieht man Unterschiede in den teiltransparenten Segmenten.
Ohne Antialiasing muss man schon sehr genau hinsehen, um die kleinen Unterschiede zu sehen.

.Ausgabe mit `FilterPoints`, Antialiasing ausgeschaltet
image::CurveFilterPoints.png[pdfwidth=8cm]

.Ausgabe `FilterPointsAggressive`, Antialiasing ausgeschaltet
image::CurveFilterPointsAggressive.png[pdfwidth=8cm]

(Zum Vergleich beide Bilder herunterladen und im Bildbetrachter abwechselnd anzeigen, dann sieht man die kleinen Unterschiede.)


[NOTE]
====
Im Gegensatz zu `FilterPoints` ist das Ergebnis des `FilterPointsAggressive` aber eine leicht veränderte Darstellung. Das liegt an der Art, wie Liniensegmente zusammengefasst werden.

Nach der Skalierung von Plotkoordinaten zu Bildschirmkoordinaten liegt beispielsweise folgendes Polygon zum Filtern vor:

    x      y
    ----------
    6      230
    6      379
    6      602
    7      304
    7      602
    7       81
    7      155
    8      424 
    ...

so enthält das Polygon _nach_ dem Filtern nur noch die Punkte:

    x      y
    ----------
    6      230
    6      602
    7      304
    7      602
    7      81
    8      424
    ...

Die Liniensegmente auf den x-Zeichenkoordinaten 6 und 7 wurden hier zusammengefasst. 

Aber während vorher eine Linie von (7,155) -> (8,424) gezeichnet wurde, wird nun eine Linie von (7,81) -> (8,424) gezeichnet, welches im Detail ein minimal anderes Erscheinungsbild gibt. Die Unterschiede in der Ausgabe sind aber so klein, dass man für die relevanten Anwendungsfälle, also größere Datenreihen und stark schwankende Werte, das Einschalten des Zeichenattributs `FilterPointsAggressive` durchaus generell empfehlen kann.
====


### Polygon-Clipping

Je nach Wahl des Plotausschnitts, festzulegen über Achsenskalierung (siehe <<sec:axes>>) oder interaktiv durch den Plotzoomer (siehe <<sec:zoomer>>), werden mitunter nur Teile von Kurven gezeichnet. In diesem Fall ist es sinnvoll, das Polygon nur auf die sichtbaren Bereiche zu begrenzen. Diese Funktionalität bietet die Klasse `QwtPlotCurve` durch Einschalten des Zeichenattributs `QwtPlotCurve::ClipPolygons`.

[NOTE]
====
Beim Zeichnen des Plots auf dem Bildschirm könnte man das Polygon-Clipping auch weglassen, da der Qt-Painter selbst ein Clipping durchführt. Beim Datenexport in eine SVG-Datei (siehe <<sec:print>>) ist das Clipping aber zwingend notwendig. 
====

Standardmäßig ist das Attribut `QwtPlotCurve::ClipPolygons` eingeschaltet. Das Clipping wird übrigends erst _nach_ dem Punktfilteralgorithmus angewendet, sodass eine Datenreduktion in diesem Schritt sich positiv auf die Zeit für das Clipping auswirkt.

Interessanterweise wirkt sich das Polygon-Clipping beim Rendern auf den Bildschirm nur unmerklich auf die Renderperformance aus.

Beim 10 Mio Sinuskurvenplot oben (Antialiasing an, FilterPoints an, FilterPointsAggressive aus, ClipPolygons an) ist die Zeichenzeit für das komplette Diagramm ca. **300 ms**. Hineingezoomt mit

```c++
plot.setAxisScale(QwtPlot::xBottom, 150000, 160000);
plot.setAxisScale(QwtPlot::yLeft, 0.99, 1);
```

erhöht sich die Renderzeit auf ca. **370 ms**. Wenn man nun `ClipPolygons` ausschaltet, so dauert das **290 ms** beim vollständigen Plot und **410 ms** beim hineingezoomten Plot. 

[NOTE]
====
Im hineingezoomten Zustand dauert der Clipping-Algorithmus länger, dafür ist das Zeichnen etwas schneller. Beide Effekte arbeiten gegeneinander aber im Ergebnis ist es bei meinem Testfall minimal langsamer als im herausgezoomten Zustand).
====

Der Unterschied zwischen **300 ms** und **290 ms** beim vollständigen Plot liegt an dem Oberhead für die Polygon-Clipping-Funktion, die natürlich beim vollständig sichtparen Plot keine Wirkung hat. 

Im stark hineingezoomten Zustand zeichnet das Plot mit eingeschaltetem Polygon-Clipping immerhin ca. **40 ms** schneller, was aber selten signifikant sein sollte.

[NOTE]
====
Dein Einfluss des Attributs `ClipPolygons` auf die Zeichenperformance ist marginal, sodass man dieses Attribut getrost immer eingeschaltet lassen kann.

Lediglich beim Ausschalten des `FilterPoints`-Attributs und sehr großen Datenmengen könnte das `ClipPolygons` im hineingezoomten Zustand etwas bewirken. 
Zum Beispiel rendert das Plot _ohne_ `FilterPoints` und _ohne_ `ClipPolygons` im hineingezoomten Zustand (siehe oben) in **550 ms**, gegenüber **360 ms** _mit_ `ClipPolygons`. Aber selbst in diesem eher unrealistischen Szenario ist die Auswirkung des Attributs klein. 

Fazit: `ClipPolygons` eingeschaltet lassen!
====



[[sec:curveFitter]]
## Kurvenfilter

Die `QwtPlotCurve` kann die übergebenen Rohdaten vor dem eigentlichen Rendern noch an einen Algorithmus übergeben, der die Daten glättet oder eine kontinuierliche Kuve durch die Datenpunkte legt. Diese Operationen hängen vom aktuellen Zoomlevel und der Plotgröße ab, denn je nach Auflösung wird der Verlauf der angepassten Kurve neu berechnet. Dies gibt eine bessere Qualität als beim Vorberechnen der Daten und Plotten eines Linienzugs durch vorberechnete Kurven. Deshalb ist diese Funktionalität direkt in das `QwtPlot` integriert.

Einen solchen Filteralgorithmus übergibt man der Kurve, indem man eine Klasse, abgeleitet von  `QwtCurveFitter` der Kurve übergibt.

Es werden verschiedene Implementierungen dieser Schnittstelle mitgeliefert:

.Kind-Klassen der Basisklasse `QwtCurveFitter`
image::ClassDiagrams/QwtCurveFitter-class-hierarchy.png[pdfwidth=10cm]

### Kurvenglättung/Spline-Interpolation

Schauen wir uns zuerst den `QwtSplineCurveFitter` an.  Diese Klasse kapselt einen Algorithmus, der aus den gegebenen Stützstellen der Kurve einen weichen Verlauf berechnet. Dafür gibt es verschiedene mathematischen Algorithmen.

Jeder dieser Algorithmen ist in einer von `QwtSpline` abgeleiteten Klasse implementiert.


.Kind-Klassen der Basisklasse `QwtSpline`
image::ClassDiagrams/QwtSpline-class-hierarchy.png[pdfwidth=10cm]


Das Ergebnis lässt sich am Besten mit einem einfachen parametrischen Datensatz veranschaulichen:

[source,c++]
----
QVector<double> x{1,2,5,6,10,12,15,16,8};
QVector<double> y{5,4,8,8, 4, 5, 8, 9,10};
// Kurve hinzufügen
curve = new QwtPlotCurve();
curve->setStyle(QwtPlotCurve::Lines);
curve->setPen(QColor(0,220,20), 2);
curve->setRenderHint( QwtPlotItem::RenderAntialiased, true ); // Antialiasing verwenden
curve->setSamples(x, y);

// SplineFitter-Objekt erstellen
QwtSplineCurveFitter * splineFitter = new QwtSplineCurveFitter;
// Spline-Implementierung auswählen, hier QwtSplinePleasing
QwtSplinePleasing * spline = new QwtSplinePleasing();
// Splinealgorithmus setzen
splineFitter->setSpline(spline); // takes ownership
// SplineFitter-Objekt der Kurve geben
curve->setCurveFitter(splineFitter); // takes ownership
// fitting einschalten
curve->setCurveAttribute(QwtPlotCurve::Fitted, true);

curve->attach(&plot); // takes ownership
----

.QwtSplineCurveFitter mit QwtSplinePleasing
image::CurveFitterSplinePleasing.png[pdfwidth=10cm]


Die Qwt-Bibliothek bringt eine ganze Reihe verschiedener Algorithmen und passender Implementierungen mit:

- `QwtSplinePleasing`: _"QwtSplinePleasing is some sort of cardinal spline, with non C1 continuous extra rules for narrow angles. It has a locality of 2.
   The algorithm is the one offered by a popular office package."_

- `QwtSplineLocal`: _"QwtSplineLocal offers several standard algorithms for interpolating
   a curve with polynomials having C1 continuity at the control points.
   All algorithms are local in a sense, that changing one control point
   only few polynomials."_
    
    * `Cardinal`: _"The cardinal spline interpolation is a very cheap calculation with a locality of 1"_
    * `ParabolicBlending`: _"Parabolic blending is a cheap calculation with a locality of 1. Sometimes is also called Cubic Bessel interpolation."_
    * `Akima`: _"The algorithm of H.Akima is a calculation with a locality of 2."_
    * `PChip`: _"Piecewise Cubic Hermite Interpolating Polynomial (PCHIP) is an algorithm that is popular because of being offered by MATLAB. It preserves the shape of the data and respects monotonicity. It has a locality of 1."_

- `QwtSplineCubic`: _"A cubic spline is a spline with C2 continuity at all control points. It is a non local spline, what means that all polynomials are changing when one control point has changed."_

[IMPORTANT]
====
Nur `QwtSplinePleasing` funktioniert für wirklich parametrische Kurven mit nicht monoton steigenden x-Werten.
====

Zum Vergleich sind die verschiedenen Spline-Algorithmen dargestellt:

image::CurveFitterSpline1.png[pdfwidth=10cm]
image::CurveFitterSpline2.png[pdfwidth=10cm]


[TIP]
====
Obwohl die verschiedenen Spline-Implementierungen primär für das _QwtPlot_ gedacht sind, spricht nichts dagegen, diese für allgemeine Splineinterpolationsaufgaben einzusetzen. Was die Spline-Klassen in der Qwt-Bibliothek können, ist im Detail im <<sec:splines>> beschrieben.
====


### PolarCurveFitter

Dieser Kurvenfilter ist für Kreisdiagramme gedacht, siehe <<sec:polarPlots>>.


[[sec:weedingCurveFitter]]
### Datenreduktionsfilter





Grundsätzlich muss hier zwischen 
 und ist daher auch als Kurvenfilter implementiert. Ein solcher Datenreduktionsfilter ist in der Klasse `QwtWeedingCurveFitter` implementiert.

Nachfolgendes Beispiel zeigt eine mit _sehr_ vielen Punkten generierte Sinuskurve. Das Zeichnen dieser Kurve geht zwar selbst bei 2K Auflösung noch sehr schnell (ca. 300 ms für das komplette Neuzeichnen des Plots), denn die meisten Punkte liegen übereinander und man kann sich daher das Zeichnen dieser Punkte sparen. Hier kommt der `QwtWeedingCurveFitter` ins Spiel. Verwendet wird dieser Kurvenfilteralgorithmus wie auch die Spline-Filter, jedoch generiert dieser Filter keine neue Kurve, sondern entfernt lediglich redundante und nicht notwendige Punkte. Im Rahmen der konfigurierten Genauigkeit dieses Filters sehen dann die originale und die gefilterte Kurve nahezu identisch aus, obwohl viel weniger Punkte verwendet werden.


Wenn man das Programm ausführt, wird das Plot kurz angezeigt, dann vergrößert und wieder geschlossen. Damit lässt sich die Zeit für das Zeichnen des Plots benchmarken.

Wenn man den `QwtWeedingCurveFitter` im Quelltext deaktiviert, z.B. durch setzen von 

```c++
curve->setCurveAttribute(QwtPlotCurve::Fitted, false);
```

dann gibt das Programm aus:

	QwtPlotCanvas::paintEvent():  308 ms
	QwtPlotCanvas::paintEvent():  298 ms

Wenn man mit eingeschaltetem Kurvefitter arbeitet:

	QwtWeedingCurveFitter::fitCurve() -> 162 points:  635 ms
	QwtPlotCanvas::paintEvent():  1202 ms
	QwtWeedingCurveFitter::fitCurve() -> 284 points:  666 ms
	QwtPlotCanvas::paintEvent():  1225 ms

Zunächst mal ist es interessant, dass der `QwtWeedingCurveFitter` aus den ursprünglich 10000000 Punkten nur gerade mal 162 Punkte bei der 1000x800 Plotgröße und 284 Punkte beim größeren Plot macht. Und tatsächlich sehen beide Diagramme fast identisch aus.
Natürlich wird für die Datenreduktion Zeit benötigt. Bei der niedrigen Auflösung sind das 635 ms. Eigentlich müsste aber nun aufgrund der kleineren Anzahl der Punkte das Zeichnen der Linien dafür umso schneller gehen, aber tatsächlich ist die Zeichenzeit deutlich länger: 1202 - 635 = **567 ms** für das Zeichnen des 1000x800 Pixel großen Plots gegenüber **308 ms** _ohne_ `QwtWeedingCurveFitter`.

[WARNING]
====
Der `QwtWeedingCurveFitter` reduziert wirkungsvoll die Anzahl der gezeichneten Punkte im Diagramm, welches vor allem beim Export von Daten in ein Vektorformat (svg, pdf, siehe <<sec:print>>) zur Reduktion der Datengröße beiträgt. Entgegen der Erwartungshaltung _verlangsamt_ der Filteralgorithmus aber das Zeichnen auf dem Bildschirm. 
====
