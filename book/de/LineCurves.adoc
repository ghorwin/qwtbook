:imagesdir: ../images

<<<
[[sec:linecurves]]
# Kurvendiagramme

Die wohl häufiges Diagrammart werden wohl Kurvendiagramme sein. Kurvendiagramme bzw. Liniendiagramme oder Reihendiagramme sind parametrische Kurven, bei denen die einzelnen Punkte nacheinander gezeichnet werden, und im Fall von Liniendiagrammen durch Linien verbunden werden. Weder x- noch y-Werte müssen monoton steigen.

Das Zeichenelement `QwtPlotCurve` wird jedoch nicht nur für Liniendiagramme im klassischen Sinn benutzt, sondern auch für Stufen, Stäbchen, Punkt/Symbol-Diagramme und so weiter. Alle diese Varianten haben jedoch gemein, dass sie als Daten einen x- und einen y-Vector mit Daten in Plotkoordinaten erwarten.

Der individuelle Stil der Kurve wird mit der Funktion `QwtPlotCurve::setStyle()` festgelegt. Je nach Stil können/müssen weitere Parameter festgelegt werden. In den folgenden Abschnitten werden die möglichen Diagrammtypen für jeweils die gleichen x/y-Daten im Vergleich gezeigt. 

## Datenübergabe
Wie in <<sec:seriesData>> erklärt, wird für die interne Datenhaltung in `QwtPlotCurve` die Klasse `QwtSeriesStore<QPointF>` verwendet.

Daten kann man nun auf mehrere Arten der Plot-Kurve übergeben:

.Verwendung zweier QVector<double> (oder analog QVector<float>)
```c++
QVector<double> x{1,2,5,6,10,12,15,16,17};
QVector<double> y{5,4,8,8, 4, 5, 8, 9,11};
curve->setSamples(x, y);
```

.Verwendung eines QVector<QPointF>
```c++
QVector<QPointF> samples{
	QPointF(1,5),
	QPointF(2,4),
	QPointF(5,8)
};
curve->setSamples(samples);
```

Wenn die Daten in einem C-Array oder `std::vector` vorliegen, bietet sich `QwtPlotCurve::setSamples()` an.

.Übergabe der Daten direkt im Speicher
```c++
std::vector<double> x{1,2,5,6,10,12,15,16,17};
std::vector<double> y{5,4,8,8, 4, 5, 8, 9,11};
const double * xdata = x.data();
const double * ydata = y.data();
unsigned int count = x.size();

curve->setSamples(xdata, ydata, count);
```

[IMPORTANT]
====
Bei der Verwendung von `QwtPlotCurve::setSamples()` werden die Daten _immer_ in den interne `QwtSeriesStore` der Plot-Kurve _kopiert_, auch wenn man hier direkt die Adresse des Speichers mit den Daten übergibt.
====


Bei sehr großen Datenmengen und begrenztem Hauptspeicher kann es sinnvoll sein, die Daten nicht in das Plot hineinzukopieren, sondern die Plotkurven direkt auf den Speicher zugreifen zu lassen. Dafür gibt es die Funktion `QwtPlotCurve::setRawSamples()`. Die Syntax ist wie beim vorherigen Beispiel:

.Direkte Verwendung der im Speicher befindlichen Daten durch as Plot
```c++
const double * xdata = x.data(); // x ist ein std::vector
const double * ydata = y.data(); // y ist ein std::vector
unsigned int count = x.size();
curve->setRawSamples(xdata, ydata, count);
```

[CAUTION]
====
Die Variablen und deren Speicherbereich, welche im Aufruf von `setRawSamples()` verwendet werden, müssen eine längere Lebensdauer haben, als das Plot bzw. die Plotkurve selbst.
====

Direkte Änderung der Daten im Speicher wird beim nächsten Rendern des Plots direkt sichtbar. Allerdings müssen das Plot und dessen  Zeichenelemente, die ein Interesse an den Wertebereichen der Plotkurven haben, manuell über eine Änderung der Daten information werden. Dazu einfach `QwtPlot::replot()`.



## Kurvenarten

### Liniendiagramm

Konfiguration einer `QwtPlotCurve` als Linie:

```c++
QwtPlotCurve *curve = new QwtPlotCurve();
curve->setStyle(QwtPlotCurve::Lines);
```

.Liniendiagramm
image::PlotCurves_StyleLines.png[pdfwidth=8cm]
 
### Stäbchen (Sticks)

Konfiguration einer `QwtPlotCurve` als vertikale Stäbchen:

```c++
QwtPlotCurve *curve = new QwtPlotCurve();
curve->setStyle(QwtPlotCurve::Lines);
curve->setOrientation(Qt::Vertical);
```

.Vertikale Stäbchen
image::PlotCurves_StyleSticksVertical.png[pdfwidth=8cm]

Alternativ kann man die Stäbchen auch horizontal zeichnen. Dazu muss man zusätzlich die Ausrichtung mit `QwtPlotSeriesItem::setOrientation()` setzen:

```c++
QwtPlotCurve *curve = new QwtPlotCurve();
curve->setStyle(QwtPlotCurve::Lines);
curve->setOrientation(Qt::Horizontal);
```

.Horizontale Stäbchen
image::PlotCurves_StyleSticksHorizontal.png[pdfwidth=8cm]


### Stufendiagramme

Wenn die Daten nicht linear verbunden werden sollen, sondern eher Stufen darstellen, kann man den Linientyp `Steps` verwenden.
Das Zusatz-Attribut `QwtPlotCurve::Inverted` gibt dabei an, ob die Stufe am Ende des Intervals oder Anfang des Intervals sein soll. Kurvenattribute werden mit `QwtPlotCurve::setCurveAttribute()` gesetzt:

```c++
QwtPlotCurve *curve = new QwtPlotCurve();
curve->setStyle(QwtPlotCurve::Steps);
curve->setCurveAttribute(QwtPlotCurve::Inverted, false);
```

.Stufendiagramm (normal)
image::PlotCurves_StyleSteps.png[pdfwidth=8cm]


Betrachtet man die Eingangsdaten:

```
x   y
1   5
2   4
5   8
...
``` 

so fällt auf, dass im ersten Intervall, also zwischen x=1..2, der Wert y2=4 gezeichnet wird und an der Stelle x1=1 die Verbindungslinie zwischen y1=5 und y2=4 gezeichnet wird.

Will man direkt den ersten y-Wert im ersten Intervall zeichnen (das wäre eher die natürliche Erwartungshaltung), so muss man das Attribut `Inverted` setzen:

```c++
QwtPlotCurve *curve = new QwtPlotCurve();
curve->setStyle(QwtPlotCurve::Steps);
curve->setCurveAttribute(QwtPlotCurve::Inverted, true);
```

.Stufendiagramm (invertiert)
image::PlotCurves_StyleStepsInverted.png[pdfwidth=8cm]


### Punkte (Dots)

Man kann an den jeweiligen x,y-Koordinaten auch einfach nur Punkte (auch nur einzelne Pixel) zeichnen. Das geht _sehr schnell_ vergleichen mit dem Zeichnen von Symbolen (siehe <<sec:plotSymbols>>) und kann für größere Punktwolken verwendet werden.

[TIP]
====
Bei der Verwendung von `QwtPlotCurve::Dots` sollte man bei heute üblichen Bildschirmauflösungen immer einen `QPen` mit größerer Breite einstellen, da mein _einzelne Pixel_ sonst nur noch schwer sehen kann. Für die Visualisierung großer Punktwolken (> 100000 Pixel) kann die Verwendung von einzelnen Pixeln durchaus noch einen Mehrwert bieten. Für alle besonderen Formen (Kreuze, Rauten, Ringe, Sterne, ...)  ist die Verwendung von Symbolen (siehe <<sec:plotSymbols>>) sinnvoll.
====


```c++
QwtPlotCurve *curve = new QwtPlotCurve();
curve->setStyle(QwtPlotCurve::Dots);
curve->setPen(QColor(180,40,20), 4); // width of 4 makes points better visible
```

.Punktediagramm
image::PlotCurves_StyleDots.png[pdfwidth=8cm]

[TIP]
====
Bei der Visualisierung von Punktwolken kann es hilfreich sein, Transparenz/Alphablending zu benutzen. Dazu einfach bei der Zeichenfarbe noch einen Alphawert kleiner als 255 setzen.
====

```c++
QwtPlotCurve *curve = new QwtPlotCurve();
curve->setStyle(QwtPlotCurve::Dots);
curve->setPen(QColor(0,40,180,32), 2); // 2 pixels wide, alpha value 32
```

.Punktwolke mit halbtransparenten Punkten
image::PlotCurves_StyleDotsScatter.png[pdfwidth=8cm]

[TIP]
====
Wenn man ein Liniendiagramm mit Visualisierung von Stützstellen erhalten will, so kann man natürlich _zwei_ Linien ins Diagramm einfügen: eine mit Stil `QwtPlotCurve::Lines` und die Zweite mit Stil `QwtPlotCurve::Dots` darüber zeichnen, d.h. mit höherem z-Wert. Dann muss man aber auch zwei Mal die Daten ins Diagramm geben und man erhält auch zwei Legendeneinträge (die kann man zwar auch individuell für einzelne Kurven abschalten, siehe <<sec:legend>>), aber zunächst gibt es für jede Kurve je einen Legendeneintrag). Besser ist hier die Verwendung von nur einer Kurve und Symbolen an den Stützstellen (siehe <<sec:plotSymbols>>).
====

### Keine Linie

Möchte man eine Kurve ausschließlich mit Symbolen zeichnen (siehe <<sec:plotSymbols>>), so kann man das Zeichnen des Linienzugs auch komplett ausstellen:

```c++
curve->setStyle(QwtPlotCurve::NoCurve);
```


[[sec:plotSymbols]]
## Symbole/Punkte

An den jeweiligen x,y-Koordinaten einer Kurve kann man auch Symbole zeichnen. Dafür bietet die Qwt-Bibliothek die Klasse `QwtSymbol` an.


Ein Symbol fügt man zu eine Kurve wie folgt hinzu:

```c++
// Symbol hinzufügen
QwtSymbol * symbol = new QwtSymbol(QwtSymbol::Ellipse);
symbol->setSize(8);
symbol->setPen(QColor(0,0,160), 2);
symbol->setBrush(QColor(120,170,255));
curve->setSymbol(symbol); // Curve takes ownership of symbol
```

.Liniendiagramm mit ausgefüllten Kreissymbolen
image::Symbols_EllipseFilled.png[pdfwidth=8cm]

Zuerst wird das zu verwendende Symbol auf dem Heap mit new erzeugt. Der Konstruktor übernimmt den Typ des Symbols (siehe auch Galerie unten). Man kann das aber auch später über `QwtSymbol::setStyle()` setzen.

Wichtig ist auch die Größe des Symbols, gesetzt mittels `QwtSymbol::setSize()` in Pixeln. Diese Größe skaliert das Symbol je nach Form.

Außerdem wichtig sind die Eigenschaften Pen und Brush (`QwtSymbol::setPen()` und `QwtSymbol::setBruch()`). Der Pen wird für das Zeichnen des Umrisses verwendet und der Brush, so gesetzt, für das Ausfüllen der Form. Manche Symbole wie das Kreuz sind nicht ausgefüllt, daher hat hier der Brush keine Wirkung.

Schließlich wird das Symbol der Kurve mit `QwtPlotCurve::setSymbol()` gegeben.

[IMPORTANT]
====
Beim Aufruf von `QwtPlotCurve::setSymbol()` übernimmt die Plot-Kurve die Verantwortung für's Speicheraufräumen.
====

Die Symbolklasse ist ziemlich mächtig und kann verschiedenste Symbole zeichnen:

- vorgefertigte Formen wie Kreise, Rechtecke, Kreuze, etc. (Stil `QwtSymbol::Ellipse`...`QwtSymbol::Hexagon`
- nutzerdefinierte Bilder/Pixmaps (Stil `QwtSymbol::Pixmap`)
- spezifische Grafiken gekapselt in Klasse `QwtGraphic` und erzeugt durch eine Anzahl von `QwtPainterCommand` Anweisungen (Stil `QwtSymbol::Graphic`) (siehe auch <<sec:qwtGraphic>>)
- SVG-Dokumente (Stil `QwtSymbol::SvgDocument`)
- nutzerdefinierte Formen, welche durch einen QPainterPath definiert sind (Stil `QwtSymbol::Path`)


### Symbolstile/Eingebauten Symbolformen

Es gibt zahlreiche eingebaute Symbolformen (fett gedruckt im Diagrammtitel ist jeweils der `QwtSymbol::Style` Enumerationsname):

.Eingebaute Symboltypen/Stile und deren Enumerationstypen
image::Symbols_Gallery.png[pdfwidth=16cm]


Symbole müssen nicht immer quadratisch sein. Wenn man die Größe eines Symbols mit

```c++
symbol->setSize(10);
```

setzt, wird automatisch `width=height=10` verwendet. Alternativ kann man aber auch ein Rechteck als Größe definieren:

```c++
symbol->setSize(w,h);
// oder via QSize
QSize s(w,h);
symbol->setSize(s);
```

Deshalb gibt es auch keine separaten Linienstile für Kreis und Ellipse oder Rechteck und Quadrat.

### Nutzerdefinierte Formen via QPainterPath

Man kann beliebige eigene Symbolformen setzen, indem man die Klasse `QPainterPath` verwendet.
Folgendes Beispiel generiert ein Glühlampensymbol:

```c++
// Symbol hinzufügen
QwtSymbol * symbol = new QwtSymbol(QwtSymbol::Path);
QPainterPath p;
p.addEllipse(QRectF(-10,-10,20,20));
p.moveTo(-7,-7);
p.lineTo(7,7);
p.moveTo(7,-7);
p.lineTo(-7,7);
symbol->setPath(p);
symbol->setPen(QColor(0,0,120), 2);
symbol->setBrush(QColor(160,200,255));
curve->setSymbol(symbol); // Curve takes ownership of symbol
```

.Eigenes Symbol definiert mittels QPainterPath
image::Symbols_PainterPath.png[pdfwidth=8cm]

[CAUTION]
====
Wenn man eine nicht-rechteckige Geometrie mit QPainterPath definiert, sollte man beim Ändern der Größe mittels `QwtSymbol::setSize()` die Variante mit den zwei Argumenten aufrufen, also `QwtSymbol::setSize(width,height)`. Die Variante mit nur einem Argument transformiert den Pfad onst auf ein Quadrat. Da man üblicherweise keine nicht-quadratischen Formen als Symbol definiert, dürfte das aber nur selten ein Problem sein.
====


### SVG-Symbole

Man kann eigene SVG-Dateien rendern und anzeigen lassen. Dafür muss man nur eine SVG-Datei einlesen/definieren und als Symbol setzen:

```c++
QwtSymbol * symbol = new QwtSymbol(QwtSymbol::SvgDocument);
QFile f("symbol.svg");
f.open(QFile::ReadOnly);
QTextStream strm(&f);
QByteArray svgDoc = strm.readAll().toLatin1();
symbol->setSvgDocument(svgDoc);
curve->setSymbol(symbol); // Curve takes ownership of symbol
```

[CAUTION]
====
Auch hier ist beim Festlegen der Größe wieder auf das Seitenverhältnis zu achten und zumeist die Variante `QwtSymbol::setSize(width,height)` zu verwenden.
====

Manchmal liegt der Ankerpunkt des SVG-Bildes nicht im Zentrum, wie in obigem Beispiel:

.Zentriertes SVG-Symbol, welches eigentlich aber nach oben verschoben sein sollte
image::Symbols_SvgCentered.png[pdfwidth=8cm]

Man kann den Ankerpunkt bzw. den Zentrierpunkt des Symbols aber mit `QwtSymbol::setPinPoint()` ändern. Die Koordinaten des PinPoint werden dabei von links/oben des SVG-Bildes gemessen:

```c++
...
QRect br = symbol->boundingRect(); // size of symbol
symbol->setPinPoint(QPointF(br.width()/2-1,br.height()-3));
```

.SVG-Symbol mit korrekter Ausrichtung des "Stecknadel"-Punktes
image::Symbols_SvgWithPinPoint.png[pdfwidth=8cm]

[TIP]
====
Man kann die manuell gesetzten Ankerpunkt auch wieder mit `QwtSymbol::setPinPointEnabled(false)` deaktivieren.
====


### Bild-Symbole (Pixmaps)

Alternativ zu eigenen Vektorgrafiksymbolen kann man auch beliebige Bilder als Symbole verwenden. Dies geschieht analog zu den SVG-Symbolen:

[source,c++]
----
QwtSymbol * symbol = new QwtSymbol(QwtSymbol::Pixmap);
QwtText t("QwtSymbol::Pixmap");
QPixmap pixmap;
pixmap.load("symbol.png");
symbol->setPixmap(pixmap);
QRect br = symbol->boundingRect(); // size of symbol
symbol->setPinPoint(QPointF(br.width()/2,br.height()-1));
curve->setSymbol(symbol); // Curve takes ownership of symbol
----

.Pixmap-Symbol, auch mit manuell festgelegtem "Stecknadel"-Punkt
image::Symbols_Pixmap.png[pdfwidth=8cm]


## Ausgefüllte Kurven

Eine Kurve kann neben dem Zeichenstift auch noch einen Brush übernehmen. Dann wird die Kurve bis zur x-Achse gefüllt:

[source,c++]
----
curve->setBrush(QColor(0xa0d0ff));
----

.Gefüllte Linienkurve
image::PlotCurves_StyleLinesFilled.png[pdfwidth=8cm]

Man kann die Bezugslinie für die Füllung auch noch verschieben:

[source,c++]
----
curve->setBaseLine(8);
----

.Gefüllte Linienkurve mit verschobener Bezugslinie
image::PlotCurves_StyleLinesFilledWithBaseline.png[pdfwidth=8cm]


## Legendeneinträge 

Jede `QwtPlotCurve` erstellt ihr eigenes Icon zur Anzeige in der Legende. Der in der Legende angezeigte Text wird mit `QwtPlotItem::setTitle()` gesetzt. Um die Legende anzuzeigen, muss man wie in <<sec:legend>> beschrieben zunächst eine Legende erstellen und ins Plot einfügen.

.Standardlegende für Datenreihen
image::PlotCurveLegendStandard.png[pdfwidth=8cm]


Zusätzlich kann noch mit `QwtPlotCurve::setLegendAttribute()` festgelegt werden, ob ein ausgefülltes Rechteck, eine Line oder das Reihensymbol in der Legende gezeichnet wird. 

Diese Eigenschaften werden für jede `QwtPlotCurve` individuell gesetzt:

```c++
curve->setTitle("Linie 1");
curve->setLegendAttribute(QwtPlotCurve::LegendShowLine, true);
```

.Legende mit Linien als Icons
image::PlotCurveLegendLinie.png[pdfwidth=8cm]

Bei Linien mit Markierungen kann man auch die Markierungen zeichnen:

```c++
curve->setTitle("Linie 1");
curve->setLegendAttribute(QwtPlotCurve::LegendShowLine, true);
curve->setLegendAttribute(QwtPlotCurve::LegendShowSymbol, true);

QwtSymbol * symbol = new QwtSymbol(QwtSymbol::Rect);
symbol->setSize(6);
symbol->setPen(QColor(0,0,160), 1);
symbol->setBrush(QColor(160,200,255));
curve->setSymbol(symbol); // Curve takes ownership of symbol
```

.Legende mit Linien und Symbolen als Legendenicons
image::PlotCurveLegendLinieWithSymbol.png[pdfwidth=8cm]

[IMPORTANT]
====
Wenn man unterschiedliche Liniensymbole verwendet, dann wirkt sich das auf die automatisch bestimmte Legendenicongröße aus. Somit sind dann die Legendentitel manchmal wie im Screenshot oben nicht perfekt ausgerichtet.

Man kann aber die Größe der Legendenicons mit `QwtPlotItem::setLegendIconSize()` einheitlich ändern.
====

[source,c++]
----
curve->setTitle("Linie 1");
curve->setLegendAttribute(QwtPlotCurve::LegendShowLine, true);
curve->setLegendAttribute(QwtPlotCurve::LegendShowSymbol, true);

QwtSymbol * symbol = new QwtSymbol(QwtSymbol::Rect);
symbol->setSize(6);
symbol->setPen(QColor(0,0,160), 1);
symbol->setBrush(QColor(160,200,255));
curve->setSymbol(symbol); // Curve takes ownership of symbol

// einheitliche Legendenicon-Breite unabhängig vom gewählten Symbol
curve->setLegendIconSize(QSize(30,16));
----

.Legende mit gleichgroßen Legendenicons
image::PlotCurveLegendLinieWithSymbolSameWidth.png[pdfwidth=8cm]

[CAUTION]
====
Da die Legendenicons beim Setzen von Kurvensymbolen konfiguriert werden, muss die Änderung der Legendenicongrößen stets _nach_ dem Setzen/Anpassen von Kurvensymbolen gemacht werden. Also der Aufruf von `setLegendIconSize()` muss _nach_ `setSymbol()` erfolgen!
====

[TIP]
====
Alle Informationen zu Legenden und auch spezifische Anpassungen, z.B. wie man eigene Icons zeichnet, gibt es in <<sec:legend>>.
====

[[sec:curvePerformance]]
## Zeichenattribute, Zeichengeschwindigkeit und Performanceoptimierung bei großen Datenreihen

Das Zeichnen großer Datenreihen kann mitunter einige Zeit beanspruchen. Vor allem beim Größenändern des Plotfensters wirkt sich das dann durch merkliche Verzögerung beim Bildschirmaufbau aus. Je größer die Datenreihen sind, d.h. umsomehr Punkte enthalten sind, umso länger dauert im Allgemeinen das Zeichnen des Plots. In diesem Abschnitt soll es um verschiedene Eigenschaften und Fähigkeiten der `QwtPlotCurve` gehen, die sich direkt auf die Zeichengeschwindigkeit auswirken.

### Zeichenattribute (PaintAttribute / PaintAttributes)

Die Klasse `QwtPlotCurve` hat verschiedene Zeichenattribute, die verwendete Algorithmen näher konfigurieren. Hier ist zunächst eine kurze Liste, wobei die individuellen Attribute und deren Auswirkung später näher beschrieben werden:

- `ClipPolygons` - damit werden zu zeichnende Datenreihen ausgedünnt, sodass nur im aktuellen Zoomfenster sichtbare Kurventeile gezeichnet werden. Ist standardmäßig aktiv und ist für den SVG-Export notwendig. Sonst ist dieses Herausfiltern außerhalb liegender Punkte vor allem beim Hineinzoomen wirkungsvoll.
- `FilterPoints` - damit werden Punkte/Liniensegmente aus den Datenreihen herausgefiltert, die sowieso nicht gezeichnet werden würden, weil sie übereinander liegen.
- `FilterPointsAggressive` - _Nur_ für Linientyp `QwtPlotCurve::Linien`: Ersetzt viele kurze übereinanderliegende Polygonstücke durch einzelne Liniensegmente
- `MinimizeMemory` - _Nur_ beim Linientyp `QwtPlotCurve::Dots`: Verhindert wenn eingeschaltet, dass bei der Transformation der Datenreihe von Plotkoordinaten zu Renderkoordinaten eine eventuell große Polygon-Kopie erstellt wird. Stattdessen werden alle Punktkoordinaten einzeln transformiert, geclippt und gezeichnet. Da hierbei für jeden Punkt ein gewisser Extraaufwand benötigt wird, ist dies in der Regel etwas langsamer.
- `ImageBuffer` - _Nur_ beim Linientyp `QwtPlotCurve::Dots`: Eine sehr spezielle Optimierung, wobei die Punkte (jeweils nur ein Pixel pro Punkt) erst in ein `QImage` gezeichnet werden. Dies erfolgt parallelisiert und kann daher sehr schnell sein, ist allerdings nur effektiv bei sehr großen Punktmengen.

[IMPORTANT]
====
Das Zeichenattribut `FilterPointsAggressive` wirkt sich nur auf Linientyp `QwtPlotCurve::Lines` aus. Die Attribute `MinimizeMemory` und `ImageBuffer` sind sehr spezielle Optimierungen für den Linientyp `QwtPlotCurve::Dots`.
====

### Punktfilter

Durch Verwendung des Datenfiltes `FilterPoints` kann man bei sehr großen Reihendaten nur die Daten wirklich zeichnen, die sich auf das Diagramm auswirken. Wenn bspw. 100 Datenpunkte auf dem gleichen Pixel landen, braucht man die nicht alle zeichnen. Das Ausfiltern nicht sichtbarer Punkte und Liniensegmente hängt natürlich von der Zoomstufe ab und ist deshalb in die Zeichenroutine der `QwtPlotCurve` integriert.

[NOTE]
====
Neben dem Filtern überflüssiger Punkte durch Setzen des Zeichenattributs `FilterPoints` gibt es auch noch die Möglichkeit, den `QwtWeedingCurveFitter` (siehe <<sec:weedingCurveFitter>>) zu verwenden. Dieser ist aber eigentlich für die Datenreduktion beim Export gedacht und wegen des zusätzlichen Berechnungsaufwands dauert das Zeichnen auf dem Bildschirm in der Regel länger.
====

Das Zeichenattribut `QwtPlotCurve::FilterPoints` ist standardmäßig gesetzt und führt dazu, dass beim Transformieren der Datenreihenkoordinaten in Bildschirmkoordinaten bereits doppelte Punkte herausgefiltert werden (dies macht die Klasse `QwtPointMapper`). Enthält eine Datenreihe bspw. 100000 gleichverteilte Punkte entlang der x-Achse und wird auf einem 1000 Pixel breiten Plot gezeichnet, so teilen sich jeweils 100 Punkte eine x-Pixelkoordinate. Wenn nach der Umrechnung der Koordinaten zwei aufeinanderfolgende Punkte identische Pixelkoordinaten haben, werden die doppelten Punkte entfernt. Diese standardmäßig eingeschaltete Funktion macht bereits einen großen Unterschied bei der Zeichengeschwindigkeit. 

Um das mal zu verdeutlichen, ist hier ein kleines Testprogramm für die Filterfunktionen:

.Testprogramm für den Filteralgorithmus mit 10 Millionen Punkten in der Datenreihe
[source,c++]
----
#include <QApplication>
#include <QElapsedTimer>
#include <QDebug>

#include <cmath>

#include <qwt_plot.h>
#include <qwt_plot_curve.h>
#include <qwt_weeding_curve_fitter.h>

// Spezialisierte QwtPlotCurve mit Zeitmessung um drawCurve()
class BenchmarkedPlotCurve : public QwtPlotCurve {
protected:
	void drawCurve(QPainter *p, int style, 
		const QwtScaleMap & xMap, const QwtScaleMap & yMap, 
		const QRectF & canvasRect, int from, int to) const override 
	{
		QElapsedTimer timer;
		timer.start();
		QwtPlotCurve::drawCurve(p, style, xMap, yMap, canvasRect, from, to);
		qDebug() << "QwtPlotCurve::drawCurve(): " << timer.elapsed() << "ms";
	}
};


int main(int argc, char *argv[]) {
	QApplication a(argc, argv);
	QwtPlot plot;
	plot.setContentsMargins(8,8,8,8);
	plot.setCanvasBackground( Qt::white );

	// Daten zum Darstellen generieren
	QVector<double> x, y;
	for (unsigned int i=0; i<10000000; ++i) {
		x.append(i);
		y.append(std::sin(i*0.00001));
	}

	QwtPlotCurve *curve = new BenchmarkedPlotCurve();
	curve->setPen(QColor(180,40,20), 1);
	curve->setRenderHint( QwtPlotItem::RenderAntialiased, true); // Antialiasing verwenden
	curve->setPaintAttribute(QwtPlotCurve::FilterPoints, false); // Punktefilter ausschalten
	curve->setSamples(x, y);
	curve->attach(&plot); // Plot takes ownership

	plot.resize(1000,800);
	plot.show();

	return a.exec();
}
----

Das Testprogramm generiert 10 Millionen Datenpunkte (mehrere Sinuswellen) und zeichet diese dann in ein 1000x800 Pixel großes Diagramm, zunächst _ohne_ Punktefilter. Dazu wird in Zeile

```c++
curve->setPaintAttribute(QwtPlotCurve::FilterPoints, false);
```

das Zeichenattribut `FilterPoints` ausgeschaltet. Die Zeichenzeit für die Kurve einschließlich der Zeit für die Datenfilterung wird in der abgeleiteten `QwtPlotCurve` und dem kleinen Wrapper um die zentrale `drawCurve()`-Funktion gemessen.

Auf meinem Rechner gibt das Programm im Release-Build **1110 ms** aus. Dabei werden wirklich alle 10 Millionen Punkte in den zu zeichnenden Polygonzug übernommen und auf dem Painter gezeichnet (der natürlich Liniensegmente mit Länge 0 verwirft, aber dafür etwas Zeit braucht). 

Schaltet man nun das Attribut `FilterPoints` wieder ein, so enthält das Polygon _nach_ dem Filtern nur noch ca. 24500 Punkte und das Zeichnen dauert ca **300 ms**.


[NOTE]
====
Mit dem Zeichenattribut `FilterPoints` werden unsichtbare/sich überlappende Liniensegmente herausgefiltert, was bei sehr großen Datenreihen eine deutliche Zeichenbeschleunigung bewirkt.
====


### Aggressives Punktefiltern

Wenn Datenreihen sehr stark rauschen dann überlagern sich Liniensegmente mitunter. Zum Beispiel werden dann mehrere Linien mit der gleichen x-Bildschirmkoordinate übereinander gezeichnet, obwohl ja eine Linie gezeichnet zwischen minimaler und maximaler y-Koordinate ausreichen würde. 
Das Zeichenattribut `FilterPointsAggressive` schaltet eine Vorberechnung ein, die genau diese Art der Optimierung durchführt und aus mehreren sich überlagernden, vertikalen Liniensegmenten nur eine einzige Linie macht (deswegen ist diese Optimierung auch nur für den Linientyp `QwtPlotCurve::Linien` sinnvoll).

Um das mal zu testen wandeln wir das Programm oben ab und generieren eine stark rauschende Kurve:


[source,c++]
----
QVector<double> x, y;
for (unsigned int i=0; i<1000000; ++i) {
	x.append(i);
	y.append(QRandomGenerator64::global()->generateDouble());
}
----



### Polygon-Clipping


Außerdem wird der Polygonzug auch am sichtbaren Bildschirmausschnitt geclippt, was bei den 10 Millionen Punkten durchaus auch noch Zeit braucht. Wenn man das Clipping aussschaltet, wiederum durch Abschalten eines Zeichenattributs:

```c++
curve->setPaintAttribute(QwtPlotCurve::ClipPolygons, false);
```

reduziert sich die Zeichenzeit um immerhin 25% auf ca. **730 ms**. Wenn man aber nun in das Diagramm hineinzoomt, bspw. auf der X-Achse in das Interval [0,1000000] (also 10% des Gesamtbereichs), dann liegt die Zeichenzeit ohne Clipping weiterhin bei ca. **1000 ms** aber mit Clipping nur bei **500 ms**.

[TIP]
====
Man kann das standardmäßig gesetzte Zeichenattribut `QwtPlotCurve::ClipPolygons` beim Rendern auf dem Bildschirm abschalten. Da das Zeichnen sowieso auf die Canvas-Fläche begrenzt ist, braucht man das vorherige Ausdünnen des Polyogons nicht. Dadurch, dass der Clipping-Algorithmus dann wegfällt, kann sich die Zeichengeschwindigkeit eines _nicht gezoomten_ Plots erhöhen.  

Sobald man aber in ein Diagramm hineinzoomt, reduziert das Clipping den Zeichenaufwand deutlich.  Daher ist es in der Regel empfehlenswert, das Zeichenattribut `QwtPlotCurve::ClipPolygons` eingeschaltet zu lassen. Beim SVG-Export ist dies sogar notwendig, da hier auf den ViewPort nicht geclippt wird.
====

Der Overhead beim Einschalten des Zeichenattributs `QwtPlotCurve::ClipPolygons` geht im vollständig herausgezoomten Bildausschnitt in der Variabilität der Messwerte unter.

Zusammenfassend kann man sagen, dass das Einschalten des Zeichenattributs `FilterPoints` die Zeichengeschwindigkeit bei großen Datenreihen deutlich beschleunigen kann.









[[sec:curveFitter]]
## Kurvenfilter

Die `QwtPlotCurve` kann die übergebenen Rohdaten vor dem eigentlichen Rendern noch an einen Algorithmus übergeben, der die Daten glättet oder eine kontinuierliche Kuve durch die Datenpunkte legt. Diese Operationen hängen vom aktuellen Zoomlevel und der Plotgröße ab, denn je nach Auflösung wird der Verlauf der angepassten Kurve neu berechnet. Dies gibt eine bessere Qualität als beim Vorberechnen der Daten und Plotten eines Linienzugs durch vorberechnete Kurven. Deshalb ist diese Funktionalität direkt in das `QwtPlot` integriert.

Einen solchen Filteralgorithmus übergibt man der Kurve, indem man eine Klasse, abgeleitet von  `QwtCurveFitter` der Kurve übergibt.

Es werden verschiedene Implementierungen dieser Schnittstelle mitgeliefert:

.Kind-Klassen der Basisklasse `QwtCurveFitter`
image::ClassDiagrams/QwtCurveFitter-class-hierarchy.png[pdfwidth=10cm]

### Kurvenglättung/Spline-Interpolation

Schauen wir uns zuerst den `QwtSplineCurveFitter` an.  Diese Klasse kapselt einen Algorithmus, der aus den gegebenen Stützstellen der Kurve einen weichen Verlauf berechnet. Dafür gibt es verschiedene mathematischen Algorithmen.

Jeder dieser Algorithmen ist in einer von `QwtSpline` abgeleiteten Klasse implementiert.


.Kind-Klassen der Basisklasse `QwtSpline`
image::ClassDiagrams/QwtSpline-class-hierarchy.png[pdfwidth=10cm]


Das Ergebnis lässt sich am Besten mit einem einfachen parametrischen Datensatz veranschaulichen:

[source,c++]
----
QVector<double> x{1,2,5,6,10,12,15,16,8};
QVector<double> y{5,4,8,8, 4, 5, 8, 9,10};
// Kurve hinzufügen
curve = new QwtPlotCurve();
curve->setStyle(QwtPlotCurve::Lines);
curve->setPen(QColor(0,220,20), 2);
curve->setRenderHint( QwtPlotItem::RenderAntialiased, true ); // Antialiasing verwenden
curve->setSamples(x, y);

// SplineFitter-Objekt erstellen
QwtSplineCurveFitter * splineFitter = new QwtSplineCurveFitter;
// Spline-Implementierung auswählen, hier QwtSplinePleasing
QwtSplinePleasing * spline = new QwtSplinePleasing();
// Splinealgorithmus setzen
splineFitter->setSpline(spline); // takes ownership
// SplineFitter-Objekt der Kurve geben
curve->setCurveFitter(splineFitter); // takes ownership
// fitting einschalten
curve->setCurveAttribute(QwtPlotCurve::Fitted, true);

curve->attach(&plot); // takes ownership
----

.QwtSplineCurveFitter mit QwtSplinePleasing
image::CurveFitterSplinePleasing.png[pdfwidth=10cm]


Die Qwt-Bibliothek bringt eine ganze Reihe verschiedener Algorithmen und passender Implementierungen mit:

- `QwtSplinePleasing`: _"QwtSplinePleasing is some sort of cardinal spline, with non C1 continuous extra rules for narrow angles. It has a locality of 2.
   The algorithm is the one offered by a popular office package."_

- `QwtSplineLocal`: _"QwtSplineLocal offers several standard algorithms for interpolating
   a curve with polynomials having C1 continuity at the control points.
   All algorithms are local in a sense, that changing one control point
   only few polynomials."_
    
    * `Cardinal`: _"The cardinal spline interpolation is a very cheap calculation with a locality of 1"_
    * `ParabolicBlending`: _"Parabolic blending is a cheap calculation with a locality of 1. Sometimes is also called Cubic Bessel interpolation."_
    * `Akima`: _"The algorithm of H.Akima is a calculation with a locality of 2."_
    * `PChip`: _"Piecewise Cubic Hermite Interpolating Polynomial (PCHIP) is an algorithm that is popular because of being offered by MATLAB. It preserves the shape of the data and respects monotonicity. It has a locality of 1."_

- `QwtSplineCubic`: _"A cubic spline is a spline with C2 continuity at all control points. It is a non local spline, what means that all polynomials are changing when one control point has changed."_

[IMPORTANT]
====
Nur `QwtSplinePleasing` funktioniert für wirklich parametrische Kurven mit nicht monoton steigenden x-Werten.
====

Zum Vergleich sind die verschiedenen Spline-Algorithmen dargestellt:

image::CurveFitterSpline1.png[pdfwidth=10cm]
image::CurveFitterSpline2.png[pdfwidth=10cm]


[TIP]
====
Obwohl die verschiedenen Spline-Implementierungen primär für das _QwtPlot_ gedacht sind, spricht nichts dagegen, diese für allgemeine Splineinterpolationsaufgaben einzusetzen. Was die Spline-Klassen in der Qwt-Bibliothek können, ist im Detail im <<sec:splines>> beschrieben.
====


### PolarCurveFitter

Dieser Kurvenfilter ist für Kreisdiagramme gedacht, siehe <<sec:polarPlots>>.


[[sec:weedingCurveFitter]]
### Datenreduktionsfilter





Grundsätzlich muss hier zwischen 
 und ist daher auch als Kurvenfilter implementiert. Ein solcher Datenreduktionsfilter ist in der Klasse `QwtWeedingCurveFitter` implementiert.

Nachfolgendes Beispiel zeigt eine mit _sehr_ vielen Punkten generierte Sinuskurve. Das Zeichnen dieser Kurve geht zwar selbst bei 2K Auflösung noch sehr schnell (ca. 300 ms für das komplette Neuzeichnen des Plots), denn die meisten Punkte liegen übereinander und man kann sich daher das Zeichnen dieser Punkte sparen. Hier kommt der `QwtWeedingCurveFitter` ins Spiel. Verwendet wird dieser Kurvenfilteralgorithmus wie auch die Spline-Filter, jedoch generiert dieser Filter keine neue Kurve, sondern entfernt lediglich redundante und nicht notwendige Punkte. Im Rahmen der konfigurierten Genauigkeit dieses Filters sehen dann die originale und die gefilterte Kurve nahezu identisch aus, obwohl viel weniger Punkte verwendet werden.


Wenn man das Programm ausführt, wird das Plot kurz angezeigt, dann vergrößert und wieder geschlossen. Damit lässt sich die Zeit für das Zeichnen des Plots benchmarken.

Wenn man den `QwtWeedingCurveFitter` im Quelltext deaktiviert, z.B. durch setzen von 

```c++
curve->setCurveAttribute(QwtPlotCurve::Fitted, false);
```

dann gibt das Programm aus:

	QwtPlotCanvas::paintEvent():  308 ms
	QwtPlotCanvas::paintEvent():  298 ms

Wenn man mit eingeschaltetem Kurvefitter arbeitet:

	QwtWeedingCurveFitter::fitCurve() -> 162 points:  635 ms
	QwtPlotCanvas::paintEvent():  1202 ms
	QwtWeedingCurveFitter::fitCurve() -> 284 points:  666 ms
	QwtPlotCanvas::paintEvent():  1225 ms

Zunächst mal ist es interessant, dass der `QwtWeedingCurveFitter` aus den ursprünglich 10000000 Punkten nur gerade mal 162 Punkte bei der 1000x800 Plotgröße und 284 Punkte beim größeren Plot macht. Und tatsächlich sehen beide Diagramme fast identisch aus.
Natürlich wird für die Datenreduktion Zeit benötigt. Bei der niedrigen Auflösung sind das 635 ms. Eigentlich müsste aber nun aufgrund der kleineren Anzahl der Punkte das Zeichnen der Linien dafür umso schneller gehen, aber tatsächlich ist die Zeichenzeit deutlich länger: 1202 - 635 = **567 ms** für das Zeichnen des 1000x800 Pixel großen Plots gegenüber **308 ms** _ohne_ `QwtWeedingCurveFitter`.

[WARNING]
====
Der `QwtWeedingCurveFitter` reduziert wirkungsvoll die Anzahl der gezeichneten Punkte im Diagramm, welches vor allem beim Export von Daten in ein Vektorformat (svg, pdf, siehe <<sec:print>>) zur Reduktion der Datengröße beiträgt. Entgegen der Erwartungshaltung _verlangsamt_ der Filteralgorithmus aber das Zeichnen auf dem Bildschirm. 
====
