<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.20">
<meta name="author" content="Andreas Nicolai">
<title>Das Qwt Handbuch</title>
<style>
/* Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */

@import url(../css/asciidoctor.css); /* Default asciidoc style framework - important */

/* roboto-condensed-regular - latin */
@font-face {
  font-family: 'Roboto Condensed';
  font-style: normal;
  font-weight: 400;
  src: url('../fonts/roboto-condensed-v25-latin-regular.eot'); /* IE9 Compat Modes */
  src: local(''),
       url('../fonts/roboto-condensed-v25-latin-regular.eot?#iefix') format('embedded-opentype'), /* IE6-IE8 */
       url('../fonts/roboto-condensed-v25-latin-regular.woff2') format('woff2'), /* Super Modern Browsers */
       url('../fonts/roboto-condensed-v25-latin-regular.woff') format('woff'), /* Modern Browsers */
       url('../fonts/roboto-condensed-v25-latin-regular.ttf') format('truetype'), /* Safari, Android, iOS */
       url('../fonts/roboto-condensed-v25-latin-regular.svg#RobotoCondensed') format('svg'); /* Legacy iOS */
}
/* roboto-condensed-italic - latin */
@font-face {
  font-family: 'Roboto Condensed';
  font-style: italic;
  font-weight: 400;
  src: url('../fonts/roboto-condensed-v25-latin-italic.eot'); /* IE9 Compat Modes */
  src: local(''),
       url('../fonts/roboto-condensed-v25-latin-italic.eot?#iefix') format('embedded-opentype'), /* IE6-IE8 */
       url('../fonts/roboto-condensed-v25-latin-italic.woff2') format('woff2'), /* Super Modern Browsers */
       url('../fonts/roboto-condensed-v25-latin-italic.woff') format('woff'), /* Modern Browsers */
       url('../fonts/roboto-condensed-v25-latin-italic.ttf') format('truetype'), /* Safari, Android, iOS */
       url('../fonts/roboto-condensed-v25-latin-italic.svg#RobotoCondensed') format('svg'); /* Legacy iOS */
}
/* roboto-condensed-700 - latin */
@font-face {
  font-family: 'Roboto Condensed';
  font-style: normal;
  font-weight: 700;
  src: url('../fonts/roboto-condensed-v25-latin-700.eot'); /* IE9 Compat Modes */
  src: local(''),
       url('../fonts/roboto-condensed-v25-latin-700.eot?#iefix') format('embedded-opentype'), /* IE6-IE8 */
       url('../fonts/roboto-condensed-v25-latin-700.woff2') format('woff2'), /* Super Modern Browsers */
       url('../fonts/roboto-condensed-v25-latin-700.woff') format('woff'), /* Modern Browsers */
       url('../fonts/roboto-condensed-v25-latin-700.ttf') format('truetype'), /* Safari, Android, iOS */
       url('../fonts/roboto-condensed-v25-latin-700.svg#RobotoCondensed') format('svg'); /* Legacy iOS */
}
/* roboto-condensed-700italic - latin */
@font-face {
  font-family: 'Roboto Condensed';
  font-style: italic;
  font-weight: 700;
  src: url('../fonts/roboto-condensed-v25-latin-700italic.eot'); /* IE9 Compat Modes */
  src: local(''),
       url('../fonts/roboto-condensed-v25-latin-700italic.eot?#iefix') format('embedded-opentype'), /* IE6-IE8 */
       url('../fonts/roboto-condensed-v25-latin-700italic.woff2') format('woff2'), /* Super Modern Browsers */
       url('../fonts/roboto-condensed-v25-latin-700italic.woff') format('woff'), /* Modern Browsers */
       url('../fonts/roboto-condensed-v25-latin-700italic.ttf') format('truetype'), /* Safari, Android, iOS */
       url('../fonts/roboto-condensed-v25-latin-700italic.svg#RobotoCondensed') format('svg'); /* Legacy iOS */
}

/* CUSTOMISATIONS */
/* Change the values in root for quick customisation. If you want even more fine grain... venture further. */

:root{
--maincolor:#FFFFFF;
--primarycolor:#a90e22;
--secondarycolor:#9f1d0b;
--tertiarycolor: #ededed;
--sidebarbackground:#CCC;
--linkcolor:#b71c1c;
--linkcoloralternate:#f44336;
--white:#FFFFFF;
--black:#000000;
}

/* Text styles */
body{font-family: "Roboto Condensed",sans-serif;}

h1,h2{color:var(--primarycolor) !important;font-family:"Roboto Condensed",sans-serif;}
h3,h4,h5,h6{color:var(--secondarycolor);font-family: "Roboto Condensed",sans-serif; }
.title{color:(--primarycolor) !important;font-family:"Roboto Condensed",sans-serif;font-style: normal; font-weight: normal;}
p{font-family: "Roboto Condensed",sans-serif ! important}
#toc.toc2 a{font-family:"Roboto Condensed",sans-serif;}
/*#toc.toc2 a:link{color:(--linkcolor) !important}
a:visited {color: #ffdbad;}
a.bare:visited {color: #204f83;}
a:hover {color: #317ed4;}
#toc.toc2 a:hover {color: #f1b464;}*/
/* code{background-color: var(--secondarycolor) !important;color:var(--white)} */
code,kbd,pre,samp{font-family:"Consolas","Droid Sans Mono","DejaVu Sans Mono",monospace;monospace;font-size:1em}

/* Table styles */
th{background-color: var(--tertiarycolor);color:var(--black) !important;}

#toctitle{color:var(--primarycolor);font-family: "Roboto Condensed",sans-serif;font-size: 1.6875em;}
#toc.toc2{background-color:#f4f8fd;}
/*#toc.toc2{background-color:#2C001E;color:white;}
#toc.toc2.a{color:white;}
*/

/* Responsiveness fixes */
video {
  max-width: 100%;
}

@media all and (max-width: 600px) {
table {
  width: 55vw!important;
  font-size: 3vw;
}

</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<style>
pre.rouge table td { padding: 5px; }
pre.rouge table pre { margin: 0; }
pre.rouge, pre.rouge .w {
  color: #24292f;
  background-color: #f6f8fa;
}
pre.rouge .k, pre.rouge .kd, pre.rouge .kn, pre.rouge .kp, pre.rouge .kr, pre.rouge .kt, pre.rouge .kv {
  color: #cf222e;
}
pre.rouge .gr {
  color: #f6f8fa;
}
pre.rouge .gd {
  color: #82071e;
  background-color: #ffebe9;
}
pre.rouge .nb {
  color: #953800;
}
pre.rouge .nc {
  color: #953800;
}
pre.rouge .no {
  color: #953800;
}
pre.rouge .nn {
  color: #953800;
}
pre.rouge .sr {
  color: #116329;
}
pre.rouge .na {
  color: #116329;
}
pre.rouge .nt {
  color: #116329;
}
pre.rouge .gi {
  color: #116329;
  background-color: #dafbe1;
}
pre.rouge .ges {
  font-weight: bold;
  font-style: italic;
}
pre.rouge .kc {
  color: #0550ae;
}
pre.rouge .l, pre.rouge .ld, pre.rouge .m, pre.rouge .mb, pre.rouge .mf, pre.rouge .mh, pre.rouge .mi, pre.rouge .il, pre.rouge .mo, pre.rouge .mx {
  color: #0550ae;
}
pre.rouge .sb {
  color: #0550ae;
}
pre.rouge .bp {
  color: #0550ae;
}
pre.rouge .ne {
  color: #0550ae;
}
pre.rouge .nl {
  color: #0550ae;
}
pre.rouge .py {
  color: #0550ae;
}
pre.rouge .nv, pre.rouge .vc, pre.rouge .vg, pre.rouge .vi, pre.rouge .vm {
  color: #0550ae;
}
pre.rouge .o, pre.rouge .ow {
  color: #0550ae;
}
pre.rouge .gh {
  color: #0550ae;
  font-weight: bold;
}
pre.rouge .gu {
  color: #0550ae;
  font-weight: bold;
}
pre.rouge .s, pre.rouge .sa, pre.rouge .sc, pre.rouge .dl, pre.rouge .sd, pre.rouge .s2, pre.rouge .se, pre.rouge .sh, pre.rouge .sx, pre.rouge .s1, pre.rouge .ss {
  color: #0a3069;
}
pre.rouge .nd {
  color: #8250df;
}
pre.rouge .nf, pre.rouge .fm {
  color: #8250df;
}
pre.rouge .err {
  color: #f6f8fa;
  background-color: #82071e;
}
pre.rouge .c, pre.rouge .ch, pre.rouge .cd, pre.rouge .cm, pre.rouge .cp, pre.rouge .cpf, pre.rouge .c1, pre.rouge .cs {
  color: #6e7781;
}
pre.rouge .gl {
  color: #6e7781;
}
pre.rouge .gt {
  color: #6e7781;
}
pre.rouge .ni {
  color: #24292f;
}
pre.rouge .si {
  color: #24292f;
}
pre.rouge .ge {
  color: #24292f;
  font-style: italic;
}
pre.rouge .gs {
  color: #24292f;
  font-weight: bold;
}
</style>
</head>
<body class="article toc2 toc-left">
<div id="header">
<h1>Das Qwt Handbuch</h1>
<div class="details">
<span id="author" class="author">Andreas Nicolai</span><br>
<span id="email" class="email"><a href="mailto:andreas.nicolai@gmx.de">andreas.nicolai@gmx.de</a></span><br>
<span id="revnumber">version 1.0.0,</span>
<span id="revdate">Mai 2025</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Inhaltsverzeichnis</div>
<ul class="sectlevel1">
<li><a href="#_über_dieses_handbuch">Über dieses Handbuch</a></li>
<li><a href="#_überblick_über_die_qwt_bibliothek">1. Überblick über die Qwt Bibliothek</a>
<ul class="sectlevel2">
<li><a href="#_entwicklungsgeschichte">1.1. Entwicklungsgeschichte</a>
<ul class="sectlevel3">
<li><a href="#_download_der_bibliothek">1.1.1. Download der Bibliothek</a></li>
</ul>
</li>
<li><a href="#_widget_konzept_und_erscheinungsbild">1.2. Widget-Konzept und Erscheinungsbild</a></li>
<li><a href="#_besitzereigentümer_konzept_des_qwtplot_widgets">1.3. Besitzer/Eigentümer-Konzept des QwtPlot-Widgets</a></li>
<li><a href="#_zeichenobjekte_und_deren_achsenabhängigkeit">1.4. Zeichenobjekte und deren Achsenabhängigkeit</a></li>
<li><a href="#_vererbungskonzept">1.5. Vererbungskonzept</a></li>
<li><a href="#_qwt_designer_plugins">1.6. Qwt Designer Plugins</a></li>
</ul>
</li>
<li><a href="#sec:tutorial1">2. Erste Schritte und ein interaktives Diagramm</a>
<ul class="sectlevel2">
<li><a href="#_programmrohbau">2.1. Programmrohbau</a>
<ul class="sectlevel3">
<li><a href="#_qmake_projektdatei">2.1.1. QMake Projektdatei</a></li>
<li><a href="#_minimalistisches_hauptprogramm">2.1.2. Minimalistisches Hauptprogramm</a></li>
</ul>
</li>
<li><a href="#_diagrammelemente_hinzufügen">2.2. Diagrammelemente hinzufügen</a>
<ul class="sectlevel3">
<li><a href="#_linie_hinzufügen">2.2.1. Linie hinzufügen</a></li>
<li><a href="#_legende_hinzufügen">2.2.2. Legende hinzufügen</a></li>
<li><a href="#_diagrammtitel_hinzufügen">2.2.3. Diagrammtitel hinzufügen</a></li>
<li><a href="#_diagrammraster_hinzufügen">2.2.4. Diagrammraster hinzufügen</a></li>
<li><a href="#_achsenkonfiguration">2.2.5. Achsenkonfiguration</a></li>
<li><a href="#_logarithmische_achsen">2.2.6. Logarithmische Achsen</a></li>
<li><a href="#_markierungslinien">2.2.7. Markierungslinien</a></li>
</ul>
</li>
<li><a href="#_interaktion_mit_dem_diagramm">2.3. Interaktion mit dem Diagramm</a>
<ul class="sectlevel3">
<li><a href="#_zoomfunktionalität_mit_qwtplotzoomer">2.3.1. Zoomfunktionalität mit QwtPlotZoomer</a></li>
<li><a href="#_plotausschnitt_verschieben_mit_qwtplotpanner">2.3.2. Plotausschnitt verschieben mit QwtPlotPanner</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec:qwtWigets">3. QWT Widgets und Eingabekomponenten</a>
<ul class="sectlevel2">
<li><a href="#_schieberegler_slider">3.1. Schieberegler (Slider)</a></li>
<li><a href="#_drehrädereinstellräder_und">3.2. Drehräder/Einstellräder und</a></li>
<li><a href="#_drehknöpfe">3.3. Drehknöpfe</a></li>
<li><a href="#_analoge_zeiger_anzeigen">3.4. Analoge Zeiger-Anzeigen</a></li>
</ul>
</li>
<li><a href="#sec:qwtPlot">4. Allgemeine Grundlagen des QwtPlot</a>
<ul class="sectlevel2">
<li><a href="#_aufbau_und_elemente_der_diagrammkomponente">4.1. Aufbau und Elemente der Diagrammkomponente</a>
<ul class="sectlevel3">
<li><a href="#_achsen_und_koordinatensystem">4.1.1. Achsen und Koordinatensystem</a></li>
<li><a href="#_diagrammelemente">4.1.2. Diagrammelemente</a></li>
</ul>
</li>
<li><a href="#sec:seriesData">4.2. Datenhaltung im QwtPlot / QwtSeriesStore</a></li>
<li><a href="#_automatisches_zeichnen_oder_zeichnen_bei_bedarf">4.3. Automatisches Zeichnen oder Zeichnen bei Bedarf</a></li>
</ul>
</li>
<li><a href="#sec:linecurves">5. Kurvendiagramme</a>
<ul class="sectlevel2">
<li><a href="#_datenübergabe">5.1. Datenübergabe</a></li>
<li><a href="#_liniendiagramm">5.2. Liniendiagramm</a></li>
<li><a href="#_stäbchen_sticks">5.3. Stäbchen (Sticks)</a></li>
<li><a href="#_stufendiagramme">5.4. Stufendiagramme</a></li>
<li><a href="#_punkte_dots">5.5. Punkte (Dots)</a></li>
<li><a href="#_keine_linie">5.6. Keine Linie</a></li>
<li><a href="#sec:plotSymbols">5.7. Symbole/Punkte</a>
<ul class="sectlevel3">
<li><a href="#_symbolstileeingebauten_symbolformen">5.7.1. Symbolstile/Eingebauten Symbolformen</a></li>
<li><a href="#_nutzerdefinierte_formen_via_qpainterpath">5.7.2. Nutzerdefinierte Formen via QPainterPath</a></li>
<li><a href="#_svg_symbole">5.7.3. SVG-Symbole</a></li>
<li><a href="#_bild_symbole_pixmaps">5.7.4. Bild-Symbole (Pixmaps)</a></li>
</ul>
</li>
<li><a href="#sec:intervalCurves">5.8. Intervallkurven</a></li>
<li><a href="#_gestapelte_intervall_kurvenflächendiagramme">5.9. Gestapelte (Intervall-)Kurven/Flächendiagramme</a></li>
</ul>
</li>
<li><a href="#sec:barPlots">6. Balkendiagramme</a>
<ul class="sectlevel2">
<li><a href="#_grundlegende_eigenschaften_der_plots">6.1. Grundlegende Eigenschaften der Plots</a></li>
<li><a href="#_bezugslinie">6.2. Bezugslinie</a></li>
<li><a href="#_layout_und_abstände">6.3. Layout und Abstände</a>
<ul class="sectlevel3">
<li><a href="#_autoadjustsamples">6.3.1. AutoAdjustSamples</a></li>
<li><a href="#_scalesamplestoaxes">6.3.2. ScaleSamplesToAxes</a></li>
<li><a href="#_scalesampletocanvas">6.3.3. ScaleSampleToCanvas</a></li>
<li><a href="#_layout_empfehlung">6.3.4. Layout-Empfehlung</a></li>
</ul>
</li>
<li><a href="#_balkenformen_und_farben">6.4. Balkenformen und Farben</a></li>
<li><a href="#_balkenbeschriftung_auf_der_x_achse">6.5. Balkenbeschriftung auf der X-Achse</a></li>
<li><a href="#_balkenbeschriftungen">6.6. Balkenbeschriftungen</a></li>
<li><a href="#_mehrfarbige_balken">6.7. Mehrfarbige Balken</a></li>
<li><a href="#_legendeneinträge">6.8. Legendeneinträge</a></li>
<li><a href="#_gestapelte_balkendiagramme_oder_balkendiagramme_mit_mehreren_balken_pro_gruppe">6.9. Gestapelte Balkendiagramme oder Balkendiagramme mit mehreren Balken pro Gruppe</a></li>
</ul>
</li>
<li><a href="#sec:legend">7. Legende</a></li>
<li><a href="#sec:marker">8. Markierungslinien</a></li>
<li><a href="#sec:axes">9. Plotachsen</a>
<ul class="sectlevel2">
<li><a href="#_allgemeine_achsenformatierung">9.1. Allgemeine Achsenformatierung</a></li>
<li><a href="#sec:axisScales">9.2. Skalen</a></li>
</ul>
</li>
<li><a href="#sec:qwttext">10. QwtText und Sonderformatierungen</a>
<ul class="sectlevel2">
<li><a href="#sec:mathML">10.1. MathML</a></li>
</ul>
</li>
<li><a href="#sec:zoomer">11. Interaktiver Zoom und Verschieben von Diagrammausschnitten</a></li>
<li><a href="#sec:styling">12. Anpassung/Styling der Qwt Komponenten</a>
<ul class="sectlevel2">
<li><a href="#_allgemeines_zu_farbpaletten">12.1. Allgemeines zu Farbpaletten</a></li>
<li><a href="#_rahmen_und_zeichenfläche_des_diagramms">12.2. Rahmen und Zeichenfläche des Diagramms</a>
<ul class="sectlevel3">
<li><a href="#_farbe_und_rahmen_des_plots">12.2.1. Farbe und Rahmen des Plots</a></li>
<li><a href="#_zeichenfläche">12.2.2. Zeichenfläche</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec:print">13. Exportieren und Drucken</a>
<ul class="sectlevel2">
<li><a href="#_exportieren_des_plots_als_pixelgrafik">13.1. Exportieren des Plots als Pixelgrafik</a>
<ul class="sectlevel3">
<li><a href="#_erstellen_einer_1_zu_1_kopie_des_plotwidgets">13.1.1. Erstellen einer 1-zu-1 Kopie des Plotwidgets</a></li>
<li><a href="#_kopie_in_die_zwischenablage">13.1.2. Kopie in die Zwischenablage</a></li>
<li><a href="#_qwtplot_mit_anderer_auflösung_abspeichern">13.1.3. QwtPlot mit anderer Auflösung abspeichern</a></li>
<li><a href="#_diagrammelemente_skalieren_dpi_ändern">13.1.4. Diagrammelemente skalieren (DPI ändern)</a></li>
</ul>
</li>
<li><a href="#_exportieren_des_plots_als_vektorgrafik">13.2. Exportieren des Plots als Vektorgrafik</a></li>
<li><a href="#_drucken">13.3. Drucken</a></li>
</ul>
</li>
<li><a href="#_fortgeschrittene_themen">14. Fortgeschrittene Themen</a>
<ul class="sectlevel2">
<li><a href="#sec:releasingObjectsFromQwtPlot">14.1. Objekte aus dem QwtPlot loslösen</a></li>
</ul>
</li>
<li><a href="#sec:building">15. Download/Installation/Erstellung der Qwt Bibliothek</a>
<ul class="sectlevel2">
<li><a href="#_download_fertiger_pakete">15.1. Download fertiger Pakete</a>
<ul class="sectlevel3">
<li><a href="#_windowsmac">15.1.1. Windows/Mac</a></li>
<li><a href="#_linux">15.1.2. Linux</a></li>
</ul>
</li>
<li><a href="#sec:buildingFromSource">15.2. Erstellung aus dem Quelltext</a>
<ul class="sectlevel3">
<li><a href="#_windows">15.2.1. Windows</a></li>
<li><a href="#_linuxmac">15.2.2. Linux/Mac</a></li>
</ul>
</li>
<li><a href="#sec:designerPlugins">15.3. Qt Designer Plugins</a></li>
<li><a href="#_verwendung_des_plots_in_eigenen_programmen">15.4. Verwendung des Plots in eigenen Programmen</a>
<ul class="sectlevel3">
<li><a href="#_windows_2">15.4.1. Windows</a></li>
<li><a href="#_linuxmac_2">15.4.2. Linux/Mac</a></li>
</ul>
</li>
<li><a href="#sec:usingQwtPlot">15.5. Das QwtPlot in eine Designer-Oberfläche/ui-Datei integrieren</a>
<ul class="sectlevel3">
<li><a href="#_definition_eines_platzhalterwidgets">15.5.1. Definition eines Platzhalterwidgets</a></li>
<li><a href="#_verwendung_der_designer_plugins">15.5.2. Verwendung der Designer-Plugins</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_über_den_autor">16. Über den Autor</a></li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_über_dieses_handbuch">Über dieses Handbuch</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Dieses Projekt ergänzt die API-Dokumentation zur Qwt-Bibliothek und bietet sowas wie ein Programmiererhandbuch mit vielen Details zu den Internas der Bibliothek. Der Fokus liegt aber ganz klar auf der <code>QwtPlot</code> Diagrammkomponente.
Das ist übrigends schon die 2. Auflage (komplett neu überarbeitet), weil es zum Zeitpunkt der ersten Ausgabe noch kein tolles AsciiDoc gab und ich irgendwie beim Textschreiben hängengeblieben bin.</p>
</div>
<div class="paragraph">
<p>Die englische Version und die PDF-Variante gibt&#8217;s hier: <a href="https://ghorwin.github.io/qwtbook">https://ghorwin.github.io/qwtbook</a>.</p>
</div>
<div class="paragraph">
<p>Die Texte und Bilder stehen unter der Creative-Commons BY-NC Lizenz (siehe Lizenztext im Qwt Handbuch Repository <a href="https://github.com/ghorwin/QwtBook">https://github.com/ghorwin/QwtBook</a>), können also frei verwendet, modifiziert und angepasst werden, aber bitte nicht publiziert oder zum Training von kommerziellen KI-Systemen benutzt werden.
Alle Quelltextbeispiele, sowohl im Text, als auch in den herunterladbaren Tutorial/Beispiel-Quelltextarchiven, stehen unter der MIT-Lizenz und können damit in open-source wie auch kommerziellen Projekten genutzt werden.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Häufig wird das <code>QwtPlot</code> ja benutzt, um ein eigenes Postprozessing oder Visualisierungstool zu schreiben. Vielleicht lohnt sich hier der Blick auf das kostenfreie <em>PostProc 2</em>, welches wir an der TU Dresden entwickelt haben und das intern ein angepasstes und erweitertes <code>QwtPlot</code> verwendet. Das Programm ist spezialisiert auf die Visualisierung von dynamischen Simulationsergebnissen und Messdaten/Zeitreihen und man kann da einen guten Eindruck davon bekommen, was mit <code>QwtPlot</code> alles machbar ist. <em>Postproc 2</em> wird weiter aktiv gepflegt und kann hier kostenfrei heruntergeladen werden: <a href="https://bauklimatik-dresden.de/software/postproc2/">https://bauklimatik-dresden.de/software/postproc2/</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Viel Spaß bei der Lektüre - und falls noch Inhalte fehlen, einfach Geduld haben und später wiederkommen (oder im Github-Repo ein Issue anlegen). Und schaut Euch vielleicht auch meine anderen Tutorials unter <a href="https://schneggenport.de">https://schneggenport.de</a> an!</p>
</div>
<div class="paragraph">
<p>&#8201;&#8212;&#8201;Andreas Nicolai</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_überblick_über_die_qwt_bibliothek">1. Überblick über die Qwt Bibliothek</h2>
<div class="sectionbody">
<div class="paragraph">
<p><em>Qwt - Qt Widgets for Technical Applications</em> ist eine Open-Source Bibliothek für technische Anwendungen und stellt
bestimmte Widgets für Anzeigen und Kontrollkomponenten bereit. Die wohl wichtigste Komponente der Qwt Bibliothek ist das <code>QwtPlot</code>,
eine sehr flexible und mächtige Diagrammkomponente.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/exBode.png" alt="exBode">
</div>
<div class="title">Abbildung 1. Beispiel für die QwtPlot-Komponente</div>
</div>
<div class="paragraph">
<p>Die Qwt Bibliothek steht unter einer Open-Source-Lizenz, wurde und wird aktiv vom Entwickler <em>Uwe Rathmann</em> gepflegt und wird auf SourceForge.net gehostet:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="http://qwt.sourceforge.net">Qwt Webseite (englisch)</a></p>
</li>
<li>
<p><a href="https://sourceforge.net/projects/qwt">Qwt SourceForge Projektseite</a></p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_entwicklungsgeschichte">1.1. Entwicklungsgeschichte</h3>
<div class="ulist">
<ul>
<li>
<p>die erste Version der Qwt-Bibliothek stammt noch aus dem Jahr 1997 von Josef Wilgen</p>
</li>
<li>
<p>seit 2002 wird die Bibliothek von <em>Uwe Rathmann</em> entwickelt und gepflegt</p>
</li>
<li>
<p>Version 5 ist wohl am weitesten verbreitet (erstes Release vom 26.02.2007)</p>
</li>
<li>
<p>Version 6 (erstes Release vom 15.04.2011, kein Qt3 Support mehr) enthält wesentliche API-Änderungen</p>
</li>
<li>
<p>aktuelle stabile Version 6.3.0 (Stand Mai 2025)</p>
</li>
<li>
<p>im trunk gibt es zum Teil bereits wesentlich mehr und fortgeschrittene Funktionen</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_download_der_bibliothek">1.1.1. Download der Bibliothek</h4>
<div class="paragraph">
<p>Die Qwt Bibliothek kann von der <a href="https://sourceforge.net/projects/qwt">Qwt SourceForge Projektseite</a> als Quelltextarchiv geladen werden. Unter Linux wird Qwt bei vielen Distributionen als Paket gehalten. Genau genommen gibt es mehrere Pakete für die unterschiedlichen Qwt-Bibliotheksversionen bzw. Qt Versionen. Details zur Installation und Verwendung der Bibliothek gibt es im <a href="#sec:building">Kapitel 15</a>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_widget_konzept_und_erscheinungsbild">1.2. Widget-Konzept und Erscheinungsbild</h3>
<div class="paragraph">
<p>Die Qwt Bibliothek liefert Komponenten, welche analog zu den normalen Qt-Widgets in Desktopanwendungen verwendet werden können. Die Komponenten verwenden die Qt Palette, sodass die Qwt-Widgets in die jeweilige Oberfläche passen. Dadurch integrieren sich die Widgets nahtlos in Programmoberflächen. Einzelne Komponenten des <code>QwtPlot</code> unterstützen auch Styles. So ermöglichen z.B. Abrundungseffekte beim Plot-Widget das Immitieren klassischer Anzeigen.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/styledDialsAndPlot.png" alt="styledDialsAndPlot">
</div>
<div class="title">Abbildung 2. QwtPlot mit abgerundeten Ecken</div>
</div>
<div class="paragraph">
<p>Details zum Styling und zur Anpassung des Erscheinungsbildes sind im <a href="#sec:styling">Kapitel 12</a> zu finden.</p>
</div>
</div>
<div class="sect2">
<h3 id="_besitzereigentümer_konzept_des_qwtplot_widgets">1.3. Besitzer/Eigentümer-Konzept des QwtPlot-Widgets</h3>
<div class="paragraph">
<p>Eine grundlegende Eigenschaft der <code>QwtPlot</code>-Klasse ist die Besitzübername hinzugefügter Elemente. Dies gilt allgemein für alle Elemente des Plots (Linien, Marker, Legende, &#8230;&#8203;). D.h. nach Übertragung der Eigentümerschaft kümmert sich das <code>QwtPlot</code> um das Aufräumen des Speichers.</p>
</div>
<div class="paragraph">
<p>Einmal hinzugefügte Elemente werden nicht wieder losgelöst werden (bzw. nur über einen Trick, wie im <a href="#sec:releasingObjectsFromQwtPlot">Kapitel 14.1</a> beschrieben wird). Daher ist es sinnvoll, bei veränderlichen Diagrammelementen einen Mechanismus zur jeweiligen Neuerstellung eines Zeichenobjekts vorzusehen (Factory-Konzept).</p>
</div>
</div>
<div class="sect2">
<h3 id="_zeichenobjekte_und_deren_achsenabhängigkeit">1.4. Zeichenobjekte und deren Achsenabhängigkeit</h3>
<div class="paragraph">
<p>Ein wesentliches Designmerkmal beim <code>QwtPlot</code> ist die Möglichkeit, beliebige Zeichenobjekte (Kurven, Marker, Legende, &#8230;&#8203;) dem Plot zu übergeben. Damit sich diese Zeichenobjekte (engl. <em>PlotItem</em>) am Koordinatengitter ausrichten können, wird ihnen eine Achsenabhängigkeit gegeben. Dadurch erhalten diese Zeichenobjekte eine Information, wann immer sich die Achsenskalierung ändert (durch Zoomen, oder Änderung der Wertebereiche etc.).</p>
</div>
<div class="paragraph">
<p>Diese Funktionalität definiert die zentrale Bedeutung der (bis zu) 4 Achsen im Diagramm. Deswegen sind diese auch fest im <code>QwtPlot</code> verankert und werden nicht wie andere Zeichenobjekte beliebig hinzugefügt.</p>
</div>
</div>
<div class="sect2">
<h3 id="_vererbungskonzept">1.5. Vererbungskonzept</h3>
<div class="paragraph">
<p>Grundsätzlich ist das <code>QwtPlot</code> und die beteiligten Klassen auf maximale Anpassungsfähigkeit ausgelegt, d.h. es wird (fast) überall Polymorphie unterstützt. Wenn die eingebaute Funktionalität nicht zureichend ist, kann man einfach immer die entsprechende Klasse ableiten und die jeweils anzupassende Funktion re-implementieren und verändern. Dies wird anhand von Beispielen in den individuellen Kapiteln des Handbuchs beschrieben.</p>
</div>
</div>
<div class="sect2">
<h3 id="_qwt_designer_plugins">1.6. Qwt Designer Plugins</h3>
<div class="paragraph">
<p>Die Qwt Bibliothek bringt Plugins für Qt Designer bzw. Qt Creator mit, welche das Einfügen von Qwt-Komponenten in ui-Dateien erleichtert. Es lassen sich jedoch keine QwtPlot-Eigenschaften festlegen oder Kurven hinzufügen. Die eigentliche Anpassung und Ausgestaltung des Plots erfolgt im Quelltext.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Die API der Qt Designer Plugins hat sich in jüngeren Qt Creator-Versionen geändert, weswegen die Qwt Designer Plugins mit aktuellen Qt und Qt Creator Versionen nicht mehr funktionieren selbst wenn man die mit den passenden Bibliotheksversionen kompiliert.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Auch deswegen wird die Konfiguration und Anpassung des <code>QwtPlot</code> in diesem Handbuch ausschließlich durch normale API-Aufrufe demonstriert.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Soll das <code>QwtPlot</code> auch ohne Designer-Plugins im grafischen QtDesigner-Editor eingefügt werden, kann man einfach ein QWidget einfügen und dieses als Platzhalter für die <code>QwtPlot</code>-Klasse definieren, siehe <a href="#sec:usingQwtPlot">Kapitel 15.5</a>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sec:tutorial1">2. Erste Schritte und ein interaktives Diagramm</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Um mit der Qwt-Bibliothek warm zu werden, erstellen wir in einem einfachen Beispiel ein interaktives Diagramm mit der <code>QwtPlot</code>-Komponente.
Der komplette Beispielquelltext ist als 7z-Archiv herunterladbar: <a href="../code/tutorial1.7z">tutorial1.7z</a></p>
</div>
<div class="sect2">
<h3 id="_programmrohbau">2.1. Programmrohbau</h3>
<div class="sect3">
<h4 id="_qmake_projektdatei">2.1.1. QMake Projektdatei</h4>
<div class="paragraph">
<p>Wir beginnen mit der qmake-Projektdatei, in der wir den Pfad für die Header-Dateien der Bibliothek und die zu linkende Bibliothek festlegen. Hier gehe ich davon aus, dass Qwt aus dem 6.3.0er Quelltextarchiv gebaut und lokal in die Standardverzeichnisse (<code>C:\qwt-6.3.0</code> unter Windows und <code>/usr/local/qwt-6.3.0</code> unter Linux/Mac) installiert wurde. Infos über das Compilieren der Bibliothek aus dem Quelltext und Installation gibt es in <a href="#sec:building">Kapitel 15</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sh">TARGET   <span class="o">=</span> Tutorial1
QT       +<span class="o">=</span> core gui widgets
CONFIG   +<span class="o">=</span> c++11

win32 <span class="o">{</span>
	<span class="c"># Pfad zu den Qwt Headerdateien hinzufügen</span>
	INCLUDEPATH +<span class="o">=</span> C:/qwt-6.3.0/include
	CONFIG<span class="o">(</span>debug, debug|release<span class="o">)</span> <span class="o">{</span>
		QWTLIB <span class="o">=</span> qwtd
	<span class="o">}</span>
	<span class="k">else</span> <span class="o">{</span>
		QWTLIB <span class="o">=</span> qwt
	<span class="o">}</span>
	<span class="c"># Linkerpfad</span>
	LIBS +<span class="o">=</span> <span class="nt">-LC</span>://qwt-6.3.0/lib <span class="nt">-l</span><span class="nv">$$</span>QWTLIB
<span class="o">}</span>
<span class="k">else</span> <span class="o">{</span>
	<span class="c"># Pfad zu den Qwt Headerdateien hinzufügen</span>
	INCLUDEPATH +<span class="o">=</span> /usr/local/qwt-6.3.0/include/
	<span class="c"># Linkerpfad, unter Linux wird standardmäßig nur die release-Version der Lib gebaut und installiert</span>
	LIBS +<span class="o">=</span> <span class="nt">-L</span>/usr/local/qwt-6.3.0/lib <span class="nt">-lqwt</span>
<span class="o">}</span>

SOURCES +<span class="o">=</span> main.cpp</code></pre>
</div>
</div>
<div class="paragraph">
<p>Dies ist eine <code>.pro</code>-Datei für eine Qwt-6.3.0-Installation aus dem Quelltext mit Standardeinstellungen (siehe <a href="#sec:buildingFromSource">Kapitel 15.2</a>).</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Beachte, dass die im Debug-Modus kompilierte Qwt-Bibliothek ein angehängtes <em>d</em> hat. Unter Linux wird standardmäßig nur die release-Version gebaut und installiert, daher braucht man hier die Fallunterscheidung nicht.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_minimalistisches_hauptprogramm">2.1.2. Minimalistisches Hauptprogramm</h4>
<div class="paragraph">
<p>Für die Verwendung des <code>QwtPlot</code> braucht man nur eine sehr minimalistische <code>main.cpp</code>.</p>
</div>
<div class="listingblock">
<div class="title">Hauptprogramm, in dem nur das nackige Plot selbst erstellt und angezeigt wird</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="cp">#include</span> <span class="cpf">&lt;QApplication&gt;</span><span class="cp">
</span>
<span class="cp">#include</span> <span class="cpf">&lt;QwtPlot&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
	<span class="n">QApplication</span> <span class="n">a</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>
	<span class="n">QwtPlot</span> <span class="n">plot</span><span class="p">;</span>
	<span class="n">plot</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="mi">800</span><span class="p">,</span><span class="mi">500</span><span class="p">);</span>
	<span class="n">plot</span><span class="p">.</span><span class="n">show</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">exec</span><span class="p">();</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Wenn man das Programm compiliert hat und ausführen will, beklagt sich Windows über eine fehlende DLL.
Dazu in den Projekteinstellungen, unter "Ausführen", im Abschnitt "Umgebung" die PATH-Variable bearbeiten und dort den Pfad <code>C:\qwt-6.3.0\lib</code> hinzufügen.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Das Programm zeigt ein ziemlich langweiliges (und hässliches) Diagrammfenster (später wird das noch ansehnlicher gestaltet).</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/Tutorial1_a.png" alt="Tutorial1 a">
</div>
<div class="title">Abbildung 3. Das nackte Plotwidget</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Ein Hinweis zu den Header-Dateien der Qwt-Bibliothek.</p>
</div>
<div class="paragraph">
<p>Analog zu Qt Klassen werden die Qwt-Klassen über den gleichnamigen Header eingebunden, also:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="cp">#include</span> <span class="cpf">&lt;QwtPlot&gt;</span><span class="c1">       // für Klasse QwtPlot</span><span class="cp">
#include</span> <span class="cpf">&lt;QwtPlotCurve&gt;</span><span class="c1">  // für Klasse QwtPlotCurve</span><span class="cp">
#include</span> <span class="cpf">&lt;QwtLegend&gt;</span><span class="c1">     // für Klasse QwtLegend</span><span class="cp">
</span><span class="c1">// ...</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Diese Header-Dateien sind aber nur Wrapper um die eigentlichen Include-Dateien, mit dem Benennungsschema:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="cp">#include</span> <span class="cpf">&lt;qwt_plot.h&gt;</span><span class="c1">        // für Klasse QwtPlot</span><span class="cp">
#include</span> <span class="cpf">&lt;qwt_plot_curve.h&gt;</span><span class="c1">  // für Klasse QwtPlotCurve</span><span class="cp">
#include</span> <span class="cpf">&lt;qwt_legend.h&gt;</span><span class="c1">      // für Klasse QwtLegend</span><span class="cp">
</span><span class="c1">// ...</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In früheren Versionen der Qwt-lib (auch der Debian-Paket-Version <code>libqwt-qt5-dev</code>) wurden die Wrapper-Headerdateien nach dem neuen Namensschema nicht installiert, sodass man die originalen <code>qwt_xxx.h</code> Includes verwenden muss. Wenn man also auch ältere Qwt-Versionen unterstützen möchte, bzw. unter Linux die Paketversion verwenden will, sollte die originalen Headerdateinamen verwenden.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_diagrammelemente_hinzufügen">2.2. Diagrammelemente hinzufügen</h3>
<div class="sect3">
<h4 id="_linie_hinzufügen">2.2.1. Linie hinzufügen</h4>
<div class="paragraph">
<p>Als erstes fügen wir eine Linie bzw. Diagrammkurve hinzu (Header <code>QwtPlotCurve</code> bzw. <code>qwt_plot_curve.h</code>):</p>
</div>
<div class="listingblock">
<div class="title">Hauptprogramm mit einer Linie</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="cp">#include</span> <span class="cpf">&lt;QApplication&gt;</span><span class="cp">
</span>
<span class="cp">#include</span> <span class="cpf">&lt;QwtPlot&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;QwtPlotCurve&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
	<span class="n">QApplication</span> <span class="n">a</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>
	<span class="n">QwtPlot</span> <span class="n">plot</span><span class="p">;</span>
	<span class="n">plot</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="mi">500</span><span class="p">,</span><span class="mi">300</span><span class="p">);</span>

	<span class="c1">// etwas Abstand zwischen Rand und Achsentiteln</span>
	<span class="n">plot</span><span class="p">.</span><span class="n">setContentsMargins</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">);</span>
	<span class="c1">// Hintergrund der Zeichenfläche soll weiß sein</span>
	<span class="n">plot</span><span class="p">.</span><span class="n">setCanvasBackground</span><span class="p">(</span> <span class="n">Qt</span><span class="o">::</span><span class="n">white</span> <span class="p">);</span>

	<span class="c1">// Daten zum Darstellen einlesen</span>
	<span class="n">QVector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
	<span class="n">QFile</span> <span class="n">f</span><span class="p">(</span><span class="s">"spektrum.tsv"</span><span class="p">);</span>  <span class="c1">// Datei enthält 2 Spalten</span>
	<span class="n">f</span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="n">QFile</span><span class="o">::</span><span class="n">ReadOnly</span><span class="p">);</span>
	<span class="n">QTextStream</span> <span class="n">strm</span><span class="p">(</span><span class="o">&amp;</span><span class="n">f</span><span class="p">);</span>
	<span class="n">strm</span><span class="p">.</span><span class="n">readLine</span><span class="p">();</span> <span class="c1">// Kopfzeile überspringen</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">strm</span><span class="p">.</span><span class="n">atEnd</span><span class="p">())</span> <span class="p">{</span>
		<span class="kt">double</span> <span class="n">xval</span><span class="p">,</span> <span class="n">yval</span><span class="p">;</span>
		<span class="n">strm</span> <span class="o">&gt;&gt;</span> <span class="n">xval</span> <span class="o">&gt;&gt;</span> <span class="n">yval</span><span class="p">;</span>
		<span class="n">x</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">xval</span><span class="p">);</span>
		<span class="n">y</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">yval</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">QwtPlotCurve</span> <span class="o">*</span><span class="n">curve</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">QwtPlotCurve</span><span class="p">();</span>
	<span class="n">curve</span><span class="o">-&gt;</span><span class="n">setPen</span><span class="p">(</span><span class="n">QColor</span><span class="p">(</span><span class="mi">180</span><span class="p">,</span><span class="mi">40</span><span class="p">,</span><span class="mi">20</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">curve</span><span class="o">-&gt;</span><span class="n">setTitle</span><span class="p">(</span><span class="s">"Gamma-Spektrum"</span><span class="p">);</span>
	<span class="n">curve</span><span class="o">-&gt;</span><span class="n">setRenderHint</span><span class="p">(</span> <span class="n">QwtPlotItem</span><span class="o">::</span><span class="n">RenderAntialiased</span><span class="p">,</span> <span class="nb">true</span> <span class="p">);</span> <span class="c1">// Antialiasing verwenden</span>
	<span class="n">curve</span><span class="o">-&gt;</span><span class="n">setSamples</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
	<span class="n">curve</span><span class="o">-&gt;</span><span class="n">attach</span><span class="p">(</span><span class="o">&amp;</span><span class="n">plot</span><span class="p">);</span> <span class="c1">// Plot takes ownership</span>

	<span class="n">plot</span><span class="p">.</span><span class="n">show</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">exec</span><span class="p">();</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Im erweiterten Hauptprogramm wird zunächst der Header für die <code>QwtPlotCurve</code> eingebunden. Das Kurvenobjekt selbst wird mit <code>new</code> auf dem Heap erstellt. Die Daten der Kurve lesen wir aus einer Textdatei (2 Spalten, mit Kopfzeile) aus. Die Datei <code>spektrum.tsv</code> ist im Archiv des Tutorialquelltextes enthalten.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Achtung"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Grundsätzlich gilt beim <code>QwtPlot</code>: Alle Plotelemente <em>müssen</em> via new auf dem Heap erstellt werden und dem Plot dann übergeben werden. Dieses wird dann Besitzer und gibt den Speicher frei. Deshalb dürfen Linien, Legende, Marker etc. <em>niemals</em> als Stack-Variablen erstellt werden, sonst gibt es (je nach Destruktoraufrufreihenfolge) einen Speicherzugriffsfehler.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Attribute wie Linienfarbe, Titel (wird später in der Legende angezeigt), und Antialising werden gesetzt (im <a href="#sec:linecurves">Kapitel 5</a> werden alle Eigenschaften von Linien im Detail erläutert).</p>
</div>
<div class="paragraph">
<p>Die Funktion <code>setSamples()</code> setzt die Daten der Linie. Wichtig ist hier, dass die übergebenen Vectoren die gleiche Länge haben. Es handelt sich um eine parametrische Kurve, d.h. weder x noch y Werte müssen monoton sein oder sonstwelchen Regeln folgen. Jedes x,y Wertepaar definiert einen Punkt und diese Punkte werden mit der Linie verbunden.</p>
</div>
<div class="paragraph">
<p>Die Funktion <code>attach()</code> fügt das <code>QwtPlotCurve</code>-Objekt zum Diagramm hinzu.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Beim Hinzufügen der Linie mittels <code>attach()</code> zum Diagramm wird das Plot neuer Eigentümer und kümmert sich um das Aufräumen des Speichers. Man muss also nicht mehr manuell <code>delete</code> für das <code>QwtPlotCurve</code>-Objekt aufrufen.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Zusätzlich zu dem Code, welcher die Linie hinzufügt, wurden noch 2 kleine Anpassungen am Erscheinungsbild vorgenommen:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Ränder wurden mittels <code>setContentsMargins()</code> hinzugefügt (siehe auch <code>QWidgdet::setContentsMargins()</code> )</p>
</li>
<li>
<p>der Hintergrund der Zeichenfläche (<em>canvas</em>) wurde weiß gefärbt.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Das Ergebnis sieht schon eher nach Diagramm aus.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/Tutorial1_b.png" alt="Tutorial1 b">
</div>
<div class="title">Abbildung 4. Diagramm mit Linie</div>
</div>
</div>
<div class="sect3">
<h4 id="_legende_hinzufügen">2.2.2. Legende hinzufügen</h4>
<div class="paragraph">
<p>Als nächstes wird eine Legende eingefügt (Header <code>QwtLegend</code> bzw. <code>qwt_legend.h</code>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="c1">// Legende anzeigen</span>
<span class="n">QwtLegend</span> <span class="o">*</span> <span class="n">legend</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">QwtLegend</span><span class="p">();</span>
<span class="n">QFont</span> <span class="n">legendFont</span><span class="p">;</span>
<span class="n">legendFont</span><span class="p">.</span><span class="n">setPointSize</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>
<span class="n">legend</span><span class="o">-&gt;</span><span class="n">setFont</span><span class="p">(</span><span class="n">legendFont</span><span class="p">);</span>
<span class="n">plot</span><span class="p">.</span><span class="n">insertLegend</span><span class="p">(</span> <span class="n">legend</span> <span class="p">,</span> <span class="n">QwtPlot</span><span class="o">::</span><span class="n">BottomLegend</span><span class="p">);</span> <span class="c1">// plot takes ownership</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Auch hier wird oben wieder der Header für die Klasse <code>QwtLegend</code> eingebunden.</p>
</div>
<div class="paragraph">
<p>Die Legende bekommt hier noch einen veränderten Font. Das weitere Anpassen der Legende wird in <a href="#sec:legend">Kapitel 7</a> beschrieben.</p>
</div>
<div class="paragraph">
<p>Die Legende kann links, rechts, oberhalb oder unterhalb der Zeichenfläche liegen, oder in der Zeichenfläche selbst. Die Platzierung wird beim Aufruf von <code>insertLegend()</code> festlegegt.</p>
</div>
<div class="paragraph">
<p>Das Plot nimmt beim Aufruf von <code>insertLegend()</code> wiederum Besitz vom Legendenobjekt und kümmert sich um das Aufräumen des Speichers.</p>
</div>
</div>
<div class="sect3">
<h4 id="_diagrammtitel_hinzufügen">2.2.3. Diagrammtitel hinzufügen</h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="c1">// Titel hinzufügen</span>
<span class="n">QwtText</span> <span class="nf">text</span><span class="p">(</span><span class="s">"Gamma-Spektrum"</span><span class="p">);</span>
<span class="n">QFont</span> <span class="n">titleFont</span><span class="p">;</span>
<span class="n">titleFont</span><span class="p">.</span><span class="n">setBold</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
<span class="n">titleFont</span><span class="p">.</span><span class="n">setPointSize</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
<span class="n">text</span><span class="p">.</span><span class="n">setFont</span><span class="p">(</span><span class="n">titleFont</span><span class="p">);</span>
<span class="n">plot</span><span class="p">.</span><span class="n">setTitle</span><span class="p">(</span><span class="n">text</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Die Klasse <code>QwtText</code> (Header <code>QwtText</code> bzw. <code>qwt_text.h</code>) kapselt einen QString und ergänzt Funktionalität zum Rendern von mathematischen Symbolen mittels MathML (siehe <a href="#sec:mathML">Kapitel 10.1</a>).</p>
</div>
</div>
<div class="sect3">
<h4 id="_diagrammraster_hinzufügen">2.2.4. Diagrammraster hinzufügen</h4>
<div class="paragraph">
<p>Gitterlinien werden durch das Zeichenobjekt <code>QwtPlotGrid</code> gezeichnet (Header <code>QwtPlotGrid</code> bzw. <code>qwt_plot_grid.h</code>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="c1">// Haupt- und Nebengitter anzeigen</span>
<span class="n">QwtPlotGrid</span> <span class="o">*</span><span class="n">grid</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">QwtPlotGrid</span><span class="p">();</span>
<span class="n">QPen</span> <span class="nf">gridPen</span><span class="p">(</span><span class="n">Qt</span><span class="o">::</span><span class="n">gray</span><span class="p">);</span>
<span class="n">gridPen</span><span class="p">.</span><span class="n">setStyle</span><span class="p">(</span><span class="n">Qt</span><span class="o">::</span><span class="n">DashLine</span><span class="p">);</span>
<span class="n">grid</span><span class="o">-&gt;</span><span class="n">setMajorPen</span><span class="p">(</span><span class="n">gridPen</span><span class="p">);</span>
<span class="c1">// Minor grid</span>
<span class="n">grid</span><span class="o">-&gt;</span><span class="n">enableYMin</span><span class="p">(</span> <span class="nb">true</span> <span class="p">);</span>
<span class="n">gridPen</span><span class="p">.</span><span class="n">setColor</span><span class="p">(</span><span class="n">Qt</span><span class="o">::</span><span class="n">lightGray</span><span class="p">);</span>
<span class="n">gridPen</span><span class="p">.</span><span class="n">setStyle</span><span class="p">(</span><span class="n">Qt</span><span class="o">::</span><span class="n">DotLine</span><span class="p">);</span>
<span class="n">grid</span><span class="o">-&gt;</span><span class="n">setMinorPen</span><span class="p">(</span><span class="n">gridPen</span><span class="p">);</span>
<span class="n">grid</span><span class="o">-&gt;</span><span class="n">attach</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">plot</span> <span class="p">);</span> <span class="c1">// plot takes ownership</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Das Raster selbst kann hinsichtlich der Stifts (QPen) für das Haupt- und Nebengitter angepasst werden. Die Funktion <code>enableYMin()</code> schaltet das Nebengitter für die Y-Achse ein.
Wie auch bei den Plotkurven übergibt <code>attach()</code> das <code>QwtPlotGrid</code> Objekt an das <code>QwtPlot</code>, welches sich dann um die Speicherverwaltung kümmert.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Ein Raster wird standardmäßig an eine x- und y-Achse gebunden, wobei man aber auch die Gitterlinien für eine der Achsen ausblenden kann. Wenn man z.B. ein Diagramm mit 2 y-Achsen hat und für jede ein Gitterraster anzeigen möchte (auch wenn das meistens verwirrend aussieht), dann braucht man zwei <code>QwtPlotGrid</code>-Objekte.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Inzwischen sieht das Diagramm schon ganz ansehnlich aus.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/Tutorial1_c.png" alt="Tutorial1 c">
</div>
<div class="title">Abbildung 5. Diagramm mit Linie, Legende, Titel und Gitterlinien</div>
</div>
</div>
<div class="sect3">
<h4 id="_achsenkonfiguration">2.2.5. Achsenkonfiguration</h4>
<div class="paragraph">
<p>Das <code>QwtPlot</code> hat 4 Achsen eingebaut, genannt:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>QwtPlot::yLeft</code> und <code>QwtPlot::yRight</code></p>
</li>
<li>
<p><code>QwtPlot::xBottom</code> und <code>QwtPlot::xTop</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Standardmäßig sind die Achsen <code>xBottom</code> und <code>yLeft</code> sichtbar, wie im bisher verwendeten Plot.</p>
</div>
<div class="paragraph">
<p>Jedes Zeichenelement im Plot (Kurven, Marker, &#8230;&#8203;) wird einer oder mehrerer Achsen zugeordnet. In unserem Einführungsbeispiel verwendet die <code>QwtPlotCurve</code> standardmäßig die Achsen <code>xBottom</code> und <code>yLeft</code>.</p>
</div>
<div class="paragraph">
<p>Die Achsen können wie folgt konfiguriert werden.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="c1">// Achsen formatieren</span>
<span class="n">QFont</span> <span class="n">axisFont</span><span class="p">;</span>
<span class="n">axisFont</span><span class="p">.</span><span class="n">setPointSize</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>
<span class="n">axisFont</span><span class="p">.</span><span class="n">setBold</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
<span class="n">QFont</span> <span class="n">axisLabelFont</span><span class="p">;</span>
<span class="n">axisLabelFont</span><span class="p">.</span><span class="n">setPointSize</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>
<span class="c1">// X-Achse</span>
<span class="n">QwtText</span> <span class="nf">axisTitle</span><span class="p">(</span><span class="s">"Kanal"</span><span class="p">);</span>
<span class="n">axisTitle</span><span class="p">.</span><span class="n">setFont</span><span class="p">(</span><span class="n">axisFont</span><span class="p">);</span>
<span class="c1">// Titel Text und Font setzen</span>
<span class="n">plot</span><span class="p">.</span><span class="n">setAxisTitle</span><span class="p">(</span><span class="n">QwtPlot</span><span class="o">::</span><span class="n">xBottom</span><span class="p">,</span> <span class="n">axisTitle</span><span class="p">);</span>
<span class="c1">// Font für Achsenzahlen setzen</span>
<span class="n">plot</span><span class="p">.</span><span class="n">setAxisFont</span><span class="p">(</span><span class="n">QwtPlot</span><span class="o">::</span><span class="n">xBottom</span><span class="p">,</span> <span class="n">axisLabelFont</span><span class="p">);</span>
<span class="c1">// Y-Achse</span>
<span class="n">axisTitle</span><span class="p">.</span><span class="n">setText</span><span class="p">(</span><span class="s">"Ereignisse"</span><span class="p">);</span>
<span class="n">plot</span><span class="p">.</span><span class="n">setAxisTitle</span><span class="p">(</span><span class="n">QwtPlot</span><span class="o">::</span><span class="n">yLeft</span><span class="p">,</span> <span class="n">axisTitle</span><span class="p">);</span>
<span class="n">plot</span><span class="p">.</span><span class="n">setAxisFont</span><span class="p">(</span><span class="n">QwtPlot</span><span class="o">::</span><span class="n">yLeft</span><span class="p">,</span> <span class="n">axisLabelFont</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Der Titel jeder Achse wird wiederum über ein <code>QwtText</code>-Objekt (enthält Text und Font) gesetzt.
Der Font für die Zahlen an den Achsen selbst wird über <code>setAxisFont()</code> geändert.</p>
</div>
<div class="paragraph">
<p>Die Achsen selbst lassen sich vielfältig anpassen, siehe <a href="#sec:axes">Kapitel 9</a>.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/Tutorial1_d.png" alt="Tutorial1 d">
</div>
<div class="title">Abbildung 6. Vollständig formatiertes Diagramm</div>
</div>
<div class="paragraph">
<p>Die Achsen passen sich standardmäßig automatisch an den Wertebereich der angezeigten Kurven an. Das kann man natürlich auch ändern, siehe <a href="#sec:axes">Kapitel 9</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_logarithmische_achsen">2.2.6. Logarithmische Achsen</h4>
<div class="paragraph">
<p>Das <code>QwtPlot</code> kann auch logarithmische Achsen verwenden. Dazu muss man eine anderen Skalenberechnungsklasse einbinden, die <code>QwtLogScaleEngine</code> (Header <code>QwtLogScaleEngine</code> bzw. <code>qwt_scale_engine.h</code>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="c1">// Logarithmische Y-Achse</span>
<span class="n">QwtLogScaleEngine</span> <span class="o">*</span> <span class="n">logScale</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">QwtLogScaleEngine</span><span class="p">();</span>
<span class="n">plot</span><span class="p">.</span><span class="n">setAxisScaleEngine</span><span class="p">(</span><span class="n">QwtPlot</span><span class="o">::</span><span class="n">yLeft</span><span class="p">,</span> <span class="n">logScale</span><span class="p">);</span> <span class="c1">// plot takes ownership</span>
<span class="c1">// manuelle Achsenlimits festlegen, da autoscale bei log-Achsen nicht sinnvoll funktioniert</span>
<span class="n">plot</span><span class="p">.</span><span class="n">setAxisScale</span><span class="p">(</span><span class="n">QwtPlot</span><span class="o">::</span><span class="n">yLeft</span><span class="p">,</span> <span class="mf">1e-3</span><span class="p">,</span><span class="mi">1000</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Beim Aufruf von <code>setAxisScaleEngine()</code> nimmt das Plot wiederum das Objekt in Besitz und kümmert sich dann um das Speicheraufräumen.</p>
</div>
<div class="paragraph">
<p><a href="#sec:axes">Kapitel 9</a> beschreibt die Details der <em>ScaleEngine</em> und gibt weitere Beispiele.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/Tutorial1_e.png" alt="Tutorial1 e">
</div>
<div class="title">Abbildung 7. Diagramm mit logarithmischer Y-Achse</div>
</div>
</div>
<div class="sect3">
<h4 id="_markierungslinien">2.2.7. Markierungslinien</h4>
<div class="paragraph">
<p>Ein weiteres Zeichenelement, das man hin und wieder braucht, sind horizontale oder vertikale Markierungslinien. Beispielhaft fügen wir eine solche Linie mal dem Plot hinzu (Header <code>QwtPlotMarker</code> bzw. <code>qwt_plot_marker.h</code>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="c1">// Vertikale, gestrichelte Plot-Markierung einfügen</span>
<span class="n">QwtPlotMarker</span> <span class="o">*</span> <span class="n">marker</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">QwtPlotMarker</span><span class="p">(</span><span class="s">"207,50 keV"</span><span class="p">);</span>
<span class="n">marker</span><span class="o">-&gt;</span><span class="n">setLabelOrientation</span><span class="p">(</span><span class="n">Qt</span><span class="o">::</span><span class="n">Vertical</span><span class="p">);</span> <span class="c1">// Vertikale Linie</span>
<span class="n">marker</span><span class="o">-&gt;</span><span class="n">setLabelAlignment</span><span class="p">(</span><span class="n">Qt</span><span class="o">::</span><span class="n">AlignRight</span> <span class="o">|</span> <span class="n">Qt</span><span class="o">::</span><span class="n">AlignBottom</span><span class="p">);</span> <span class="c1">// Label unten und rechts von der Linie</span>
<span class="n">marker</span><span class="o">-&gt;</span><span class="n">setValue</span><span class="p">(</span><span class="mi">36</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// bei vertikalen Linien muss die x-Koordinate festgelegt werden</span>
<span class="n">QPen</span> <span class="nf">markerPen</span><span class="p">(</span><span class="n">QColor</span><span class="p">(</span><span class="mi">40</span><span class="p">,</span><span class="mi">60</span><span class="p">,</span><span class="mi">255</span><span class="p">));</span>
<span class="n">markerPen</span><span class="p">.</span><span class="n">setStyle</span><span class="p">(</span><span class="n">Qt</span><span class="o">::</span><span class="n">SolidLine</span><span class="p">);</span>
<span class="n">marker</span><span class="o">-&gt;</span><span class="n">setLinePen</span><span class="p">(</span><span class="n">markerPen</span><span class="p">);</span>
<span class="n">marker</span><span class="o">-&gt;</span><span class="n">setLineStyle</span><span class="p">(</span><span class="n">QwtPlotMarker</span><span class="o">::</span><span class="n">VLine</span><span class="p">);</span>
<span class="n">marker</span><span class="o">-&gt;</span><span class="n">setLabel</span><span class="p">(</span><span class="n">QwtText</span><span class="p">(</span><span class="s">"207,50 keV"</span><span class="p">));</span>
<span class="n">marker</span><span class="o">-&gt;</span><span class="n">attach</span><span class="p">(</span><span class="o">&amp;</span><span class="n">plot</span><span class="p">);</span> <span class="c1">// plot takes ownership</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Auch bei den Markern gibt es vielfältige Einstellungsmöglichkeiten, siehe <a href="#sec:marker">Kapitel 8</a>.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/Tutorial1_f.png" alt="Tutorial1 f">
</div>
<div class="title">Abbildung 8. Diagramm mit logarithmischer Y-Achse und vertikaler Peak-Markierung</div>
</div>
<div class="paragraph">
<p>Nun ist das Diagramm selbst fertig und wir widmen uns der Nutzerinteraktion.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_interaktion_mit_dem_diagramm">2.3. Interaktion mit dem Diagramm</h3>
<div class="paragraph">
<p>Das <code>QwtPlot</code> bietet die üblichen Interaktionsmöglichkeiten für den Anwender, wie z.B. Herein- und Herauszoonmen, oder Verschieben des Plotausschnitts.</p>
</div>
<div class="sect3">
<h4 id="_zoomfunktionalität_mit_qwtplotzoomer">2.3.1. Zoomfunktionalität mit QwtPlotZoomer</h4>
<div class="paragraph">
<p>Die Zoom-Funktionalität wird über die Klasse <code>QwtPlotZoomer</code> hinzugefügt (Header <code>QwtPlotZoomer</code> bzw. <code>qwt_plot_zoomer.h</code>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="c1">// Zoomer hinzufügen</span>
<span class="c1">// Achtung: NICHT QwtPlot selbst als 3 Argument übergeben, sonder das canvas()</span>
<span class="n">QwtPlotZoomer</span> <span class="o">*</span> <span class="n">zoomer</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">QwtPlotZoomer</span><span class="p">(</span><span class="n">QwtPlot</span><span class="o">::</span><span class="n">xBottom</span><span class="p">,</span> <span class="n">QwtPlot</span><span class="o">::</span><span class="n">yLeft</span><span class="p">,</span> <span class="n">plot</span><span class="p">.</span><span class="n">canvas</span><span class="p">());</span>  <span class="c1">// plot takes ownership</span>
<span class="n">zoomer</span><span class="o">-&gt;</span><span class="n">setTrackerMode</span><span class="p">(</span> <span class="n">QwtPlotPicker</span><span class="o">::</span><span class="n">AlwaysOn</span> <span class="p">);</span> <span class="c1">// Kurvenvwerte unterm Cursor anzeigen</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Wenn man mit der Maus über das Diagramm fährt, sieht man bereits einen veränderten Cursor und dank des Aufrufs <code>setTrackerMode(QwtPlotPicker::AlwaysOn)</code> sieht man nun auch die x- und y-Werte (des Achsen <code>xBottom</code> und <code>yLeft</code>) unter dem Cursor.</p>
</div>
<div class="paragraph">
<p>Hineinzoomen kann man, indem man die Linke Maustaste gedrückt hält, und ein Zoom-Rechteck aufzieht. Das kann man auch mehrmals hintereinander machen. Das <code>QwtPlot</code> merkt sich intern diese Zoomstufen. Herauszoomen kann durch Klick auf die rechte Maustaste, wobei immer eine Zoomstufe hinausgezoomt wird.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Die äußerste Zoomstufe wird im Konstruktor der <code>QwtPlotZoomer</code>-Klasse basierend auf den aktuellen Wertebereichen der <em>bereits hinzugefügten Kurven</em> bestimmt. Sollte man die Werte der Kurven nachträglich ändern, oder den Zoomer hinzufügen, <em>bevor</em> man dem Plot Kurven gegeben hat, so kann man die Funktion <code>QwtPlotZoomer::setZoomBase()</code> aufrufen. Details dazu gibt es im <a href="#sec:zoomer">Kapitel 11</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Im Quelltext gibt es noch eine Besonderheit. Während die bisherigen Plotelemente immer mit Memberfunktionen der <code>QwtPlot</code>-Klasse hinzugefügt wurde, bzw. mittels <code>attach()</code>, wird das Zoomerobjekt analog zu Qt Klassen als Kindobjekt der Zeichenfläche gegeben und registriert sich darüber als interaktives Element bei Plot.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Achtung"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Es ist wichtig darauf zu achten, dass man beim Konstruktor der Klasse <code>QwtPlotZoomer</code> als 3. Argument das Canvas-Objekt des Plots übergibt. Dieses erhält man mit der Funktion <code>QwtPlot::canvas()</code>. Wenn man hier stattdessen das Plot selbst übergibt, führt dies zu einem Speicherzugriffsfehler.</p>
</div>
<div class="paragraph">
<p>Im Konstruktor der <code>QwtPlotZoomer</code> Klasse registriert sich das Objekt als Kind des Canvas-Widgets, wodurch das QObject-System sich um die Speicherverwaltung kümmert. Man muss also das <code>QwtPlotZoomer</code> Objekt nicht freigeben.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Damit der Zoomer weiß, welche Achsen beim Zoom manipuliert werden sollen, muss man die x- und y-Achse im Konstruktor angeben. Möchte man z.B. beide y-Achsen gleichzeitig zoomen, braucht man zwei <code>QwtPlotZoomer</code>-Objekte.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/Tutorial1_g.png" alt="Tutorial1 g">
</div>
<div class="title">Abbildung 9. Diagramm mit aufgezogenem Zoom-Rechteck</div>
</div>
</div>
<div class="sect3">
<h4 id="_plotausschnitt_verschieben_mit_qwtplotpanner">2.3.2. Plotausschnitt verschieben mit QwtPlotPanner</h4>
<div class="paragraph">
<p>Wenn man Ausschnitt eines hineingezoomten Plots interaktiv verschieben möchte, kann man den <code>QwtPlotPanner</code> hinzufügen  (Header <code>QwtPlotZoomer</code> bzw. <code>qwt_plot_zoomer.h</code>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="c1">// Panner hinzufügen, wie auch beim PlotZoomer muss das Canvas-Objekt als Argument übergeben werden</span>
<span class="n">QwtPlotPanner</span> <span class="o">*</span> <span class="n">panner</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">QwtPlotPanner</span><span class="p">(</span><span class="n">plot</span><span class="p">.</span><span class="n">canvas</span><span class="p">());</span>  <span class="c1">// plot takes ownership</span>
<span class="n">panner</span><span class="o">-&gt;</span><span class="n">setMouseButton</span><span class="p">(</span><span class="n">Qt</span><span class="o">::</span><span class="n">MidButton</span><span class="p">);</span> <span class="c1">// Mittlere Maustaste verschiebt</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Wie beim <code>QwtPlotZoomer</code> wird das Objekt als Kindobjekt des Canvas-Widgets hinzugefügt.  Üblich ist das Verschieben von Bildschirminhalten mit gedrückter mittlerer Maustaste, also legt man das mit <code>setMouseButton()</code> fest.</p>
</div>
<div class="paragraph">
<p>Damit ist das Einstiegstutorial beendet. Mit dem <code>QwtPlot</code> kann man bereits mit wenigen Handgriffen ein voll funktionsfähiges und interaktives Diagramm erstellen.  In diesem Tutorial war das <code>QwtPlot</code> gleichzeitig das Anwendungs-Widget. Wenn man das <code>QwtPlot</code> aber in bestehende Designer-Formularklassen einfügen will, gibt es verschiedene Techniken:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>die Verwendung von Platzhalter-Widgets</p>
</li>
<li>
<p>die Einbindung von Qt Designer Plugins für die Qwt Bibliothek</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Diese Methoden sind in <a href="#sec:usingQwtPlot">Kapitel 15.5</a> beschrieben.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sec:qwtWigets">3. QWT Widgets und Eingabekomponenten</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Neben dem <code>QwtPlot</code> gibt es in der Qwt-Bibliothek noch eine Reihe anderer Eingabekomponenten, die in diesem Kapitel kurz vorgestellt werden.
Viele dieser Komponenten sind klassischen Anzeigen und Einstellrädern in wissenschafltlich/technischen Geräten nachempfunden.</p>
</div>
<div class="paragraph">
<p>Für die Anzeige der Skalen verwenden die nachfolgend vorgestellten Komponenten intern zur Darstellung der Skalen die in <a href="#sec::axisScales">[sec::axisScales]</a> näher beschriebenen Skalenberechnungs- und -zeichenklassen.</p>
</div>
<div class="sect2">
<h3 id="_schieberegler_slider">3.1. Schieberegler (Slider)</h3>
<div class="paragraph">
<p>Die Klasse <code>QwtSlider</code> erlaubt die Darstellung verschiedener Schieberegler, welche mit der Maus oder Tastatur (Cursortasten) bedient werden können. Im Gegensatz zur  <code>QSlider</code> Klasse können die Skalen viel flexibler und auch nichtlinear definiert werden.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/controlsSlider.png" alt="controlsSlider">
</div>
<div class="title">Abbildung 10. Beispiele für <code>QwtSlider</code></div>
</div>
<div class="paragraph">
<p>Das Beispiel im Screenshot oben ist in der Qwt-Bibliothek als Beispiel <code>controls</code> enthalten.</p>
</div>
</div>
<div class="sect2">
<h3 id="_drehrädereinstellräder_und">3.2. Drehräder/Einstellräder und</h3>
<div class="paragraph">
<p>Die Klasse <code>QwtWheel</code> zeigt ein horizontales oder vertikales Einstellrad. Die Klasse <code>QwtThermo</code> zeigt eine Balkenanzeige, allerdings mit einer flexibel hinterlegbaren Farbtabelle. Dies erlaubt z.B. Farbverläufe oder Farbsprünge bei Übersteigen bestimmter Schwellwerte.</p>
</div>
<div class="paragraph">
<p>Qt selbst bietet für eine Balkenanzeige die Klasse <code>QProgressBar</code> an, welches sich aber im Erscheinungsbild an den jeweiligen Plattformstil für Fortschrittsbalken orientiert und auch keine Skalen bietet.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/controlsWheelThermo.png" alt="controlsWheelThermo">
</div>
<div class="title">Abbildung 11. Beispiele für <code>QwtWheel</code> und  <code>QwtThermo</code></div>
</div>
<div class="paragraph">
<p>Das Beispiel im Screenshot oben ist in der Qwt-Bibliothek als Beispiel <code>controls</code> enthalten.</p>
</div>
</div>
<div class="sect2">
<h3 id="_drehknöpfe">3.3. Drehknöpfe</h3>
<div class="paragraph">
<p>Die Klasse <code>QwtKnob</code> zeigt einen Drehknopf, mit ebenso flexibel konfigurierbaren Skaleneinheiten. Die Qt-Klasse <code>QDial</code> bietet ebenso ein Einstellrad, jedoch wiederum viel simpler und mit weniger Einstellungsmöglichkeiten hinsichtlich der Skalendarstellung und -skalierung.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/controlsKnob.png" alt="controlsKnob">
</div>
<div class="title">Abbildung 12. Beispiele für <code>QwtKnob</code></div>
</div>
<div class="paragraph">
<p>Das Beispiel im Screenshot oben ist in der Qwt-Bibliothek als Beispiel <code>controls</code> enthalten.</p>
</div>
</div>
<div class="sect2">
<h3 id="_analoge_zeiger_anzeigen">3.4. Analoge Zeiger-Anzeigen</h3>
<div class="paragraph">
<p>Die Klasse <code>QwtDial</code> zeichnet analoge Zeigeranzeigen, die aber auch mit der Maus/Tastatur verändert werden können (wenn man das aktiviert). Die Anzeigen lassen sich farblich sehr individuell konfigurieren.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/controlsDials.png" alt="controlsDials">
</div>
<div class="title">Abbildung 13. Beispiele für <code>QwtDial</code></div>
</div>
<div class="paragraph">
<p>Das Beispiel im Screenshot oben ist in der Qwt-Bibliothek als Beispiel <code>controls</code> enthalten.</p>
</div>
<div class="paragraph">
<p>Bemerkenswert ist vielleicht noch, dass die Anzeigenadel selbst unabhängig von der Klasse <code>QwtDial</code> durch eine separate Klasse implementiert wird. Als Standard wird hier <code>QwtDialSimpleNeedle</code> verwendet, wie im Screenshot oben. Man kann sich hier aber auch austoben, und selber beliebige Anzeigenadeln entwerfen und integrieren.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sec:qwtPlot">4. Allgemeine Grundlagen des QwtPlot</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Das <code>QwtPlot</code> ist sicher die nützlichste und am weitesten bekannte Komponente der Qwt Bibliothek. Im Gegensatz zu vielen anderen Qt-Diagrammkomponenten, kann man mit dem <code>QwtPlot</code> wirklich sehr flexibel (und effizient) alle möglichen Diagrammtypen erstellen und anzeigen.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/2D_time_plot_2axes.png" alt="2D time plot 2axes">
</div>
<div class="title">Abbildung 14. Beispiel für ein typisches <code>QwtPlot</code> mit zwei y-Achsen und innenliegender Legende.</div>
</div>
<div class="paragraph">
<p>Bevor ab <a href="#sec:linecurves">Kapitel 5</a> die einzelnen Diagrammtypen vorgestellt werden, geht es in diesem Kapitel um die wesentlichen Grundlagen.</p>
</div>
<div class="sect2">
<h3 id="_aufbau_und_elemente_der_diagrammkomponente">4.1. Aufbau und Elemente der Diagrammkomponente</h3>
<div class="paragraph">
<p>Das <code>QwtPlot</code> besteht aus einem Titel, umliegenden Achsen, Legenden und der eigentlichen Zeichenfläche. Alle diese Elemente können konfiguriert und sichtbar/unsichtbar geschaltet werden.</p>
</div>
<div class="sect3">
<h4 id="_achsen_und_koordinatensystem">4.1.1. Achsen und Koordinatensystem</h4>
<div class="paragraph">
<p>Das Diagramm selbst ist ein kartesisches Diagramm mit maximal 4 Achsen, identifiziert über folgende Enumerationswerte:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>QwtPlot::xBottom</code></p>
</li>
<li>
<p><code>QwtPlot::xTop</code></p>
</li>
<li>
<p><code>QwtPlot::yLeft</code></p>
</li>
<li>
<p><code>QwtPlot::yRight</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Diese Achsen haben primär die Aufgabe, zwischen den <em>Plotkoordinaten</em> (x,y) und <em>Bildschirmkoordinaten</em> umzurechnen. Jede der vier Achsen kann individuell konfiguriert werden, welches sich auf die min/max-Werte und die Achsenskalierung auswirkt.</p>
</div>
</div>
<div class="sect3">
<h4 id="_diagrammelemente">4.1.2. Diagrammelemente</h4>
<div class="paragraph">
<p>Innerhalb der Zeichenfläche kann man nun die verschiedensten Elemente zeichen, bspw.:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Linien,</p>
</li>
<li>
<p>Balken,</p>
</li>
<li>
<p>Symbole,</p>
</li>
<li>
<p>Markierungen,</p>
</li>
<li>
<p>Legendeneinträge,</p>
</li>
<li>
<p>Gitterraster,</p>
</li>
<li>
<p>&#8230;&#8203; und viele weitere</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Alle diese Objekte sind von der Basisklasse  <code>QwtPlotItem</code> abgeleitet und teilen sich dadurch gewisse gemeinsame Eigenschaften.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/ClassDiagrams/QwtPlotItem-class-hierarchy.png" alt="QwtPlotItem class hierarchy">
</div>
<div class="title">Abbildung 15. Von QwtPlotItem abgeleitete Klassen der verschiedenen Zeichenelemente</div>
</div>
<div class="paragraph">
<p>In einem Diagramm kann man alle möglichen Elemente kombinieren, also auch Liniendiagramme mit Balken, Symbolen und Markierungen darstellen.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Die Zeichenreihenfolge, also welches Zeichenelement ein anderes überdeckt, bestimmt das z-Attribut. Dies wird über die Funktionen <code>QwtPlotItem::setZ(...)</code> und <code>QwtPlotItem::z()</code>  kontrolliert.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Die Positionierung der Diagrammelemente erfolgt über die Plotkoordinaten. Die Umrechung in Bildschirmkoordinaten bzw. die konkrete Position auf der Zeichenfläche wird mittels der jeweils zugeordneten x- und y-Achse gemacht.  Da es nun jeweils zwei x- und y-Achsen gibt, braucht man also bei Anzeige eines Diagrammelements an einem bestimmtenx,y-Datenpunkt zwingend eine Zuordnung zu <em>einer</em> x- und <em>einer</em> y-Achse. Diese Eigenschaft setzt man den einzelnen Zeichenelementen, wobei standardmäßig <code>xBottom</code> und <code>yLeft</code> ausgewählt sind.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Die Zuordnung eines Zeichenelements zu einer Achse erfolgt mit den Memberfunktionen <code>QwtPlotItem::setAxes(...)</code>, <code>QwtPlotItem::setXAxis(...)</code>, <code>QwtPlotItem::setYAxis(...)</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Alle Zeichenelemente werden <em>grundsätzlich</em> auf dem Heap mit <code>new</code> erstellt und mittels der Memberfunktion <code>QwtPlotItem::attach(...)</code> dem eigentlichen <code>QwtPlot</code> hinzugefügt.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Beim Aufruf von <code>attach()</code> wird das Zeichenelement in die Obhut des <code>QwtPlot</code> übergeben, welches sich dann um das Aufräumen des Speichers kümmert. Möchte man das Zeichenelement wieder zurückerhalten, ruft man die Memberfunktion <code>detach()</code> auf. Damit übernimmt man dann selbst wieder die Verantwortung für das Speicherbereinigen.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Das <code>QwtPlotItem</code> deklariert und implementiert auch die virtuellen Funktionen für das Zeichnen sowie Berechnen wichtiger Layoutdaten. Dies wird aber später in den fortgeschrittenen Kapiteln noch genauer erklärt. Nun aber zu den individuellen Zeichenelementen und daraus erstellten Diagrammtypen.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="sec:seriesData">4.2. Datenhaltung im QwtPlot / QwtSeriesStore</h3>
<div class="paragraph">
<p>Für die Darstellen von Plotkurven/Balken oder anderen Zeichenelementen werden die Daten für mehrere Datenpunkte (<em>samples</em>) benötigt. Je nach Anforderung des Zeichenelements gibt es verschiedene Typen von <em>samples</em>. So brauchen Linienkurven normalerweise x,y-Wertepaare, aber Intervallkurven jeweils x,y1,y2-Tuples.</p>
</div>
<div class="paragraph">
<p>Alle Zeichenelemente, welche solche Reihendaten verwenden, sind Kinder der Klasse <code>QwtPlotSeriesItem</code>.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/ClassDiagrams/QwtPlotSeriesItem-class-hierarchy.png" alt="QwtPlotSeriesItem class hierarchy">
</div>
<div class="title">Abbildung 16. Klasse QwtPlotSeriesItem, Elternklassen und abgeleitete Klassen</div>
</div>
<div class="paragraph">
<p>Die Datenhaltung erfolgt in der Template-Klasse <code>QwtSeriesStore</code>, welche die abstrakte Schnittstellenklasse <code>QwtAbstractSeriesStore</code> implementiert.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Die hier in Qwt verwendet Kombination von Template-Klassen für die Datenhaltung individueller Typen und gleichzeitig Implementierung gemeinschaftlicher Klassenfunktionalität via virtueller Funktionen, zeigt mal wieder schön die Flexibilität von C++.</p>
</div>
<div class="paragraph">
<p>Allerdings macht es das Verständnis der Interaktion von Datenhalteklassen und die Zeichenelement-Klassen auf den ersten Blick etwas komplizierter. Glücklicherweise muss man das für die Verwendung des <code>QwtPlot</code> gar nicht so genau wissen.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Je nach Anforderung des individuellen Zeichenelements/Diagrammtyps werden unterschiedliche Daten benötigt:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>QPointF</code> für reguläre Reihen-/Seriendiagramme (Linien)</p>
</li>
<li>
<p><code>QwtIntervalSample</code> für Histogramme und Intervallkurven</p>
</li>
<li>
<p><code>QwtPoint3D</code> für Spektrogramplots (Farbverlaufsdiagramme)</p>
</li>
<li>
<p><code>QwtOHLCSample</code> für Trading-Curves (OHLC - <em>Open-High-Low-Close</em>)</p>
</li>
<li>
<p><code>QwtVectorFieldSample</code> für Vektorfelder</p>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/ClassDiagrams/QwtAbstractSeriesStore-class-hierarchy.png" alt="QwtAbstractSeriesStore class hierarchy">
</div>
<div class="title">Abbildung 17. Abstrakte Klasse QwtAbstractSeriesStore und abgeleitete Klassen</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Die meisten Diagrammelemente/Diagrammklassen haben geeignete Schnittstellenfunktionen für die Übergabe der Plotdaten ans Diagramm. Daher muss man selten direkt mit <code>QwtSeriesStore</code> arbeiten. In den nachfolgenden Kapiteln wird dies jeweils individuell erklärt.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_automatisches_zeichnen_oder_zeichnen_bei_bedarf">4.3. Automatisches Zeichnen oder Zeichnen bei Bedarf</h3>
<div class="paragraph">
<p>Das Zeichnen eines komplexen Plots kann durchaus länger dauern, daher ist es bei Anpassungen des Plots häufig nicht notwendig, bei jeweil individuellen Änderung alles neu zu zeichnen. Stattdessen reicht es aus, nach Aktualisierung aller Daten und Anpassung anderer Einstellungen (Achsen, Legenden,&#8230;&#8203;) das Plot neu zu zeichnen.</p>
</div>
<div class="paragraph">
<p><em>Zeichnen</em> bedeutet hier eigentlich zwei unterschiedliche Arbeitsschritte:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Neuberechnung des Layouts, d.h. Größen für Achsen, Legenden, Titel, Label, Zeichenfläche etc.. Dabei erfolgt auch eine Neuberechnung der Achsenskalierung und damit der Zuordnung von Plot-Koordinaten zu Pixelgrößen</p>
</li>
<li>
<p>Das eigentliche Zeichnen (<em>render</em>) des Plots</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Schritt 1 wird ausgeführt, wenn man <code>QwtPlot::replot()</code> aufruft. Standardmäßig wird das immer gemacht, wenn man irgendeine Ploteigenschaft ändert. Diesen automatischen Aufruf kann man mit <code>QwtPlot::setAutoReplot()</code> an/ausschalten.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="c1">// Automatisches Neu-Layouten ausschalten</span>
<span class="n">plot</span><span class="o">-&gt;</span><span class="n">setAutoReplot</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Der Aufruf von <code>replot()</code> direkt oder indirekt bei Änderungen, wenn <em>autoReplot</em> angeschaltet ist, führt nicht zu dem teils zeitaufwändigen Rendern des Plots. Je nach Komplexität des Plots und Größe der Daten ist das sogar sehr schnell. Daher ist das Ausschalten des Auto-Plots selten aus Performancegründen notwendig.</p>
</div>
<div class="paragraph">
<p>Ein Ausschalten des <em>autoReplot</em> kann aber sinnvoll sein, wenn bei Anpassungen von individuellen Ploteigenschaften ein zwischenzeitlich inkonsistenter Zustand eintreten könnte, wo ein Neulayouten nur Quatsch erzeugen könnte oder sowas wie <em>Division durch Null</em> erzeugen könnte. Dann wartet man besser, bis alle Plot-/Kurveneigenschaften fertig aktualisiert wurden und ruft dann <code>replot()</code> auf.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Nach einem Aktualisieren des Layouts in <code>replot()</code> wird ein Zeichenupdate via Qt-Event-Queue angestoßen. Gezeichnet/gerendert wird dann <em>erst im nächsten Bildrefresh</em> und auch nur <em>ein Mal</em>. Somit kann man gerne 1000 Mal <code>replot()</code> aufrufen, und es wird doch nur einmal gerendert. Dies spart sehr viel Zeit.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sec:linecurves">5. Kurvendiagramme</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Die wohl häufiges Diagrammart werden wohl Kurvendiagramme sein. Kurvendiagramme bzw. Liniendiagramme sind parametrische Kurven, bei denen die einzelnen Punkte nacheinander gezeichnet werden, und im Fall von Liniendiagrammen durch Linien verbunden werden. Weder x- noch y-Werte müssen monoton steigen.</p>
</div>
<div class="paragraph">
<p>Das Zeichenelement <code>QwtPlotCurve</code> wird jedoch nicht nur für Liniendiagramme im klassischen Sinn benutzt, sondern auch für Stufen, Stäbchen, Punkt/Symbol-Diagramme und so weiter. Alle diese Varianten haben jedoch gemein, dass sie als Daten einen x- und einen y-Vector mit Daten in Plotkoordinaten erwarten.</p>
</div>
<div class="paragraph">
<p>Der individuelle Stil der Kurve wird mit der Funktion <code>QwtPlotCurve::setStyle()</code> festgelegt. Je nach Stil können/müssen weitere Parameter festgelegt werden. In den folgenden Abschnitten werden die möglichen Diagrammtypen für jeweils die gleichen x/y-Daten im Vergleich gezeigt.</p>
</div>
<table class="tableblock frame-all grid-all" style="width: 25%;">
<caption class="title">Tabelle 1. Testdaten für die nachfolgenden Diagramme</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">x</th>
<th class="tableblock halign-left valign-top">y</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">5</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">5</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">8</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">6</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">8</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">12</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">5</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">15</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">8</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">16</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">9</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">17</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">11</p></td>
</tr>
</tbody>
</table>
<div class="sect2">
<h3 id="_datenübergabe">5.1. Datenübergabe</h3>
<div class="paragraph">
<p>Wie in <a href="#sec:seriesData">Kapitel 4.2</a> erklärt, wird für die interne Datenhaltung in <code>QwtPlotCurve</code> die Klasse <code>QwtSeriesStore&lt;QPointF&gt;</code> verwendet.</p>
</div>
<div class="paragraph">
<p>Daten kann man nun auf mehrere Arten der Plot-Kurve übergeben:</p>
</div>
<div class="listingblock">
<div class="title">Verwendung zweier QVector&lt;double&gt; (oder analog QVector&lt;float&gt;)</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">QVector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">x</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">17</span><span class="p">};</span>
<span class="n">QVector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">y</span><span class="p">{</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span><span class="mi">11</span><span class="p">};</span>
<span class="n">curve</span><span class="o">-&gt;</span><span class="n">setSamples</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Verwendung eines QVector&lt;QPointF&gt;</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">QVector</span><span class="o">&lt;</span><span class="n">QPointF</span><span class="o">&gt;</span> <span class="n">samples</span><span class="p">{</span>
	<span class="n">QPointF</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span>
	<span class="n">QPointF</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span>
	<span class="n">QPointF</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">8</span><span class="p">)</span>
<span class="p">};</span>
<span class="n">curve</span><span class="o">-&gt;</span><span class="n">setSamples</span><span class="p">(</span><span class="n">samples</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Wenn die Daten in einem C-Array oder <code>std::vector</code> vorliegen, bietet sich <code>QwtPlotCurve::setSamples()</code> an.</p>
</div>
<div class="listingblock">
<div class="title">Übergabe der Daten direkt im Speicher</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">x</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">17</span><span class="p">};</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">y</span><span class="p">{</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span><span class="mi">11</span><span class="p">};</span>
<span class="k">const</span> <span class="kt">double</span> <span class="o">*</span> <span class="n">xdata</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="n">data</span><span class="p">();</span>
<span class="k">const</span> <span class="kt">double</span> <span class="o">*</span> <span class="n">ydata</span> <span class="o">=</span> <span class="n">y</span><span class="p">.</span><span class="n">data</span><span class="p">();</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>

<span class="n">curve</span><span class="o">-&gt;</span><span class="n">setSamples</span><span class="p">(</span><span class="n">xdata</span><span class="p">,</span> <span class="n">ydata</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Bei der Verwendung von <code>QwtPlotCurve::setSamples()</code> werden die Daten <em>immer</em> in den interne <code>QwtSeriesStore</code> der Plot-Kurve <em>kopiert</em>, auch wenn man hier direkt die Adresse des Speichers mit den Daten übergibt.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Bei sehr großen Datenmengen und begrenztem Hauptspeicher kann es sinnvoll sein, die Daten nicht in das Plot hineinzukopieren, sondern die Plotkurven direkt auf den Speicher zugreifen zu lassen. Dafür gibt es die Funktion <code>QwtPlotCurve::setRawSamples()</code>. Die Syntax ist wie beim vorherigen Beispiel:</p>
</div>
<div class="listingblock">
<div class="title">Direkte Verwendung der im Speicher befindlichen Daten durch as Plot</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">const</span> <span class="kt">double</span> <span class="o">*</span> <span class="n">xdata</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="n">data</span><span class="p">();</span> <span class="c1">// x ist ein std::vector</span>
<span class="k">const</span> <span class="kt">double</span> <span class="o">*</span> <span class="n">ydata</span> <span class="o">=</span> <span class="n">y</span><span class="p">.</span><span class="n">data</span><span class="p">();</span> <span class="c1">// y ist ein std::vector</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
<span class="n">curve</span><span class="o">-&gt;</span><span class="n">setRawSamples</span><span class="p">(</span><span class="n">xdata</span><span class="p">,</span> <span class="n">ydata</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Achtung"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Die Variablen und deren Speicherbereich, welche im Aufruf von <code>setRawSamples()</code> verwendet werden, müssen eine längere Lebensdauer haben, als das Plot bzw. die Plotkurve selbst.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Direkte Änderung der Daten im Speicher wird beim nächsten Rendern des Plots direkt sichtbar. Allerdings müssen das Plot und dessen  Zeichenelemente, die ein Interesse an den Wertebereichen der Plotkurven haben, manuell über eine Änderung der Daten information werden. Dazu einfach <code>QwtPlot::replot()</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_liniendiagramm">5.2. Liniendiagramm</h3>
<div class="paragraph">
<p>Konfiguration einer <code>QwtPlotCurve</code> als Linie:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">QwtPlotCurve</span> <span class="o">*</span><span class="n">curve</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">QwtPlotCurve</span><span class="p">();</span>
<span class="n">curve</span><span class="o">-&gt;</span><span class="n">setStyle</span><span class="p">(</span><span class="n">QwtPlotCurve</span><span class="o">::</span><span class="n">Lines</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/PlotCurves_StyleLines.png" alt="PlotCurves StyleLines">
</div>
<div class="title">Abbildung 18. Liniendiagramm</div>
</div>
</div>
<div class="sect2">
<h3 id="_stäbchen_sticks">5.3. Stäbchen (Sticks)</h3>
<div class="paragraph">
<p>Konfiguration einer <code>QwtPlotCurve</code> als vertikale Stäbchen:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">QwtPlotCurve</span> <span class="o">*</span><span class="n">curve</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">QwtPlotCurve</span><span class="p">();</span>
<span class="n">curve</span><span class="o">-&gt;</span><span class="n">setStyle</span><span class="p">(</span><span class="n">QwtPlotCurve</span><span class="o">::</span><span class="n">Lines</span><span class="p">);</span>
<span class="n">curve</span><span class="o">-&gt;</span><span class="n">setOrientation</span><span class="p">(</span><span class="n">Qt</span><span class="o">::</span><span class="n">Vertical</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/PlotCurves_StyleSticksVertical.png" alt="PlotCurves StyleSticksVertical">
</div>
<div class="title">Abbildung 19. Vertikale Stäbchen</div>
</div>
<div class="paragraph">
<p>Alternativ kann man die Stäbchen auch horizontal zeichnen. Dazu muss man zusätzlich die Ausrichtung mit <code>QwtPlotSeriesItem::setOrientation()</code> setzen:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">QwtPlotCurve</span> <span class="o">*</span><span class="n">curve</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">QwtPlotCurve</span><span class="p">();</span>
<span class="n">curve</span><span class="o">-&gt;</span><span class="n">setStyle</span><span class="p">(</span><span class="n">QwtPlotCurve</span><span class="o">::</span><span class="n">Lines</span><span class="p">);</span>
<span class="n">curve</span><span class="o">-&gt;</span><span class="n">setOrientation</span><span class="p">(</span><span class="n">Qt</span><span class="o">::</span><span class="n">Horizontal</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/PlotCurves_StyleSticksHorizontal.png" alt="PlotCurves StyleSticksHorizontal">
</div>
<div class="title">Abbildung 20. Horizontale Stäbchen</div>
</div>
</div>
<div class="sect2">
<h3 id="_stufendiagramme">5.4. Stufendiagramme</h3>
<div class="paragraph">
<p>Wenn die Daten nicht linear verbunden werden sollen, sondern eher Stufen darstellen, kann man den Linientyp <code>Steps</code> verwenden.
Das Zusatz-Attribut <code>QwtPlotCurve::Inverted</code> gibt dabei an, ob die Stufe am Ende des Intervals oder Anfang des Intervals sein soll. Kurvenattribute werden mit <code>QwtPlotCurve::setCurveAttribute()</code> gesetzt:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">QwtPlotCurve</span> <span class="o">*</span><span class="n">curve</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">QwtPlotCurve</span><span class="p">();</span>
<span class="n">curve</span><span class="o">-&gt;</span><span class="n">setStyle</span><span class="p">(</span><span class="n">QwtPlotCurve</span><span class="o">::</span><span class="n">Steps</span><span class="p">);</span>
<span class="n">curve</span><span class="o">-&gt;</span><span class="n">setCurveAttribute</span><span class="p">(</span><span class="n">QwtPlotCurve</span><span class="o">::</span><span class="n">Inverted</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/PlotCurves_StyleSteps.png" alt="PlotCurves StyleSteps">
</div>
<div class="title">Abbildung 21. Stufendiagramm (normal)</div>
</div>
<div class="paragraph">
<p>Betrachtet man die Eingangsdaten:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code>x   y
1   5
2   4
5   8
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>so fällt auf, dass im ersten Intervall, also zwischen x=1..2, der Wert y2=4 gezeichnet wird und an der Stelle x1=1 die Verbindungslinie zwischen y1=5 und y2=4 gezeichnet wird.</p>
</div>
<div class="paragraph">
<p>Will man direkt den ersten y-Wert im ersten Intervall zeichnen (das wäre eher die natürliche Erwartungshaltung), so muss man das Attribut <code>Inverted</code> setzen:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">QwtPlotCurve</span> <span class="o">*</span><span class="n">curve</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">QwtPlotCurve</span><span class="p">();</span>
<span class="n">curve</span><span class="o">-&gt;</span><span class="n">setStyle</span><span class="p">(</span><span class="n">QwtPlotCurve</span><span class="o">::</span><span class="n">Steps</span><span class="p">);</span>
<span class="n">curve</span><span class="o">-&gt;</span><span class="n">setCurveAttribute</span><span class="p">(</span><span class="n">QwtPlotCurve</span><span class="o">::</span><span class="n">Inverted</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/PlotCurves_StyleStepsInverted.png" alt="PlotCurves StyleStepsInverted">
</div>
<div class="title">Abbildung 22. Stufendiagramm (invertiert)</div>
</div>
</div>
<div class="sect2">
<h3 id="_punkte_dots">5.5. Punkte (Dots)</h3>
<div class="paragraph">
<p>Man kann an den jeweiligen x,y-Koordinaten auch einfach nur Punkte (auch nur einzelne Pixel) zeichnen. Das geht <em>sehr schnell</em> vergleichen mit dem Zeichnen von Symbolen (siehe <a href="#sec:plotSymbols">Kapitel 5.7</a>) und kann für größere Punktwolken verwendet werden.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Bei der Verwendung von <code>QwtPlotCurve::Dots</code> sollte man bei heute üblichen Bildschirmauflösungen immer einen <code>QPen</code> mit größerer Breite einstellen, da mein <em>einzelne Pixel</em> sonst nur noch schwer sehen kann. Für die Visualisierung großer Punktwolken (&gt; 100000 Pixel) kann die Verwendung von einzelnen Pixeln durchaus noch einen Mehrwert bieten. Für alle besonderen Formen (Kreuze, Rauten, Ringe, Sterne, &#8230;&#8203;)  ist die Verwendung von Symbolen (siehe <a href="#sec:plotSymbols">Kapitel 5.7</a>) sinnvoll.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">QwtPlotCurve</span> <span class="o">*</span><span class="n">curve</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">QwtPlotCurve</span><span class="p">();</span>
<span class="n">curve</span><span class="o">-&gt;</span><span class="n">setStyle</span><span class="p">(</span><span class="n">QwtPlotCurve</span><span class="o">::</span><span class="n">Dots</span><span class="p">);</span>
<span class="n">curve</span><span class="o">-&gt;</span><span class="n">setPen</span><span class="p">(</span><span class="n">QColor</span><span class="p">(</span><span class="mi">180</span><span class="p">,</span><span class="mi">40</span><span class="p">,</span><span class="mi">20</span><span class="p">),</span> <span class="mi">4</span><span class="p">);</span> <span class="c1">// width of 4 makes points better visible</span></code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/PlotCurves_StyleDots.png" alt="PlotCurves StyleDots">
</div>
<div class="title">Abbildung 23. Punktediagramm</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Bei der Visualisierung von Punktwolken kann es hilfreich sein, Transparenz/Alphablending zu benutzen. Dazu einfach bei der Zeichenfarbe noch einen Alphawert kleiner als 255 setzen.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">QwtPlotCurve</span> <span class="o">*</span><span class="n">curve</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">QwtPlotCurve</span><span class="p">();</span>
<span class="n">curve</span><span class="o">-&gt;</span><span class="n">setStyle</span><span class="p">(</span><span class="n">QwtPlotCurve</span><span class="o">::</span><span class="n">Dots</span><span class="p">);</span>
<span class="n">curve</span><span class="o">-&gt;</span><span class="n">setPen</span><span class="p">(</span><span class="n">QColor</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">40</span><span class="p">,</span><span class="mi">180</span><span class="p">,</span><span class="mi">32</span><span class="p">),</span> <span class="mi">2</span><span class="p">);</span> <span class="c1">// 2 pixels wide, alpha value 32</span></code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/PlotCurves_StyleDotsScatter.png" alt="PlotCurves StyleDotsScatter">
</div>
<div class="title">Abbildung 24. Punktwolke mit halbtransparenten Punkten</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Wenn man ein Liniendiagramm mit Visualisierung von Stützstellen erhalten will, so kann man natürlich <em>zwei</em> Linien ins Diagramm einfügen: eine mit Stil <code>QwtPlotCurve::Lines</code> und die zweite mit Stil <code>QwtPlotCurve::Dots</code> darüber, d.h. mit höherem z-Wert, zeichnen. Dann muss man aber auch zwei mal die Daten ins Diagramm geben und man erhält auch zwei Legendeneinträge (die kann man zwar abschalten, siehe <a href="#sec:legend">Kapitel 7</a>, aber trotzdem). Besser ist hier die Verwendung von nur einer Kurve und Symbolen an den Stützstellen (siehe <a href="#sec:plotSymbols">Kapitel 5.7</a>).</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_keine_linie">5.6. Keine Linie</h3>
<div class="paragraph">
<p>Möchte man eine Kurve ausschließlich mit Symbolen zeichnen (siehe nachfolgendes Kapitel), so kann man das Zeichnen des Linienzugs auch komplett ausstellen:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">curve</span><span class="o">-&gt;</span><span class="n">setStyle</span><span class="p">(</span><span class="n">QwtPlotCurve</span><span class="o">::</span><span class="n">NoCurve</span><span class="p">);</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="sec:plotSymbols">5.7. Symbole/Punkte</h3>
<div class="paragraph">
<p>An den jeweiligen x,y-Koordinaten einer Kurve kann man auch Symbole zeichnen. Dafür bietet die Qwt-Bibliothek die Klasse <code>QwtSymbol</code> an.</p>
</div>
<div class="paragraph">
<p>Ein Symbol fügt man zu eine Kurve wie folgt hinzu:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="c1">// Symbol hinzufügen</span>
<span class="n">QwtSymbol</span> <span class="o">*</span> <span class="n">symbol</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">QwtSymbol</span><span class="p">(</span><span class="n">QwtSymbol</span><span class="o">::</span><span class="n">Ellipse</span><span class="p">);</span>
<span class="n">symbol</span><span class="o">-&gt;</span><span class="n">setSize</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>
<span class="n">symbol</span><span class="o">-&gt;</span><span class="n">setPen</span><span class="p">(</span><span class="n">QColor</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">160</span><span class="p">),</span> <span class="mi">2</span><span class="p">);</span>
<span class="n">symbol</span><span class="o">-&gt;</span><span class="n">setBrush</span><span class="p">(</span><span class="n">QColor</span><span class="p">(</span><span class="mi">120</span><span class="p">,</span><span class="mi">170</span><span class="p">,</span><span class="mi">255</span><span class="p">));</span>
<span class="n">curve</span><span class="o">-&gt;</span><span class="n">setSymbol</span><span class="p">(</span><span class="n">symbol</span><span class="p">);</span> <span class="c1">// Curve takes ownership of symbol</span></code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/Symbols_EllipseFilled.png" alt="Symbols EllipseFilled">
</div>
<div class="title">Abbildung 25. Liniendiagramm mit ausgefüllten Kreissymbolen</div>
</div>
<div class="paragraph">
<p>Zuerst wird das zu verwendende Symbol auf dem Heap mit new erzeugt. Der Konstruktor übernimmt den Typ des Symbols (siehe auch Galerie unten). Man kann das aber auch später über <code>QwtSymbol::setStyle()</code> setzen.</p>
</div>
<div class="paragraph">
<p>Wichtig ist auch die Größe des Symbols, gesetzt mittels <code>QwtSymbol::setSize()</code> in Pixeln. Diese Größe skaliert das Symbol je nach Form.</p>
</div>
<div class="paragraph">
<p>Außerdem wichtig sind die Eigenschaften Pen und Brush (<code>QwtSymbol::setPen()</code> und <code>QwtSymbol::setBruch()</code>). Der Pen wird für das Zeichnen des Umrisses verwendet und der Brush, so gesetzt, für das Ausfüllen der Form. Manche Symbole wie das Kreuz sind nicht ausgefüllt, daher hat hier der Brush keine Wirkung.</p>
</div>
<div class="paragraph">
<p>Schließlich wird das Symbol der Kurve mit <code>QwtPlotCurve::setSymbol()</code> gegeben.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Beim Aufruf von <code>QwtPlotCurve::setSymbol()</code> übernimmt die Plot-Kurve die Verantwortung für&#8217;s Speicheraufräumen.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Die Symbolklasse ist ziemlich mächtig und kann verschiedenste Symbole zeichnen:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>vorgefertigte Formen wie Kreise, Rechtecke, Kreuze, etc. (Stil <code>QwtSymbol::Ellipse</code>&#8230;&#8203;<code>QwtSymbol::Hexagon</code></p>
</li>
<li>
<p>nutzerdefinierte Bilder/Pixmaps (Stil <code>QwtSymbol::Pixmap</code>)</p>
</li>
<li>
<p>spezifische Grafiken gekapselt in Klasse <code>QwtGraphic</code> und erzeugt durch eine Anzahl von <code>QwtPainterCommand</code> Anweisungen (Stil <code>QwtSymbol::Graphic</code>) (siehe auch <a href="#sec:qwtGraphic">[sec:qwtGraphic]</a>)</p>
</li>
<li>
<p>SVG-Dokumente (Stil <code>QwtSymbol::SvgDocument</code>)</p>
</li>
<li>
<p>nutzerdefinierte Formen, welche durch einen QPainterPath definiert sind (Stil <code>QwtSymbol::Path</code>)</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_symbolstileeingebauten_symbolformen">5.7.1. Symbolstile/Eingebauten Symbolformen</h4>
<div class="paragraph">
<p>Es gibt zahlreiche eingebaute Symbolformen (fett gedruckt im Diagrammtitel ist jeweils der <code>QwtSymbol::Style</code> Enumerationsname):</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/Symbols_Gallery.png" alt="Symbols Gallery">
</div>
<div class="title">Abbildung 26. Eingebaute Symboltypen/Stile und deren Enumerationstypen</div>
</div>
<div class="paragraph">
<p>Symbole müssen nicht immer quadratisch sein. Wenn man die Größe eines Symbols mit</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">symbol</span><span class="o">-&gt;</span><span class="n">setSize</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>setzt, wird automatisch <code>width=height=10</code> verwendet. Alternativ kann man aber auch ein Rechteck als Größe definieren:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">symbol</span><span class="o">-&gt;</span><span class="n">setSize</span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="n">h</span><span class="p">);</span>
<span class="c1">// oder via QSize</span>
<span class="n">QSize</span> <span class="nf">s</span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="n">h</span><span class="p">);</span>
<span class="n">symbol</span><span class="o">-&gt;</span><span class="n">setSize</span><span class="p">(</span><span class="n">s</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Deshalb gibt es auch keine separaten Linienstile für Kreis und Ellipse oder Rechteck und Quadrat.</p>
</div>
</div>
<div class="sect3">
<h4 id="_nutzerdefinierte_formen_via_qpainterpath">5.7.2. Nutzerdefinierte Formen via QPainterPath</h4>
<div class="paragraph">
<p>Man kann beliebige eigene Symbolformen setzen, indem man die Klasse <code>QPainterPath</code> verwendet.
Folgendes Beispiel generiert ein Glühlampensymbol:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="c1">// Symbol hinzufügen</span>
<span class="n">QwtSymbol</span> <span class="o">*</span> <span class="n">symbol</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">QwtSymbol</span><span class="p">(</span><span class="n">QwtSymbol</span><span class="o">::</span><span class="n">Path</span><span class="p">);</span>
<span class="n">QPainterPath</span> <span class="n">p</span><span class="p">;</span>
<span class="n">p</span><span class="p">.</span><span class="n">addEllipse</span><span class="p">(</span><span class="n">QRectF</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">20</span><span class="p">));</span>
<span class="n">p</span><span class="p">.</span><span class="n">moveTo</span><span class="p">(</span><span class="o">-</span><span class="mi">7</span><span class="p">,</span><span class="o">-</span><span class="mi">7</span><span class="p">);</span>
<span class="n">p</span><span class="p">.</span><span class="n">lineTo</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span><span class="mi">7</span><span class="p">);</span>
<span class="n">p</span><span class="p">.</span><span class="n">moveTo</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span><span class="o">-</span><span class="mi">7</span><span class="p">);</span>
<span class="n">p</span><span class="p">.</span><span class="n">lineTo</span><span class="p">(</span><span class="o">-</span><span class="mi">7</span><span class="p">,</span><span class="mi">7</span><span class="p">);</span>
<span class="n">symbol</span><span class="o">-&gt;</span><span class="n">setPath</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="n">symbol</span><span class="o">-&gt;</span><span class="n">setPen</span><span class="p">(</span><span class="n">QColor</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">120</span><span class="p">),</span> <span class="mi">2</span><span class="p">);</span>
<span class="n">symbol</span><span class="o">-&gt;</span><span class="n">setBrush</span><span class="p">(</span><span class="n">QColor</span><span class="p">(</span><span class="mi">160</span><span class="p">,</span><span class="mi">200</span><span class="p">,</span><span class="mi">255</span><span class="p">));</span>
<span class="n">curve</span><span class="o">-&gt;</span><span class="n">setSymbol</span><span class="p">(</span><span class="n">symbol</span><span class="p">);</span> <span class="c1">// Curve takes ownership of symbol</span></code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/Symbols_PainterPath.png" alt="Symbols PainterPath">
</div>
<div class="title">Abbildung 27. Eigenes Symbol definiert mittels QPainterPath</div>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Achtung"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Wenn man eine nicht-rechteckige Geometrie mit QPainterPath definiert, sollte man beim Ändern der Größe mittels <code>QwtSymbol::setSize()</code> die Variante mit den zwei Argumenten aufrufen, also <code>QwtSymbol::setSize(width,height)</code>. Die Variante mit nur einem Argument transformiert den Pfad onst auf ein Quadrat. Da man üblicherweise keine nicht-quadratischen Formen als Symbol definiert, dürfte das aber nur selten ein Problem sein.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_svg_symbole">5.7.3. SVG-Symbole</h4>
<div class="paragraph">
<p>Man kann eigene SVG-Dateien rendern und anzeigen lassen. Dafür muss man nur eine SVG-Datei einlesen/definieren und als Symbol setzen:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">QwtSymbol</span> <span class="o">*</span> <span class="n">symbol</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">QwtSymbol</span><span class="p">(</span><span class="n">QwtSymbol</span><span class="o">::</span><span class="n">SvgDocument</span><span class="p">);</span>
<span class="n">QFile</span> <span class="nf">f</span><span class="p">(</span><span class="s">"symbol.svg"</span><span class="p">);</span>
<span class="n">f</span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="n">QFile</span><span class="o">::</span><span class="n">ReadOnly</span><span class="p">);</span>
<span class="n">QTextStream</span> <span class="nf">strm</span><span class="p">(</span><span class="o">&amp;</span><span class="n">f</span><span class="p">);</span>
<span class="n">QByteArray</span> <span class="n">svgDoc</span> <span class="o">=</span> <span class="n">strm</span><span class="p">.</span><span class="n">readAll</span><span class="p">().</span><span class="n">toLatin1</span><span class="p">();</span>
<span class="n">symbol</span><span class="o">-&gt;</span><span class="n">setSvgDocument</span><span class="p">(</span><span class="n">svgDoc</span><span class="p">);</span>
<span class="n">curve</span><span class="o">-&gt;</span><span class="n">setSymbol</span><span class="p">(</span><span class="n">symbol</span><span class="p">);</span> <span class="c1">// Curve takes ownership of symbol</span></code></pre>
</div>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Achtung"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Auch hier ist beim Festlegen der Größe wieder auf das Seitenverhältnis zu achten und zumeist die Variante <code>QwtSymbol::setSize(width,height)</code> zu verwenden.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Manchmal liegt der Ankerpunkt des SVG-Bildes nicht im Zentrum, wie in obigem Beispiel:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/Symbols_SvgCentered.png" alt="Symbols SvgCentered">
</div>
<div class="title">Abbildung 28. Zentriertes SVG-Symbol, welches eigentlich aber nach oben verschoben sein sollte</div>
</div>
<div class="paragraph">
<p>Man kann den Ankerpunkt bzw. den Zentrierpunkt des Symbols aber mit <code>QwtSymbol::setPinPoint()</code> ändern. Die Koordinaten des PinPoint werden dabei von links/oben des SVG-Bildes gemessen:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="p">...</span>
<span class="n">QRect</span> <span class="n">br</span> <span class="o">=</span> <span class="n">symbol</span><span class="o">-&gt;</span><span class="n">boundingRect</span><span class="p">();</span> <span class="c1">// size of symbol</span>
<span class="n">symbol</span><span class="o">-&gt;</span><span class="n">setPinPoint</span><span class="p">(</span><span class="n">QPointF</span><span class="p">(</span><span class="n">br</span><span class="p">.</span><span class="n">width</span><span class="p">()</span><span class="o">/</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">br</span><span class="p">.</span><span class="n">height</span><span class="p">()</span><span class="o">-</span><span class="mi">3</span><span class="p">));</span></code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/Symbols_SvgWithPinPoint.png" alt="Symbols SvgWithPinPoint">
</div>
<div class="title">Abbildung 29. SVG-Symbol mit korrekter Ausrichtung des "Stecknadel"-Punktes</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Man kann die manuell gesetzten Ankerpunkt auch wieder mit <code>QwtSymbol::setPinPointEnabled(false)</code> deaktivieren.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_bild_symbole_pixmaps">5.7.4. Bild-Symbole (Pixmaps)</h4>
<div class="paragraph">
<p>Alternativ zu eigenen Vektorgrafiksymbolen kann man auch beliebige Bilder als Symbole verwenden. Dies geschieht analog zu den SVG-Symbolen:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">QwtSymbol</span> <span class="o">*</span> <span class="n">symbol</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">QwtSymbol</span><span class="p">(</span><span class="n">QwtSymbol</span><span class="o">::</span><span class="n">Pixmap</span><span class="p">);</span>
<span class="n">QwtText</span> <span class="nf">t</span><span class="p">(</span><span class="s">"QwtSymbol::Pixmap"</span><span class="p">);</span>
<span class="n">QPixmap</span> <span class="n">pixmap</span><span class="p">;</span>
<span class="n">pixmap</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="s">"symbol.png"</span><span class="p">);</span>
<span class="n">symbol</span><span class="o">-&gt;</span><span class="n">setPixmap</span><span class="p">(</span><span class="n">pixmap</span><span class="p">);</span>
<span class="n">QRect</span> <span class="n">br</span> <span class="o">=</span> <span class="n">symbol</span><span class="o">-&gt;</span><span class="n">boundingRect</span><span class="p">();</span> <span class="c1">// size of symbol</span>
<span class="n">symbol</span><span class="o">-&gt;</span><span class="n">setPinPoint</span><span class="p">(</span><span class="n">QPointF</span><span class="p">(</span><span class="n">br</span><span class="p">.</span><span class="n">width</span><span class="p">()</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="n">br</span><span class="p">.</span><span class="n">height</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span>
<span class="n">curve</span><span class="o">-&gt;</span><span class="n">setSymbol</span><span class="p">(</span><span class="n">symbol</span><span class="p">);</span> <span class="c1">// Curve takes ownership of symbol</span></code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/Symbols_Pixmap.png" alt="Symbols Pixmap">
</div>
<div class="title">Abbildung 30. Pixmap-Symbol, auch mit manuell festgelegtem "Stecknadel"-Punkt</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="sec:intervalCurves">5.8. Intervallkurven</h3>
<div class="paragraph">
<p>Eine spezielle Kurvenart ist die <em>Intervallkurve</em>, bereitgestellt über die Klasse <code>QwtPlotIntervalCurve</code>.</p>
</div>
<div class="paragraph">
<p>Im Prinzip ist das eine Kurve mit zwei y-Werten pro x-Koordinate im Datensatz. Es werden zwei reguläre Kurven gezeichnet und dazwischen wird die Fläche ausgefüllt. Dies kann man auch gut dazu nutzen, um gestackte Liniendiagramme zu zeichnen.</p>
</div>
<div class="listingblock">
<div class="title">Beispiel für eine Intervallkurve</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">QVector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">x</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">17</span><span class="p">};</span>
<span class="n">QVector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">y1</span><span class="p">{</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span><span class="mi">11</span><span class="p">};</span>
<span class="n">QVector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">y2</span><span class="p">{</span><span class="mi">6</span><span class="p">,</span><span class="mf">4.4</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span> <span class="mf">5.5</span><span class="p">,</span> <span class="mf">5.7</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span><span class="mi">12</span><span class="p">};</span>

<span class="n">QVector</span><span class="o">&lt;</span><span class="n">QwtIntervalSample</span><span class="o">&gt;</span> <span class="n">intervalSamples</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">x</span><span class="p">.</span><span class="n">count</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
	<span class="n">intervalSamples</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">QwtIntervalSample</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">y1</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">y2</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>

<span class="n">QwtPlotIntervalCurve</span> <span class="o">*</span><span class="n">curve</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">QwtPlotIntervalCurve</span><span class="p">();</span>
<span class="n">curve</span><span class="o">-&gt;</span><span class="n">setStyle</span><span class="p">(</span><span class="n">QwtPlotIntervalCurve</span><span class="o">::</span><span class="n">Tube</span><span class="p">);</span>
<span class="n">curve</span><span class="o">-&gt;</span><span class="n">setPen</span><span class="p">(</span><span class="n">QColor</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">40</span><span class="p">,</span><span class="mi">180</span><span class="p">),</span> <span class="mi">2</span><span class="p">);</span>
<span class="n">curve</span><span class="o">-&gt;</span><span class="n">setBrush</span><span class="p">(</span> <span class="n">QColor</span><span class="p">(</span><span class="mi">60</span><span class="p">,</span><span class="mi">200</span><span class="p">,</span><span class="mi">255</span><span class="p">)</span> <span class="p">);</span>
<span class="n">curve</span><span class="o">-&gt;</span><span class="n">setRenderHint</span><span class="p">(</span> <span class="n">QwtPlotItem</span><span class="o">::</span><span class="n">RenderAntialiased</span><span class="p">,</span> <span class="nb">true</span> <span class="p">);</span> <span class="c1">// Antialiasing verwenden</span>
<span class="n">curve</span><span class="o">-&gt;</span><span class="n">setSamples</span><span class="p">(</span><span class="n">intervalSamples</span><span class="p">);</span>
<span class="n">curve</span><span class="o">-&gt;</span><span class="n">attach</span><span class="p">(</span><span class="o">&amp;</span><span class="n">plot</span><span class="p">);</span> <span class="c1">// Plot takes ownership</span></code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/IntervalCurve.png" alt="IntervalCurve">
</div>
<div class="title">Abbildung 31. Intervallkurve</div>
</div>
<div class="paragraph">
<p>Die Funktion <code>setSamples()</code> gibt es in zwei Varianten:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>QwtPlotIntervalCurve::setSamples( const QVector&lt; QwtIntervalSample &gt;&amp; )</code> : erwartet einen Vektor mit Interval-Samples, bestehend aus x-Koordinate, unterem und oberen y-Wert</p>
</li>
<li>
<p><code>QwtPlotIntervalCurve::setSamples( QwtSeriesData&lt; QwtIntervalSample &gt;* )</code> : erwartet ein <code>QwtSeriesData</code> Objekt (siehe <a href="#sec:seriesData">Kapitel 4.2</a>) welches Eigentum der Intervallkurve wird. Diese Funktion entspricht der Funktion <code>setData()</code> der Elternklasse <code>QwtSeriesStore</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Man kann das Erscheinungsbild noch etwas Aufwerten, wenn man für die Füllung der Kurve einen Gradienten verwendet. Dafür gibt man der Kurve einfach einen <code>QBrush</code>, der mit einem Gradienten erstellt wurde.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="p">...</span>
<span class="n">QLinearGradient</span> <span class="nf">grad</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">90</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">220</span><span class="p">);</span>
<span class="n">grad</span><span class="p">.</span><span class="n">setColorAt</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">QColor</span><span class="p">(</span><span class="mi">60</span><span class="p">,</span><span class="mi">200</span><span class="p">,</span><span class="mi">255</span><span class="p">));</span>
<span class="n">grad</span><span class="p">.</span><span class="n">setColorAt</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">QColor</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">60</span><span class="p">,</span><span class="mi">120</span><span class="p">));</span>
<span class="n">curve</span><span class="o">-&gt;</span><span class="n">setBrush</span><span class="p">(</span> <span class="n">QBrush</span><span class="p">(</span><span class="n">grad</span><span class="p">));</span>
<span class="p">...</span></code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/IntervalCurve_Gradient.png" alt="IntervalCurve Gradient">
</div>
<div class="title">Abbildung 32. Intervallkurve mit Gradientenfüllung</div>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Achtung"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Die Colorstops der Gradienten in Qt werden in Pixelkoordinaten angegeben. Wenn man also das Plot-Fenster vergrößert/verkleinert, dann führt das zu witzigen Effekten.
Die Lösung ist, das QwtPlot in einer eigenen Klasse abzuleiten und im Resize-Event den Gradienten entsprechend anzupassen. Gleiches gilt auch für das interaktive Verschieben/Zoomen im Plotfenster, also immer wenn ich sich die Pixelkoordinaten der gefüllten Fläche ändern.
Insgesamt einfacher ist es, die Klasse <code>QwtPlotIntervalCurve</code> abzuleiten und die Zeichenfunktion selbst zu implementieren, siehe auch Beispiel in <a href="#sec:advancedCurves">[sec:advancedCurves]</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<div class="title">Intervallkurve mit festem Gradienten bei Änderung der Plotgeometrie</div>
<p><span class="image"><img src="../images/IntervalCurve_Gradient_200.png" alt="Height200" width="200" height="400"></span>
<span class="image"><img src="../images/IntervalCurve_Gradient_300.png" alt="Height300" width="200" height="400"></span>
<span class="image"><img src="../images/IntervalCurve_Gradient_400.png" alt="Height400" width="200" height="400"></span></p>
</div>
</div>
<div class="sect2">
<h3 id="_gestapelte_intervall_kurvenflächendiagramme">5.9. Gestapelte (Intervall-)Kurven/Flächendiagramme</h3>
<div class="paragraph">
<p>Man kann die Intervallkurven auch nutzen, um gestapelte, ausgefüllte Kurven bzw. Flächendiagramme zu erstellen. Dazu erstellt man einfach mehrere <code>QwtPlotIntervalCurve</code> Zeichenelemente, die sich jeweils die gleichen Y-Werte teilen.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">QVector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">x</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">17</span><span class="p">};</span>
<span class="n">QVector</span><span class="o">&lt;</span><span class="n">QVector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="o">&gt;</span>  <span class="n">y</span><span class="p">;</span>
<span class="c1">// 3 curves, 4 lines</span>
<span class="n">y</span><span class="p">.</span><span class="n">append</span><span class="p">(</span> <span class="n">QVector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">}</span> <span class="p">);</span>
<span class="n">y</span><span class="p">.</span><span class="n">append</span><span class="p">(</span> <span class="n">QVector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">{</span><span class="mi">2</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span>  <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span>  <span class="mi">5</span><span class="p">,</span> <span class="mi">11</span><span class="p">}</span> <span class="p">);</span>
<span class="n">y</span><span class="p">.</span><span class="n">append</span><span class="p">(</span> <span class="n">QVector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">{</span><span class="mi">6</span><span class="p">,</span><span class="mf">4.4</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span><span class="mf">5.5</span><span class="p">,</span><span class="mf">5.7</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">}</span> <span class="p">);</span>
<span class="n">y</span><span class="p">.</span><span class="n">append</span><span class="p">(</span> <span class="n">QVector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">{</span><span class="mi">7</span><span class="p">,</span><span class="mf">6.6</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span>  <span class="mi">9</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">13</span><span class="p">}</span> <span class="p">);</span>

<span class="k">const</span> <span class="n">QColor</span> <span class="n">cols</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="n">QColor</span><span class="p">(</span><span class="mi">96</span><span class="p">,</span><span class="mi">60</span><span class="p">,</span><span class="mi">20</span><span class="p">),</span>
						<span class="n">QColor</span><span class="p">(</span><span class="mi">156</span><span class="p">,</span><span class="mi">39</span><span class="p">,</span><span class="mi">6</span><span class="p">),</span>
						<span class="n">QColor</span><span class="p">(</span><span class="mi">212</span><span class="p">,</span><span class="mi">91</span><span class="p">,</span><span class="mi">18</span><span class="p">),</span>
						<span class="n">QColor</span><span class="p">(</span><span class="mi">242</span><span class="p">,</span><span class="mi">188</span><span class="p">,</span><span class="mi">43</span><span class="p">)</span>
					  <span class="p">};</span>

<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">y</span><span class="p">.</span><span class="n">count</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">QwtPlotIntervalCurve</span> <span class="o">*</span><span class="n">curve</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QwtPlotIntervalCurve</span><span class="p">();</span>
	<span class="c1">// generate intervals for current curve</span>
	<span class="n">QVector</span><span class="o">&lt;</span><span class="n">QwtIntervalSample</span><span class="o">&gt;</span> <span class="n">intervalSamples</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">x</span><span class="p">.</span><span class="n">count</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="n">intervalSamples</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">QwtIntervalSample</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">],</span><span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]));</span>
	<span class="n">curve</span><span class="o">-&gt;</span><span class="n">setStyle</span><span class="p">(</span><span class="n">QwtPlotIntervalCurve</span><span class="o">::</span><span class="n">Tube</span><span class="p">);</span>
	<span class="n">curve</span><span class="o">-&gt;</span><span class="n">setPen</span><span class="p">(</span><span class="n">QColor</span><span class="p">(</span><span class="mi">96</span><span class="p">,</span><span class="mi">60</span><span class="p">,</span><span class="mi">20</span><span class="p">),</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">curve</span><span class="o">-&gt;</span><span class="n">setBrush</span><span class="p">(</span><span class="n">cols</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]);</span>
	<span class="n">curve</span><span class="o">-&gt;</span><span class="n">setRenderHint</span><span class="p">(</span> <span class="n">QwtPlotItem</span><span class="o">::</span><span class="n">RenderAntialiased</span><span class="p">,</span> <span class="nb">true</span> <span class="p">);</span> <span class="c1">// Antialiasing verwenden</span>
	<span class="n">curve</span><span class="o">-&gt;</span><span class="n">setSamples</span><span class="p">(</span><span class="n">intervalSamples</span><span class="p">);</span>
	<span class="n">curve</span><span class="o">-&gt;</span><span class="n">attach</span><span class="p">(</span><span class="o">&amp;</span><span class="n">plot</span><span class="p">);</span> <span class="c1">// Plot takes ownership</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/IntervalCurve_StackedCurve.png" alt="IntervalCurve StackedCurve">
</div>
<div class="title">Abbildung 33. Diagramm mit gestapelten Kurven/Flächendiagramm</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sec:barPlots">6. Balkendiagramme</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Balkendiagramme sind mit <code>QwtPlot</code> ebenfalls einfach möglich. Dabei gibt es verschiedene Varianten, je nach Datenlage:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>ein Balken pro Intervall, nebeneinander oder gestapelt</p>
</li>
<li>
<p>mehrere Balken pro Intervall, nebeneinander oder gestapelt</p>
</li>
<li>
<p>mehrere Balken pro Intervall, nebeneinander und gestapelt (das geht z.B. mit Excel nicht!)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Als Zeichenelement/Diagrammtyp werden entweder <code>QwtPlotBarChart</code> oder <code>QwtPlotMultiBarChart</code> verwendet. Beide Klassen implementieren die Schnittstelle der abstrakten Basisklasse <code>QwtPlotAbstractBarChart</code>.</p>
</div>
<div class="sect2">
<h3 id="_grundlegende_eigenschaften_der_plots">6.1. Grundlegende Eigenschaften der Plots</h3>
<div class="paragraph">
<p>Für einfache Balkendiagramme verwendet man die Klasse <code>QwtPlotBarChart</code>. Wie auch schon bei <code>QwtPlotCurve</code> wird das Balkendiagramm-Zeichenelement auf dem Heap erstellt und dem Diagramm mit <code>attach()</code> übergeben.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">QwtPlotBarChart</span> <span class="o">*</span> <span class="n">curve</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">QwtPlotBarChart</span><span class="p">();</span>
<span class="n">QVector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">y</span><span class="p">{</span><span class="mi">10</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">14</span><span class="p">,</span><span class="mi">18</span><span class="p">,</span><span class="mi">12</span><span class="p">};</span>
<span class="n">curve</span><span class="o">-&gt;</span><span class="n">setSamples</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>
<span class="n">curve</span><span class="o">-&gt;</span><span class="n">attach</span><span class="p">(</span><span class="o">&amp;</span><span class="n">plot</span><span class="p">);</span> <span class="c1">// Plot takes ownership</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Ohne weitere Anpassung sieht das Diagramm noch recht langweilig aus.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/BarPlot_1.png" alt="BarPlot 1">
</div>
<div class="title">Abbildung 34. Minimalistisches Balkendiagramm</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Die Funktion <code>QwtPlotBarChart::setSamples()</code> generiert aus dem Vektor der y-Werte automatisch einen Vektor mit x,y-Wertepaaren, wobei die x-Werte von 0 beginnend durchnummeriert werden. Die Balken entsprechen intern einer normalen Plotkurve mit equidistanten Stützstellen auf der x-Achse.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_bezugslinie">6.2. Bezugslinie</h3>
<div class="paragraph">
<p>Standardmäßig beginnen die Balken bei 0. Mitunter will man aber relative Unterschiede bezogen auf eine Grundlinie einstellen. Dazu verwendet man <code>setBaseLine(yPlotCoordinate)</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">QVector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">y</span><span class="p">{</span><span class="mi">10</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">14</span><span class="p">,</span><span class="mi">18</span><span class="p">,</span><span class="mi">12</span><span class="p">};</span>
<span class="n">curve</span><span class="o">-&gt;</span><span class="n">setSamples</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>
<span class="n">curve</span><span class="o">-&gt;</span><span class="n">setBaseLine</span><span class="p">(</span><span class="mi">15</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/BarPlot_1_baseLine.png" alt="BarPlot 1 baseLine">
</div>
<div class="title">Abbildung 35. Balkendiagramm mit Bezugslinie bei y=15</div>
</div>
</div>
<div class="sect2">
<h3 id="_layout_und_abstände">6.3. Layout und Abstände</h3>
<div class="paragraph">
<p>Das Erscheinungsbild des Diagramms lässt sich vielfältig anpassen. Wenn man das Diagramm vergrößert und verkleinert, werden dabei die Achsen skaliert und passend dazu auch die Balken.</p>
</div>
<div class="paragraph">
<p>In der Standardeinstellung werden die Balken mit minimalem Abstand zueinander und vom Rand gezeichnet. Den Randabstand kann man mit <code>setMargin(pixels)</code> ändern und den Abstand zwischen den einzelnen Balken definiert man mit <code>setSpacing(pixels)</code>.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/BarPlot_1_spacingMargin.png" alt="BarPlot 1 spacingMargin">
</div>
<div class="title">Abbildung 36. Balkendiagramm mit angepassten Abständen und Rändern</div>
</div>
<div class="paragraph">
<p>Die Breite der Balken selbst wird über Layoutvorgaben und konkret über die Funktionen <code>QwtPlotAbstractBarChart::setLayoutPolicy()</code> und <code>QwtPlotAbstractBarChart::setLayoutHint()</code> kontrolliert.</p>
</div>
<div class="sect3">
<h4 id="_autoadjustsamples">6.3.1. AutoAdjustSamples</h4>
<div class="paragraph">
<p>In diesem Modus, gesetzt durch</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">curve</span><span class="o">-&gt;</span><span class="n">setLayoutPolicy</span><span class="p">(</span><span class="n">QwtPlotAbstractBarChart</span><span class="o">::</span><span class="n">AutoAdjustSamples</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>wird die Größe der Balken basierend auf der Größe der Zeichenfläche und der gesetzen Rand- und Zwischenabstände bestimmt.</p>
</div>
<div class="paragraph">
<div class="title">Balkendiagram im Layoutmodus <em>AutoAdjustSamples</em>, normal (links) und hineingezoomt (rechts)</div>
<p><span class="image"><img src="../images/BarPlot_1_LayoutAutoAdjustSamples.png" alt="BarPlot 1 LayoutAutoAdjustSamples"></span>
<span class="image"><img src="../images/BarPlot_1_LayoutAutoAdjustSamples_zoomed.png" alt="BarPlot 1 LayoutAutoAdjustSamples zoomed"></span></p>
</div>
<div class="paragraph">
<p>Die Balken, die Zwischenräume (spacing) und Randabstände (margin) füllen die Zeichenfläche komplett aus. Wie man am rechten Diagramm sieht, bleibt das auch beim Hineinzoomen ins Diagramm so.</p>
</div>
<div class="paragraph">
<p>Der zusätzliche Parameter <code>setLayoutHint()</code> definiert die Anzahl der Pixel, die ein Balken mindestens breit sein sollte. Damit kann man verhindern, dass beim Verkleinern der Plotgröße die Balken irgendwann komplett verschwinden. Folgendes Beispiel zeigt, was bei einem größeren LayoutHint im Modus <code>AutoAdjustSamples</code> passiert:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">curve</span><span class="o">-&gt;</span><span class="n">setLayoutPolicy</span><span class="p">(</span><span class="n">QwtPlotAbstractBarChart</span><span class="o">::</span><span class="n">AutoAdjustSamples</span><span class="p">);</span>
<span class="n">curve</span><span class="o">-&gt;</span><span class="n">setLayoutHint</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>  <span class="c1">// minimum width of bars is 100 pixels</span></code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/BarPlot_1_LayoutAutoAdjustSamples_minWidth.png" alt="BarPlot 1 LayoutAutoAdjustSamples minWidth">
</div>
<div class="title">Abbildung 37. Durch LayoutHint definierte Mindestbalkenbreite</div>
</div>
</div>
<div class="sect3">
<h4 id="_scalesamplestoaxes">6.3.2. ScaleSamplesToAxes</h4>
<div class="paragraph">
<p>In diesem Layoutmodus wird die Balkenbreite basierend auf der aktuellen x-Achsenskalierung festgelegt. Wenn man in diesem Layoutmodus den LayoutHint auf 0.5 setzt, dann wird ein Balken genau halb so breit wie ein Achsentick gezeichet und dann mittig am Achsentick ausgerichtet. Es wird also die X-Achse benutzt, um die 0.5 in Plotkoordinaten in Pixelbreiten der Zeichenfläche umzurechnen.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">curve</span><span class="o">-&gt;</span><span class="n">setLayoutPolicy</span><span class="p">(</span><span class="n">QwtPlotAbstractBarChart</span><span class="o">::</span><span class="n">ScaleSamplesToAxes</span><span class="p">);</span>
<span class="n">curve</span><span class="o">-&gt;</span><span class="n">setLayoutHint</span><span class="p">(</span><span class="mf">0.5</span><span class="p">);</span> <span class="c1">// 0.5 axis scale as bar width</span></code></pre>
</div>
</div>
<div class="paragraph">
<div class="title">Balkendiagram im Layoutmodus <em>ScaleSamplesToAxes</em>, normal (links) und hineingezoomt (rechts)</div>
<p><span class="image"><img src="../images/BarPlot_1_LayoutScaleSamplesToAxes.png" alt="BarPlot 1 LayoutScaleSamplesToAxes"></span>
<span class="image"><img src="../images/BarPlot_1_LayoutScaleSamplesToAxes_zoomed.png" alt="BarPlot 1 LayoutScaleSamplesToAxes zoomed"></span></p>
</div>
<div class="paragraph">
<p>Auch beim Hereinzoomen orientiert sich die Balkenbreite stets an der X-Achsenskalierung.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Der Balkenabstand wird hier ausschließlich über den LayoutHint definiert und der Balkenabstand, den man mittels <code>setSpacing()</code> setzt, wird in diesem Layoutmodus nicht berücksichtigt. Wenn man also eine Balkenbreite 1 (in x-Achsenskaleneinheiten) setzt, dann werden die Balken dicht-an-dicht gezeichnet, unabhängig vom <em>spacing</em>. Der Randabstand <em>margin</em> wird hingegen wie bisher angewendet.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_scalesampletocanvas">6.3.3. ScaleSampleToCanvas</h4>
<div class="paragraph">
<p>In diesem Modus werden die Balkenbreiten in Abhängigkeit (als Prozentsatz) zur Zeichenflächengröße bestimmt. Man sollte sich zur Festlegung des LayoutHint-Parameters überlegen, wie viele Balken denn maximal im Diagramm sichtbar sein werden.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">curve</span><span class="o">-&gt;</span><span class="n">setLayoutPolicy</span><span class="p">(</span><span class="n">QwtPlotAbstractBarChart</span><span class="o">::</span><span class="n">ScaleSampleToCanvas</span><span class="p">);</span>
<span class="n">curve</span><span class="o">-&gt;</span><span class="n">setLayoutHint</span><span class="p">(</span><span class="mf">0.1</span><span class="p">);</span> <span class="c1">// bar width 10% of canvas width</span></code></pre>
</div>
</div>
<div class="paragraph">
<div class="title">Balkendiagram im Layoutmodus <em>ScaleSampleToCanvas</em>, mit 10% Zeichenflächebreite als Balkenbreite</div>
<p><span class="image"><img src="../images/BarPlot_1_LayoutScaleSampleToCanvas.png" alt="BarPlot 1 LayoutScaleSampleToCanvas"></span>
<span class="image"><img src="../images/BarPlot_1_LayoutScaleSampleToCanvas_zoomed.png" alt="BarPlot 1 LayoutScaleSampleToCanvas zoomed"></span></p>
</div>
<div class="paragraph">
<p>Beim Hereinzoomen bleibt die Balkenbreite konstant und ändert sich nur bei Größenänderung des Plots.</p>
</div>
</div>
<div class="sect3">
<h4 id="_layout_empfehlung">6.3.4. Layout-Empfehlung</h4>
<div class="paragraph">
<p>Abgesehen von speziellen Anforderungen ist für die meisten Fälle die LayoutPolicy <code>QwtPlotAbstractBarChart::ScaleSamplesToAxes</code> empfehlenswert. Sowohl beim Größenändern des Plots als auch beim Zoomen verhält sich das Plot so, wie man es erwartet.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">curve</span><span class="o">-&gt;</span><span class="n">setLayoutPolicy</span><span class="p">(</span><span class="n">QwtPlotAbstractBarChart</span><span class="o">::</span><span class="n">ScaleSamplesToAxes</span><span class="p">);</span>
<span class="n">curve</span><span class="o">-&gt;</span><span class="n">setLayoutHint</span><span class="p">(</span><span class="mf">0.8</span><span class="p">);</span> <span class="c1">// 0.8 axis scale as bar width</span>
<span class="n">curve</span><span class="o">-&gt;</span><span class="n">setMargin</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span> <span class="c1">// 10 pixel margin</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Möchte man wirklich immer die gleichen Abstände zwischen den Balken haben, egal wie groß das Plot ist oder wie weit man hineinzoomt, dann ist die LayoutPolicy <code>QwtPlotAbstractBarChart::AutoAdjustSamples</code> zu empfehlen.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_balkenformen_und_farben">6.4. Balkenformen und Farben</h3>
<div class="paragraph">
<p>Die Balken selbst werden durch die Klasse <code>QwtColumnSymbol</code> gezeichnet. Diese kann verschiedenartig konfiguriert werden. Standardmäßig wird der Symboltyp <code>QwtColumnSymbol::Box</code> verwendet, wie in nachfolgendem Beispiel:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">QwtColumnSymbol</span><span class="o">*</span> <span class="n">symbol</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">QwtColumnSymbol</span><span class="p">(</span> <span class="n">QwtColumnSymbol</span><span class="o">::</span><span class="n">Box</span> <span class="p">);</span>
<span class="n">symbol</span><span class="o">-&gt;</span><span class="n">setLineWidth</span><span class="p">(</span> <span class="mi">2</span> <span class="p">);</span>
<span class="n">symbol</span><span class="o">-&gt;</span><span class="n">setFrameStyle</span><span class="p">(</span> <span class="n">QwtColumnSymbol</span><span class="o">::</span><span class="n">Raised</span> <span class="p">);</span>
<span class="n">symbol</span><span class="o">-&gt;</span><span class="n">setPalette</span><span class="p">(</span> <span class="n">QPalette</span><span class="p">(</span> <span class="n">QColor</span><span class="p">(</span><span class="mh">0xff0040</span><span class="p">)</span> <span class="p">)</span> <span class="p">);</span>
<span class="n">curve</span><span class="o">-&gt;</span><span class="n">setSymbol</span><span class="p">(</span> <span class="n">symbol</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Angepasst werden können die Form des Rechteckrahmens (<code>Raised</code>, <code>Plain</code>, <code>NoFrame</code>), die Füllfarbe und Linienfarbe.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/BarPlot_1_BoxSymbol.png" alt="BarPlot 1 BoxSymbol">
</div>
<div class="title">Abbildung 38. Balkendiagram mit angepasstem Stil für die Balken</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Wenn man ein <code>QPalette</code> Objekt mit einer einzelnen Farbe im Konstruktor erstellt, dann werden die Farben für die einzelnen Palettenrollen automatisch berechnet.
<code>QwtColumnSymbol</code> verwendet die Rollen <code>QPalette::Window</code>, <code>QPalette::Dark</code> und <code>QPalette::Light</code> für die individuelle Elemente. Beim Stil <code>plain</code> wird der Rahmen mit der Palettenrolle <code>Dark</code> gezeichnet.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Durch Anpassung individueller Palettenrollen kann man das Zeichnen der Balken anpassen.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">QwtColumnSymbol</span><span class="o">*</span> <span class="n">symbol</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">QwtColumnSymbol</span><span class="p">(</span> <span class="n">QwtColumnSymbol</span><span class="o">::</span><span class="n">Box</span> <span class="p">);</span>
<span class="n">symbol</span><span class="o">-&gt;</span><span class="n">setFrameStyle</span><span class="p">(</span><span class="n">QwtColumnSymbol</span><span class="o">::</span><span class="n">Plain</span><span class="p">);</span>
<span class="n">symbol</span><span class="o">-&gt;</span><span class="n">setLineWidth</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="n">QPalette</span> <span class="nf">palette</span><span class="p">(</span><span class="n">QColor</span><span class="p">(</span><span class="mh">0xc1e311</span><span class="p">));</span>
<span class="n">palette</span><span class="p">.</span><span class="n">setBrush</span><span class="p">(</span><span class="n">QPalette</span><span class="o">::</span><span class="n">Dark</span><span class="p">,</span> <span class="n">Qt</span><span class="o">::</span><span class="n">black</span><span class="p">);</span> <span class="c1">// black frame</span>
<span class="n">symbol</span><span class="o">-&gt;</span><span class="n">setPalette</span><span class="p">(</span><span class="n">palette</span><span class="p">);</span>
<span class="n">curve</span><span class="o">-&gt;</span><span class="n">setSymbol</span><span class="p">(</span> <span class="n">symbol</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/BarPlot_1_BoxSymbolBlackFrame.png" alt="BarPlot 1 BoxSymbolBlackFrame">
</div>
<div class="title">Abbildung 39. Balkendiagram mit schwarz umrandeten, einfarbigen Balken</div>
</div>
</div>
<div class="sect2">
<h3 id="_balkenbeschriftung_auf_der_x_achse">6.5. Balkenbeschriftung auf der X-Achse</h3>
<div class="paragraph">
<p>Die in den bisherigen Beispieldiagrammen gezeigte X-Achse ist etwas ungewöhnlich für Balkendiagramme. Ohne jetzt auf <a href="#sec:axes">Kapitel 9</a> vorgreifen zu wollen, soll hier doch die für Balkendiagramme typische Anpassung der x-Achse gezeigt werden.</p>
</div>
<div class="paragraph">
<p>Zunächst wird die Achsenzeichenfunktionalität angepasst, wofür man sich zunächst Zugriff auf die aktuelle Zeichenklassen <code>QwtScaleDraw</code> (Header <code>QwtScaleDraw</code> bzw. <code>qwt_scale_draw.h</code>) mit <code>QwtPlot::axisScaleDraw()</code> holt.
Dann schaltet man die Unterteilungsstriche (<em>Ticks</em>) und die Achsenlinie (<em>Backbone</em>) ab.</p>
</div>
<div class="paragraph">
<p>Um die unterschiedlichen Randeinstellungen des Plots besser zu verstehen, werden Balken mit <code>ScaleSamplesToAxes</code> und LayoutHint 1 (komplette Breite) gewählt, die Balkendiagrammränder (<em>margins</em>) auf 20 und der Zeichenflächenrand (umlaufend) auf 10 Pixel gesetzt.</p>
</div>
<div class="paragraph">
<p>Schließlich stellen wir noch sicher, dass das Plotlayout die y-Achse nicht direkt über dem x=0 Wert an den linken Rand der Zeichenfläche legt. Dies macht man durch Anpassung des <code>QwtPlotLayout</code> (Header <code>QwtPlotLayout</code> bzw. <code>qwt_plot_layout.h</code>). <code>QwtPlotLayout::setAlignCanvasToScale()</code> legt fest, ob die gewählte Achse direkt am Rand der Zeichenfläche liegt und damit die jeweils zugeordnete Achse (hier die x-Achse) eben mit dem 0-Wert direkt am linken Rand der Zeichenfläche liegt.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">QwtScaleDraw</span><span class="o">*</span> <span class="n">scaleDraw1</span> <span class="o">=</span> <span class="n">plot</span><span class="p">.</span><span class="n">axisScaleDraw</span><span class="p">(</span> <span class="n">QwtPlot</span><span class="o">::</span><span class="n">xBottom</span> <span class="p">);</span>
<span class="n">scaleDraw1</span><span class="o">-&gt;</span><span class="n">enableComponent</span><span class="p">(</span> <span class="n">QwtScaleDraw</span><span class="o">::</span><span class="n">Backbone</span><span class="p">,</span> <span class="nb">false</span> <span class="p">);</span>
<span class="n">scaleDraw1</span><span class="o">-&gt;</span><span class="n">enableComponent</span><span class="p">(</span> <span class="n">QwtScaleDraw</span><span class="o">::</span><span class="n">Ticks</span><span class="p">,</span> <span class="nb">false</span> <span class="p">);</span>

<span class="n">curve</span><span class="o">-&gt;</span><span class="n">setMargin</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span> <span class="c1">// margin left/right of bars</span>
<span class="n">plot</span><span class="p">.</span><span class="n">plotLayout</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">setCanvasMargin</span><span class="p">(</span> <span class="mi">10</span> <span class="p">);</span> <span class="c1">// canvas margin all around</span>

<span class="c1">// do not fix y-axis at 0 and left edge of canvas</span>
<span class="n">plot</span><span class="p">.</span><span class="n">plotLayout</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">setAlignCanvasToScale</span><span class="p">(</span> <span class="n">QwtPlot</span><span class="o">::</span><span class="n">yLeft</span><span class="p">,</span> <span class="nb">false</span> <span class="p">);</span>
<span class="n">plot</span><span class="p">.</span><span class="n">updateCanvasMargins</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Zum Vergleich nochmal das gleiche Diagramm <em>ohne</em> Ränder und mit <code>setAlignCanvasToScale(yLeft, true)</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">QwtScaleDraw</span><span class="o">*</span> <span class="n">scaleDraw1</span> <span class="o">=</span> <span class="n">plot</span><span class="p">.</span><span class="n">axisScaleDraw</span><span class="p">(</span> <span class="n">QwtPlot</span><span class="o">::</span><span class="n">xBottom</span> <span class="p">);</span>
<span class="n">scaleDraw1</span><span class="o">-&gt;</span><span class="n">enableComponent</span><span class="p">(</span> <span class="n">QwtScaleDraw</span><span class="o">::</span><span class="n">Backbone</span><span class="p">,</span> <span class="nb">false</span> <span class="p">);</span>
<span class="n">scaleDraw1</span><span class="o">-&gt;</span><span class="n">enableComponent</span><span class="p">(</span> <span class="n">QwtScaleDraw</span><span class="o">::</span><span class="n">Ticks</span><span class="p">,</span> <span class="nb">false</span> <span class="p">);</span>

<span class="n">curve</span><span class="o">-&gt;</span><span class="n">setMargin</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="n">plot</span><span class="p">.</span><span class="n">plotLayout</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">setCanvasMargin</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="n">plot</span><span class="p">.</span><span class="n">plotLayout</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">setAlignCanvasToScale</span><span class="p">(</span> <span class="n">QwtPlot</span><span class="o">::</span><span class="n">yLeft</span><span class="p">,</span> <span class="nb">true</span> <span class="p">);</span>
<span class="n">plot</span><span class="p">.</span><span class="n">updateCanvasMargins</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="paragraph">
<div class="title">Balkendiagram mit typischer X-Achsenbeschriftung, mit Rändern (links), ohne Ränder und y-Achse schneidet x-Achse bei x=0 direkt am linken Rand</div>
<p><span class="image"><img src="../images/BarPlot_1_xAxis.png" alt="BarPlot 1 xAxis"></span>
<span class="image"><img src="../images/BarPlot_1_xAxis_aligned.png" alt="BarPlot 1 xAxis aligned"></span></p>
</div>
</div>
<div class="sect2">
<h3 id="_balkenbeschriftungen">6.6. Balkenbeschriftungen</h3>
<div class="paragraph">
<p>Möchte man statt der Zahlen am unteren Bildschirmrand Beschriftungen für die einzelnen Balken haben, musst man die Klasse <code>QwtScaleDraw</code> ableiten und dann die virtuelle Funktionen <code>QwtScaleDraw::label()</code> überladen.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">ScaleDraw</span> <span class="o">:</span> <span class="k">public</span> <span class="n">QwtScaleDraw</span> <span class="p">{</span>
<span class="nl">public:</span>
	<span class="n">ScaleDraw</span><span class="p">(</span><span class="k">const</span> <span class="n">QStringList</span><span class="o">&amp;</span> <span class="n">labels</span> <span class="p">)</span> <span class="o">:</span> <span class="n">m_labels</span><span class="p">(</span> <span class="n">labels</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">enableComponent</span><span class="p">(</span> <span class="n">QwtScaleDraw</span><span class="o">::</span><span class="n">Ticks</span><span class="p">,</span> <span class="nb">false</span> <span class="p">);</span>
		<span class="n">enableComponent</span><span class="p">(</span> <span class="n">QwtScaleDraw</span><span class="o">::</span><span class="n">Backbone</span><span class="p">,</span> <span class="nb">false</span> <span class="p">);</span>
		<span class="n">setLabelAlignment</span><span class="p">(</span> <span class="n">Qt</span><span class="o">::</span><span class="n">AlignHCenter</span> <span class="o">|</span> <span class="n">Qt</span><span class="o">::</span><span class="n">AlignVCenter</span> <span class="p">);</span>
	<span class="p">}</span>

	<span class="k">virtual</span> <span class="n">QwtText</span> <span class="nf">label</span><span class="p">(</span> <span class="kt">double</span> <span class="n">value</span> <span class="p">)</span> <span class="k">const</span> <span class="n">QWT_OVERRIDE</span> <span class="p">{</span>
		<span class="k">const</span> <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">qRound</span><span class="p">(</span> <span class="n">value</span> <span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span> <span class="n">index</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">m_labels</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="p">)</span>
			<span class="k">return</span> <span class="n">m_labels</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
		<span class="k">return</span> <span class="nf">QwtText</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="n">QStringList</span> <span class="n">m_labels</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Diese Klassenimplementierung konfiguriert die Darstellung der Unterteilungsstriche und Skalenlinie wie bisher, sorgt für korrekte Ausrichtung der Labels und merkt sich die im Konstruktor übergebenen Texte als indizierte Liste.
Entscheidend ist die Implementierung der Funktion <code>QwtScaleDraw::label()</code>. Diese Funktion hat die Aufgabe, passend zu den übergebenen Zahlenwerten (hier Werte der x-Achse) entsprechende Beschriftungen anzuzeigen. Wie am Anfang dieses Kapitels erwähnt, wird jedem Balken eine fortlaufende Nummer zugeordnet. Wenn die Achse nun also eine Zahl zeichnen will, also z.B. die 4, dann wird in der Funktion der Wert gerundet und als Index benutzt, um den dazugehörigen Text zurückzuliefern.</p>
</div>
<div class="paragraph">
<div class="title">Balkendiagram mit Textbeschriftung der Balken, rechts hineingezoomed mit fehlerhafter Beschriftung der Balken</div>
<p><span class="image"><img src="../images/BarPlot_1_xAxisWithLabels.png" alt="BarPlot 1 xAxisWithLabels"></span>
<span class="image"><img src="../images/BarPlot_1_xAxisWithLabels_zoomed.png" alt="BarPlot 1 xAxisWithLabels zoomed"></span></p>
</div>
<div class="paragraph">
<p>Das Problem mit dem hineinzoomen lässt sich durch eine minimale Erweiterung des Codes lösen (nur Labels dort zeichnen, wo der x-Achsen-Skalenwert gerundet ziemlich exakt einer ganzen Zahl entspricht):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++">	<span class="k">if</span> <span class="p">(</span> <span class="n">index</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">m_labels</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">qAbs</span><span class="p">(</span><span class="n">index</span><span class="o">-</span><span class="n">value</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-6</span> <span class="p">)</span>
		<span class="k">return</span> <span class="n">m_labels</span><span class="p">[</span><span class="n">index</span><span class="p">];</span></code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/BarPlot_1_xAxisWithLabels_zoomedFixed.png" alt="BarPlot 1 xAxisWithLabels zoomedFixed">
</div>
<div class="title">Abbildung 40. Hineingezoomt in ein Balkendiagramm mit Textbeschriftung</div>
</div>
</div>
<div class="sect2">
<h3 id="_mehrfarbige_balken">6.7. Mehrfarbige Balken</h3>
<div class="paragraph">
<p>Wenn man die Balken nun auch noch individuell einfärben möchte, so kommt man um eine Re-Implemetierung des <code>QwtPlotBarChart</code> Zeichenelements nicht herum. Man muss eigentlich nur die Funktion <code>QwtPlotBarChart::specialSymbol()</code> reimplementieren und hier unterschiedlich gefärbte Balkensymbole zurückliefern.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">MultiColorBarChart</span> <span class="o">:</span> <span class="k">public</span>  <span class="p">{</span>
<span class="nl">public:</span>
	<span class="n">MultiColorBarChart</span><span class="p">()</span> <span class="p">{</span>
		<span class="n">setLayoutPolicy</span><span class="p">(</span><span class="n">QwtPlotBarChart</span><span class="o">::</span><span class="n">ScaleSamplesToAxes</span><span class="p">);</span>
		<span class="n">setLayoutHint</span><span class="p">(</span><span class="mf">0.8</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="c1">// we want to have individual colors for each bar</span>
	<span class="k">virtual</span> <span class="n">QwtColumnSymbol</span><span class="o">*</span> <span class="nf">specialSymbol</span><span class="p">(</span>
	    <span class="kt">int</span> <span class="n">sampleIndex</span><span class="p">,</span> <span class="k">const</span> <span class="n">QPointF</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">const</span> <span class="n">QWT_OVERRIDE</span>
	<span class="p">{</span>
		<span class="c1">// generate symbol with color for each bar</span>
		<span class="n">QwtColumnSymbol</span><span class="o">*</span> <span class="n">symbol</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QwtColumnSymbol</span><span class="p">(</span> <span class="n">QwtColumnSymbol</span><span class="o">::</span><span class="n">Box</span> <span class="p">);</span>
		<span class="n">symbol</span><span class="o">-&gt;</span><span class="n">setLineWidth</span><span class="p">(</span> <span class="mi">2</span> <span class="p">);</span>
		<span class="n">symbol</span><span class="o">-&gt;</span><span class="n">setFrameStyle</span><span class="p">(</span> <span class="n">QwtColumnSymbol</span><span class="o">::</span><span class="n">Raised</span> <span class="p">);</span>

		<span class="n">QColor</span> <span class="nf">c</span><span class="p">(</span> <span class="n">Qt</span><span class="o">::</span><span class="n">white</span> <span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span> <span class="n">sampleIndex</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">sampleIndex</span> <span class="o">&lt;</span> <span class="n">m_colors</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="p">)</span>
			<span class="n">c</span> <span class="o">=</span> <span class="n">m_colors</span><span class="p">[</span> <span class="n">sampleIndex</span> <span class="p">];</span>
		<span class="n">symbol</span><span class="o">-&gt;</span><span class="n">setPalette</span><span class="p">(</span> <span class="n">c</span> <span class="p">);</span>

		<span class="k">return</span> <span class="n">symbol</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">QList</span><span class="o">&lt;</span><span class="n">QColor</span><span class="o">&gt;</span> <span class="n">m_colors</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Für jeden Balken im Diagramm speichern wir uns eine Farbe in der Membervariable <code>m_colors</code>. In der überladenen Funktion <code>QwtPlotBarChart::specialSymbol()</code> erstellen wir nun jeweils ein <code>QwtColumnSymbol</code> wie im vorangehenden Kapitel und liefern dieses zurück. Die Funktion übernimmt sowohl den Index des Balkens (oder <em>samples</em>) als Argument, wie auch die Plotkoordinaten des Balkens, wobei der x-Wert der Punktes wieder der Balkenindex ist, und der y-Wert dem Funktionswert des Balkens entspricht.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Die Funktion <code>QwtPlotBarChart::specialSymbol()</code> ist eine <em>factory function</em> und überträgt die Eigentümerschaft des auf dem Heap erstellten Objekts an den Aufrufer. Deshalb <em>muss</em> man hier in jedem Aufruf der Funktion ein neues <code>QwtColumnSymbol</code> Objekt mit <code>new</code> erstellen. Nachdem der Balken gezeichnet wurde, löscht das Balkendiagrammelement das erzeugte Säulensymbolobjekt wieder.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/BarPlot_1_MultiColor.png" alt="BarPlot 1 MultiColor">
</div>
<div class="title">Abbildung 41. Balkendiagramm mit unterschiedlich gefärbten Balken</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Wenn man nur bestimmte Balken einfärben möchte, die anderen aber im Standarddesign zeichnen lassen will, so kann man die Funktion <code>QwtPlotBarChart::specialSymbol()</code> auch einfach einen <em>nullptr</em> zurückgeben lassen. Dann verwendet das Balkendiagramm das Standardsymbol.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_legendeneinträge">6.8. Legendeneinträge</h3>
<div class="paragraph">
<p>Für Balkendiagramme kann man zwei Arten von Legendeneinträgen erstellen:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>einen Eintrag für das gesammte Balkendiagramm-Zeichenelement, oder</p>
</li>
<li>
<p>individuelle Einträge für jeden einzelnen Balken</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Die erste Variante ist dann sinnvoll, wenn neben dem Balkendiagramm-Zeichenelement noch weitere Zeichenelemente mit Legendeneinträgen angezeigt werden. Im vorliegenden Fall ist eine individuelle Bezeichnung der Balken sinnvoll.</p>
</div>
<div class="paragraph">
<p>Dafür muss die virtuelle Funktion <code>QwtPlotBarChart::barTitle()</code> reimplementiert werden (die Standardimplementierung liefert immer einen leeren Titeltext). Außerdem muss der Legendentyp auf "einzelne Balken" durch Aufruf der Funktion <code>QwtPlotBarChart::setLegendMode( QwtPlotBarChart::LegendBarTitles )</code> umgeschaltet werden. Zusätzlich kann man noch mit <code>QwtPlotBarChart::setLegendIconSize()</code> die Größe der Legendensymbole anpassen:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">MultiColorBarChart</span> <span class="o">:</span> <span class="k">public</span> <span class="n">QwtPlotBarChart</span> <span class="p">{</span>
<span class="nl">public:</span>
	<span class="n">MultiColorBarChart</span><span class="p">()</span> <span class="p">{</span>
		<span class="n">setLayoutPolicy</span><span class="p">(</span><span class="n">QwtPlotBarChart</span><span class="o">::</span><span class="n">ScaleSamplesToAxes</span><span class="p">);</span>
		<span class="n">setLayoutHint</span><span class="p">(</span><span class="mf">0.8</span><span class="p">);</span>
		<span class="c1">// Legende zeigt individuelle Balkentitel</span>
		<span class="n">setLegendMode</span><span class="p">(</span> <span class="n">QwtPlotBarChart</span><span class="o">::</span><span class="n">LegendBarTitles</span> <span class="p">);</span>
		<span class="n">setLegendIconSize</span><span class="p">(</span> <span class="n">QSize</span><span class="p">(</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">14</span> <span class="p">)</span> <span class="p">);</span>
	<span class="p">}</span>

	<span class="c1">// Individuelle Farben für die einzelnen Balken</span>
	<span class="k">virtual</span> <span class="n">QwtColumnSymbol</span><span class="o">*</span> <span class="n">specialSymbol</span><span class="p">(</span>
	    <span class="kt">int</span> <span class="n">sampleIndex</span><span class="p">,</span> <span class="k">const</span> <span class="n">QPointF</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">const</span> <span class="n">QWT_OVERRIDE</span>
	<span class="p">{</span>
	    <span class="c1">// ... wie bisher</span>
	<span class="p">}</span>

	<span class="k">virtual</span> <span class="n">QwtText</span> <span class="n">barTitle</span><span class="p">(</span> <span class="kt">int</span> <span class="n">sampleIndex</span> <span class="p">)</span> <span class="k">const</span> <span class="n">QWT_OVERRIDE</span> <span class="p">{</span>
	 	<span class="k">if</span> <span class="p">(</span> <span class="n">sampleIndex</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">sampleIndex</span> <span class="o">&lt;</span> <span class="n">m_titles</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="p">)</span>
	 		<span class="k">return</span> <span class="n">m_titles</span><span class="p">[</span> <span class="n">sampleIndex</span> <span class="p">];</span>
	 	<span class="k">return</span> <span class="n">QwtText</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="n">QStringList</span>	  <span class="n">m_titles</span><span class="p">;</span>
	<span class="n">QList</span><span class="o">&lt;</span><span class="n">QColor</span><span class="o">&gt;</span> <span class="n">m_colors</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Zusätzlich zu den Farben werden nun die Titel der Balken in der Membervariable <code>m_titles</code> gehalten und in jedem Aufruf von <code>barTitle()</code> zurückgeliefert.</p>
</div>
<div class="paragraph">
<p>Damit die Legende überhaupt gezeichnet wird, muss man diese für das Plot anzeigen:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="c1">// Legende anzeigen</span>
<span class="n">QwtLegend</span> <span class="o">*</span> <span class="n">legend</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">QwtLegend</span><span class="p">();</span>
<span class="n">QFont</span> <span class="n">legendFont</span><span class="p">;</span>
<span class="n">legendFont</span><span class="p">.</span><span class="n">setPointSize</span><span class="p">(</span><span class="mi">7</span><span class="p">);</span>
<span class="n">legend</span><span class="o">-&gt;</span><span class="n">setFont</span><span class="p">(</span><span class="n">legendFont</span><span class="p">);</span>
<span class="n">plot</span><span class="p">.</span><span class="n">insertLegend</span><span class="p">(</span><span class="n">legend</span><span class="p">,</span> <span class="n">QwtPlot</span><span class="o">::</span><span class="n">RightLegend</span><span class="p">);</span> <span class="c1">// plot takes ownership</span>

<span class="c1">// x-Achse verstecken</span>
<span class="n">plot</span><span class="p">.</span><span class="n">setAxisVisible</span><span class="p">(</span><span class="n">QwtPlot</span><span class="o">::</span><span class="n">xBottom</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/BarPlot_1_MultiColorWithLegend.png" alt="BarPlot 1 MultiColorWithLegend">
</div>
<div class="title">Abbildung 42. Balkendiagramm mit unterschiedlich gefärbten Balken und Legendeneinträgen</div>
</div>
</div>
<div class="sect2">
<h3 id="_gestapelte_balkendiagramme_oder_balkendiagramme_mit_mehreren_balken_pro_gruppe">6.9. Gestapelte Balkendiagramme oder Balkendiagramme mit mehreren Balken pro Gruppe</h3>

</div>
</div>
</div>
<div class="sect1">
<h2 id="sec:legend">7. Legende</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="sec:marker">8. Markierungslinien</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="sec:axes">9. Plotachsen</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Die Achsen/Skalen eines Plots (insgesamt 4, open, unten, links und rechts) können bereits in den mitgeliferten Klassenimplementierungen vielfältig angepasst und verändert werden.
Und natürlich können die beteiligten Klassen auch abgeleitet und so beliebig modifiziert/geändert werden.</p>
</div>
<div class="paragraph">
<p>Die wichtigsten Klassen in Bezug auf die Achsen sind:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>QwtAxis</code></p>
</li>
<li>
<p><code>QwtAbstractScaleDraw</code> und die Spezialisierungen <code>QwtScaleDraw</code> und <code>QwtDateScaleDraw</code></p>
</li>
<li>
<p><code>QwtScaleEngine`und die Spezialisierungen `QwtLinearScaleEngine`und `QwtLogScaleEngine</code></p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_allgemeine_achsenformatierung">9.1. Allgemeine Achsenformatierung</h3>

</div>
<div class="sect2">
<h3 id="sec:axisScales">9.2. Skalen</h3>

</div>
</div>
</div>
<div class="sect1">
<h2 id="sec:qwttext">10. QwtText und Sonderformatierungen</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="sec:mathML">10.1. MathML</h3>

</div>
</div>
</div>
<div class="sect1">
<h2 id="sec:zoomer">11. Interaktiver Zoom und Verschieben von Diagrammausschnitten</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="sec:styling">12. Anpassung/Styling der Qwt Komponenten</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_allgemeines_zu_farbpaletten">12.1. Allgemeines zu Farbpaletten</h3>
<div class="paragraph">
<p>Die Qwt-Komponenten verwenden die Qt Palette und deren Farbrollen für die Einfärbung.</p>
</div>
</div>
<div class="sect2">
<h3 id="_rahmen_und_zeichenfläche_des_diagramms">12.2. Rahmen und Zeichenfläche des Diagramms</h3>
<div class="paragraph">
<p>Beim QwtPlot können verschiedene Elemente angepasst werden. Nachfolgend ist ein QwtPlot zu sehen, welches in einem äußeren Widget (dunkelgrau) eingebettet ist. Die hellgraue Fläche ist das eigentliche <code>QwtPlot</code>:</p>
</div>
<div class="paragraph">
<p>![Rahmen und Zeichenfläche](imgs/plotStylingOverview.png)</p>
</div>
<div class="paragraph">
<p>Im Screenshot sind die wichtigsten Attribute markiert:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Innenabstand (siehe <code>QWidget::setContentsMargins()</code>)</p>
</li>
<li>
<p>Rahmen (hauptsächlich für den Druck wichtig)</p>
</li>
<li>
<p>Hintergrund des Plot-Widgets</p>
</li>
<li>
<p>Zeichenfläche (engl. <em>Canvas</em>) (betrifft Hintergrundfarbe und Rahmen)</p>
</li>
</ol>
</div>
<div class="sect3">
<h4 id="_farbe_und_rahmen_des_plots">12.2.1. Farbe und Rahmen des Plots</h4>
<div class="paragraph">
<p>Die Farbe des äußeren Bereichs des Plots wird über die Paletteneigenschaft des <code>QwtPlot</code> kontrolliert. Standardmäßig wird der äußere Rand des Plot-Widgets transparant gezeichnet, d.h. die Farbe des darunterliegenden Widgets ist sichtbar. Um eine eigene Farbe zu setzen, muss daher ```setAutoFillBackground(true)``` aufgerufen werden:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">QPalette</span> <span class="n">pal</span> <span class="o">=</span> <span class="n">plot</span><span class="p">.</span><span class="n">palette</span><span class="p">();</span>
<span class="c1">// Die QPalette::Window Farbrolle definiert die Einfärbung</span>
<span class="c1">// des äußeren Plotbereichs</span>
<span class="n">pal</span><span class="p">.</span><span class="n">setColor</span><span class="p">(</span><span class="n">QPalette</span><span class="o">::</span><span class="n">Window</span><span class="p">,</span> <span class="n">QColor</span><span class="p">(</span><span class="mi">196</span><span class="p">,</span><span class="mi">196</span><span class="p">,</span><span class="mi">220</span><span class="p">));</span>
<span class="n">plot</span><span class="o">-&gt;</span><span class="n">setPalette</span><span class="p">(</span><span class="n">pal</span><span class="p">);</span>
<span class="c1">// die Eigenschaft "autoFillBackground" muss dafür eingeschaltet sein</span>
<span class="n">plot</span><span class="o">-&gt;</span><span class="n">setAutoFillBackground</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>![](imgs/plotStyling1.png)</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p><strong>Hinweis:</strong> In Abschnitt [Gradient als Plot-Hintergrund](customization/#gradient-als-plot-hintergrund) wird beschrieben, wie man einen Farbverlauf im Plothintergrund umsetzt, und diesen bei Größenänderung entsprechend anpasst.</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>Der Rahmen wird wie bei einem normalen Widget angepasst:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">plot</span><span class="o">-&gt;</span><span class="n">setFrameStyle</span><span class="p">(</span><span class="n">QFrame</span><span class="o">::</span><span class="n">Box</span> <span class="o">|</span> <span class="n">QFrame</span><span class="o">::</span><span class="n">Sunken</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Normalerweise ist ein solcher Rahmen nicht notwendig für die Bildschirmdarstellung oder für das Einbetten des QwtPlot in eine Programmoberfläche. Der Rahmen ist jedoch häufig beim [Export/Druck](export) des Widgets sinnvoll.</p>
</div>
</div>
<div class="sect3">
<h4 id="_zeichenfläche">12.2.2. Zeichenfläche</h4>
<div class="paragraph">
<p>Die Zeichenfläche kann eingefärbt werden:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">plot</span><span class="o">-&gt;</span><span class="n">setCanvasBackground</span><span class="p">(</span><span class="n">Qt</span><span class="o">::</span><span class="n">darkGray</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>![](imgs/plotStyling3.png)</p>
</div>
<div class="paragraph">
<p>Der Randabstand zwischen Achsenbeschriftung und Titel zum Rand kann definiert werden:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">plot</span><span class="o">-&gt;</span><span class="n">setContentsMargins</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">35</span><span class="p">,</span><span class="mi">5</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>![](imgs/plotStyling4.png)</p>
</div>
<div class="paragraph">
<p>Die Rahmen um die Zeichenfläche kann durch Anpassen des Zeichenflächenobjekts (<code>QwtPlotCanvas</code>) verändert werden. <code>QwtPlotCanvas</code> ist von QFrame abgeleitet, wodurch es entsprechend angepasst werden kann. Es wird einfach neues Objekt erstellt, konfiguriert und dem Plot übergeben (das QwtPlot wird neuer Besitzer des Zeichenflächenobjekts):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">QwtPlotCanvas</span> <span class="o">*</span> <span class="n">canvas</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">QwtPlotCanvas</span><span class="p">(</span><span class="o">&amp;</span><span class="n">plot</span><span class="p">);</span>
<span class="n">canvas</span><span class="o">-&gt;</span><span class="n">setPalette</span><span class="p">(</span><span class="n">Qt</span><span class="o">::</span><span class="n">white</span><span class="p">);</span>
<span class="n">canvas</span><span class="o">-&gt;</span><span class="n">setFrameStyle</span><span class="p">(</span><span class="n">QFrame</span><span class="o">::</span><span class="n">Box</span> <span class="o">|</span> <span class="n">QFrame</span><span class="o">::</span><span class="n">Plain</span> <span class="p">);</span>
<span class="n">canvas</span><span class="o">-&gt;</span><span class="n">setLineWidth</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="n">plot</span><span class="o">-&gt;</span><span class="n">setCanvas</span><span class="p">(</span><span class="n">canvas</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>![](imgs/plotStyling5.png)</p>
</div>
<div class="paragraph">
<p>Einfacher geht es durch Setzen des Stylesheets für das Canvas-Widget (siehe Qt-Widgets Dokumentation, welche Attribute unterstützt werden):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">plot</span><span class="o">-&gt;</span><span class="n">canvas</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">setStyleSheet</span><span class="p">(</span>
    <span class="s">"border: 1px solid Black;"</span>
    <span class="s">"border-radius: 15px;"</span>
    <span class="s">"background-color: qlineargradient( x1: 0, y1: 0, x2: 0, y2: 1,"</span>
        <span class="s">"stop: 0 LemonChiffon, stop: 1 PaleGoldenrod );"</span>
<span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>![](imgs/plotStyling6.png)</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sec:print">13. Exportieren und Drucken</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Neben der Anzeige auf dem Bildschirm ist das Speichern schicker Diagramme und Verwendung dieser in Berichten eine nicht unwichtige Aufgabe. Allerdings ist es nicht trivial, gute Diagramme mit sinnvollen Schriftgrößen zu exportieren. Grundsätzlich muss hier zwischen Pixelgrafik-Export und Vektorgrafik unterschieden werden.</p>
</div>
<div class="sect2">
<h3 id="_exportieren_des_plots_als_pixelgrafik">13.1. Exportieren des Plots als Pixelgrafik</h3>
<div class="paragraph">
<p>Der naheliegenste Export des Plots ist eine 1-zu-1 Kopie in die Zwischenablage oder in eine Bitmapdatei (jpg, gif, png,&#8230;&#8203;).</p>
</div>
<div class="sect3">
<h4 id="_erstellen_einer_1_zu_1_kopie_des_plotwidgets">13.1.1. Erstellen einer 1-zu-1 Kopie des Plotwidgets</h4>
<div class="paragraph">
<p>Jedes QWidget kann direkt in eine QPixmap gezeichnet werden. Und dieses kann dann in eine Datei gespeichert werden.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="c1">// Plot in Pixmap rendern</span>
<span class="n">QPixmap</span> <span class="n">p</span> <span class="o">=</span> <span class="n">plot</span><span class="p">.</span><span class="n">grab</span><span class="p">();</span>
<span class="c1">// Pixmap in Datei speichern</span>
<span class="n">p</span><span class="p">.</span><span class="n">save</span><span class="p">(</span><span class="s">"diagramm_screenshot.png"</span><span class="p">);</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_kopie_in_die_zwischenablage">13.1.2. Kopie in die Zwischenablage</h4>
<div class="paragraph">
<p>Statt das Pixmap in eine Datei zu speichern, kann man das auch einfach in die Zwischenablage kopieren. Dazu <code>QClibBoard</code> und  <code>QApplication</code> einbinden und:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="c1">// Plot in Pixmap rendern</span>
<span class="n">QPixmap</span> <span class="n">p</span> <span class="o">=</span> <span class="n">plot</span><span class="p">.</span><span class="n">grab</span><span class="p">();</span>
<span class="c1">// Pixmap in Zwischenablage kopieren</span>
<span class="n">qApp</span><span class="o">-&gt;</span><span class="n">clipboard</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">setImage</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">toImage</span><span class="p">());</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_qwtplot_mit_anderer_auflösung_abspeichern">13.1.3. QwtPlot mit anderer Auflösung abspeichern</h4>
<div class="paragraph">
<p>Wenn das QwtPlot mit einer anderen Auflösung/Pixelgröße als angezeigt auf dem Bildschirm abgespeichert werden soll, so verwendet man die <code>QwtPlotRenderer</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="c1">// Render-Objekt erstellen</span>
<span class="n">QwtPlotRenderer</span> <span class="n">renderer</span><span class="p">;</span>
<span class="c1">// Statt der versenkten Box wird ein Rahmen mit Skalenstrichen gezeichnen</span>
<span class="n">renderer</span><span class="p">.</span><span class="n">setLayoutFlag</span><span class="p">(</span><span class="n">QwtPlotRenderer</span><span class="o">::</span><span class="n">FrameWithScales</span><span class="p">);</span>
<span class="c1">// Zielgröße festlegen</span>
<span class="n">QRect</span> <span class="nf">imageRect</span><span class="p">(</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mi">1200</span><span class="p">,</span> <span class="mi">600</span> <span class="p">);</span>
<span class="c1">// Bildobjekt in der entsprechenden Größe erstellen...</span>
<span class="n">QImage</span> <span class="nf">image</span><span class="p">(</span> <span class="n">imageRect</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">QImage</span><span class="o">::</span><span class="n">Format_ARGB32</span> <span class="p">);</span>
<span class="c1">// und mit weißem Hintergrund füllen</span>
<span class="n">image</span><span class="p">.</span><span class="n">fill</span><span class="p">(</span><span class="n">Qt</span><span class="o">::</span><span class="n">white</span><span class="p">);</span>

<span class="c1">// Das Diagramm in das QImage zeichnen</span>
<span class="n">QPainter</span> <span class="nf">painter</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">image</span> <span class="p">);</span>
<span class="n">renderer</span><span class="p">.</span><span class="n">render</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">plot</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">painter</span><span class="p">,</span> <span class="n">imageRect</span> <span class="p">);</span>
<span class="n">painter</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>

<span class="c1">// QImage zurück in Pixmap konvertieren</span>
<span class="n">QPixmap</span> <span class="nf">plotPixmap</span><span class="p">(</span> <span class="n">QPixmap</span><span class="o">::</span><span class="n">fromImage</span><span class="p">(</span><span class="n">image</span><span class="p">)</span> <span class="p">);</span>
<span class="n">plotPixmap</span><span class="p">.</span><span class="n">save</span><span class="p">(</span><span class="s">"diagram.png"</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Das Diagramm aus dem Tutorial 1 (<a href="#sec:tutorial1">Kapitel 2</a>) sieht dann z.B. so aus:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/Tutorial1_h.png" alt="Tutorial1 h">
</div>
<div class="title">Abbildung 43. Plot in höherer Auflösung abgespeichert</div>
</div>
</div>
<div class="sect3">
<h4 id="_diagrammelemente_skalieren_dpi_ändern">13.1.4. Diagrammelemente skalieren (DPI ändern)</h4>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_exportieren_des_plots_als_vektorgrafik">13.2. Exportieren des Plots als Vektorgrafik</h3>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect2">
<h3 id="_drucken">13.3. Drucken</h3>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_fortgeschrittene_themen">14. Fortgeschrittene Themen</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Die nachfolgend vorgestellten Themen greifen in die internen Datenstrukturen der Qwt-Bibliotheksklassen ein und diese könnten sich in zukünftigen Bibliotheksversionen sicher nocheinmal deutlich ändern.
Daher sind diese Techniken mit Vorsicht zu genießen!</p>
</div>
<div class="sect2">
<h3 id="sec:releasingObjectsFromQwtPlot">14.1. Objekte aus dem QwtPlot loslösen</h3>
<div class="paragraph">
<p>Die API des <code>QwtPlot</code> geht davon aus, dass Objekt beim Hinzufügen/Ersetzen existierender Plotelemente das Plot als neuen Eigentümer erhalten. Sobald ein Plotelement ein vorheriges Plotelement ersetzt, löscht das <code>QwtPlot</code> das alte Objekt automatisch. Es gibt keine <em>release</em>-Funktionen, wie man die von <em>shared pointer</em>-Implementierungen kennt. Daher kann man einmal hinzugefügte Objekte nicht entfernen, anpassen und wieder neu hinzufügen.</p>
</div>
<div class="paragraph">
<p>Die empfohlene Methode ist:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Plotelement neu erstellen</p>
</li>
<li>
<p>anpassen</p>
</li>
<li>
<p>das bisherige PlotElement ersetzen</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Mitunter ist dies aber nicht praktikabel und man hätte gerne eine Methode, um ein existierendes Objekt loszulösen. Man kann das aber mit einem Trick dennoch machen.</p>
</div>
<div class="paragraph">
<p>TODO&#8230;&#8203; erklären</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sec:building">15. Download/Installation/Erstellung der Qwt Bibliothek</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_download_fertiger_pakete">15.1. Download fertiger Pakete</h3>
<div class="sect3">
<h4 id="_windowsmac">15.1.1. Windows/Mac</h4>
<div class="paragraph">
<p>Auf diesen Plattformen würde ich immer das Bauen aus dem Quelltext empfehlen, da das hinreichend einfach ist (siehe <a href="#sec:buildingFromSource">Kapitel 15.2</a> unten).</p>
</div>
</div>
<div class="sect3">
<h4 id="_linux">15.1.2. Linux</h4>
<div class="paragraph">
<p>Unter Linux kann man auf die Pakete des Paketmanagers zurückgreifen.</p>
</div>
<div class="sect4">
<h5 id="_debianubuntu">Debian/Ubuntu</h5>
<div class="paragraph">
<p>Beispielsweise für Ubuntu 24.04:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sh"><span class="c"># Paket mit Headern für die Entwicklung</span>
<span class="nb">sudo </span>apt <span class="nb">install </span>libqwt-qt5-dev</code></pre>
</div>
</div>
<div class="paragraph">
<p>Headerdatei-Pfad:  <code>/usr/include/qwt</code></p>
</div>
<div class="paragraph">
<p>Für&#8217;s Deployment eigener Programme und als Abhängigkeit eigener Pakete reicht es, dass Paket  <code>libqwt-qt5-6</code> zu installieren.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="sec:buildingFromSource">15.2. Erstellung aus dem Quelltext</h3>
<div class="sect3">
<h4 id="_windows">15.2.1. Windows</h4>
<div class="ulist">
<ul>
<li>
<p>Release <code>qwt-6.3.0.zip</code>  herunterladen und entpacken.</p>
</li>
<li>
<p>Datei <code>qwtconfig.pri</code> bearbeiten und Optionen ein-/ausschalten</p>
</li>
<li>
<p>Kommandozeile mit Qt Umgebungsvariablen öffnen, z.B.: <em>Startmenu</em> &#8594; <em>Qt 5.15.2 (MinGW 8.1.0 64-bit)</em>, oder alternativ in der Commandozeile die benötigten Umgebungsvariablen setzen.</p>
</li>
<li>
<p>Ins Verzeichnis mit der <code>qwt.pro</code> wechseln</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In der Commandozeile wird erwartet, dass:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>der Compiler ausführbar d.h. im Suchpfad ist</p>
</li>
<li>
<p>der QTPATH gesetzt ist</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="_mingw3264">MinGW32/64</h5>
<div class="paragraph">
<p>Es wird eine MinGW32/64 Installation mit <code>mingw32-make</code> im PATH erwartet.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="bat"><span class="c">:: Makefile erstellen</span>
<span class="kd">qmake</span> <span class="kd">qwt</span>.pro
<span class="c">:: Bibliothek und Plugin/Beispiele bauen</span>
<span class="kd">mingw32</span><span class="na">-make -j</span><span class="m">8</span>
<span class="c">:: Biblithek installieren</span>
<span class="kd">mingw32</span><span class="na">-make </span><span class="kd">install</span></code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Die <code>-j8</code> sind für das parallele Bauen auf 8 CPUs.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_visual_studio_compiler">Visual Studio Compiler</h5>
<div class="paragraph">
<p>Es gibt verschiedene Compilerversionen, wobei 2017, 2019, 2022 oder VSCode aktuell üblich sind.
Eine vorbereitete Kommandozeile öffnet man am Besten über den vorbereiteten Startmenü-Link, welcher für 2019 ungefähr so heißt: <em>Entwickler-Eingabeaufforderung für VS 2019</em></p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Man muss hier darauf achten, dass man die richtige Variante wählt, also x86 oder x64.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Alternativ kann man auch eine normale Kommandozeile öffnen und danach die Compilerpfade und Optionen setzen.
Hier hilft es, die normalerweise über das Startmenü verknüpfte Batchdatei auszuführen:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="bat"><span class="s2">"</span><span class="vm">%ProgramFiles</span><span class="s2">(x86)</span><span class="err">%</span><span class="s2">\Microsoft Visual Studio\2019\Community\Common7\Tools\VsDevCmd.bat"</span> <span class="na">-arch</span><span class="o">=</span><span class="kd">amd64</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Gebaut wird mit jom:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="bat"><span class="c">:: Makefile erstellen</span>
<span class="kd">qmake</span> <span class="kd">qwt</span>.pro
<span class="c">:: Bibliothek und Plugin/Beispiele bauen</span>
<span class="kd">nmake</span>
<span class="c">:: Biblithek installieren</span>
<span class="kd">nmake</span> <span class="kd">install</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_installationsverzeichnisrelevante_pfade">Installationsverzeichnis/Relevante Pfade</h5>
<div class="paragraph">
<p>Sofern nicht in der Datei <code>qwtconfig.pri</code> ein anderer Installationspräfix in der Variable <code>QWT_INSTALL_PREFIX</code> eingestellt wurde, ist die Bibliothek nach dem Erstellen unter <code>c:\Qwt-6.3.0</code> installiert:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>c:\Qwt-6.3.0\include  - Header-Dateien
c:\Qwt-6.3.0\lib      - Bibliothek/DLLs
c:\Qwt-6.3.0\doc\html - API Dokumentation (`index.html` in diesem Verzeichnis öffnen)</pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_linuxmac">15.2.2. Linux/Mac</h4>

</div>
</div>
<div class="sect2">
<h3 id="sec:designerPlugins">15.3. Qt Designer Plugins</h3>
<div class="olist lowerroman">
<ol class="lowerroman" type="i">
<li>
<p>wie erstellt man die Designerplugins und bekommt die in die Komponentenpalette&#8230;&#8203;</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_verwendung_des_plots_in_eigenen_programmen">15.4. Verwendung des Plots in eigenen Programmen</h3>
<div class="sect3">
<h4 id="_windows_2">15.4.1. Windows</h4>

</div>
<div class="sect3">
<h4 id="_linuxmac_2">15.4.2. Linux/Mac</h4>

</div>
</div>
<div class="sect2">
<h3 id="sec:usingQwtPlot">15.5. Das QwtPlot in eine Designer-Oberfläche/ui-Datei integrieren</h3>
<div class="paragraph">
<p>Wenn man mittels Qt Designer eine Programmoberfläche baut, möchte man da vielleicht auch ein <code>QwtPlot</code> einbetten. Das kann man auf zwei verschiedene Arten machen:</p>
</div>
<div class="olist loweralpha">
<ol class="loweralpha">
<li>
<p>ein QWidget als Platzhalter einfügen und zu einem Platzhalterwidget für das <code>QwtPlot</code> machen, oder</p>
</li>
<li>
<p>die Qwt-Designer-Plugins verwenden.</p>
</li>
</ol>
</div>
<div class="sect3">
<h4 id="_definition_eines_platzhalterwidgets">15.5.1. Definition eines Platzhalterwidgets</h4>
<div class="paragraph">
<p>Zur Erklärung wird im Qt Designer ein einfaches Widget entworfen:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/Tutorial1_ui1.png" alt="Tutorial1 ui1">
</div>
<div class="title">Abbildung 44. Widget mit Platzhalter-Widget für das Diagramm</div>
</div>
<div class="paragraph">
<p>Unter der Spinbox wurde ein <code>QWidget</code> eingefügt. Dieses soll nun als Platzhalter für das <code>QwtPlot</code> dienen. Dazu im Kontextmenü des Widgets die Option "Als Platzhalter für benutzerdefinierte Klasse festlegen&#8230;&#8203;" auswählen:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/Tutorial1_ui2.png" alt="Tutorial1 ui2">
</div>
</div>
<div class="paragraph">
<p>Und im Dialog eine neue Platzhalterklasse wie folgt definieren:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/Tutorial1_ui3.png" alt="Tutorial1 ui3">
</div>
</div>
<div class="paragraph">
<p>Die Eingabe mit "Hinzufügen" bestätigen und dann auf "Anwenden" klicken, um das Platzhalter-Widget in das <code>QwtPlot</code> zu wandeln. Wir benennen das noch in <em>plot</em> um, und füge das horizontale Layout und das Plotwidget in ein vertikales Layout ein:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/Tutorial1_ui4.png" alt="Tutorial1 ui4">
</div>
</div>
<div class="paragraph">
<p>Damit sich das Plotwidget den ganzen vertikalen Platz schnappt, wählt man das Top-Level Widget aus und scrollt in der Eigenschaftsleiste bis nach unten zu den Einstellungen für das vertikale Layout. Dort gibt man bei den Stretch-Faktoren "0,1" ein, wodurch sich das 2. Widget im Layout (das Plot) komplett ausdehnt.</p>
</div>
</div>
<div class="sect3">
<h4 id="_verwendung_der_designer_plugins">15.5.2. Verwendung der Designer-Plugins</h4>
<div class="paragraph">
<p>Dazu muss man die QtDesigner-Plugins zunächst erstellen und integrieren.</p>
</div>
<div class="paragraph">
<p>TODO :</p>
</div>
<div class="paragraph">
<p>Wenn man die erstmal installiert hat, kann man ein <code>QwtPlot</code> direkt aus der Komponentenpalette in den Entwurf zeihen und ist fertig.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_über_den_autor">16. Über den Autor</h2>
<div class="sectionbody">
<div class="olist lowerroman">
<ol class="lowerroman" type="i">
<li>
<p>später, siehe <a href="https://schneggenport.de">https://schneggenport.de</a></p>
</li>
</ol>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Version 1.0.0<br>
Last updated 2025-06-05 20:35:53 +0200
</div>
</div>
</body>
</html>